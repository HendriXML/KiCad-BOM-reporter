<?xml version="1.0" encoding="utf-8" standalone="no"?>
<pkg:Library
  xsi:schemaLocation="urn:schemas-www-wisware.nl-scriptingpackages ../XmlSchemas.Common.XmlScript/XMLScripting.Packages.xsd"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xmlns="urn:schemas-www-wisware.nl-xmlscripting"
  xmlns:fil="urn:schemas-www-wisware.nl-xmlscripting-filemanagement"
  xmlns:fw="urn:schemas-www-wisware.nl-xmlscripting-windowsfirewall"
  xmlns:su="urn:schemas-www-wisware.nl-xmlscripting-sysutils"
  xmlns:reg="urn:schemas-www-wisware.nl-xmlscripting-registry"
  xmlns:indx="urn:schemas-www-wisware.nl-xmlscripting-index"
  xmlns:rep="urn:schemas-www-wisware.nl-xmlscripting-report"
  xmlns:sts="urn:schemas-www-wisware.nl-xmlscripting-showstatus"
  xmlns:sys="urn:schemas-www-wisware.nl-xmlscripting"
  xmlns:msx="urn:schemas-www-wisware.nl-xmlscripting-xml"
  xmlns:pkg="urn:schemas-www-wisware.nl-scriptingpackages">
  <sys:Type>
    <Enumeration Identifier="TPrefix" Elements="pfTera, pfGiga, pfMega, pfKilo, pfNone, pfMilli, pfMicro, pfNano, pfPico, pfFemto"/>
    <Enumeration Identifier="TDisplayUnitType" Elements="duMicroVoltage, duMicroAmp, duMicroResistance, duFemtoCapacitance, duFemtoInductance, duMicroPercentage, duMicroPower"/>
    <Enumeration Identifier="TFactorType" Elements="ftFemto, ftMicro, ftMicroAsSingle"/>
    <Enumeration Identifier="TESerie" Elements="E3, E6, E12, E24, E48, E96, E192"/>
    <Enumeration Identifier="TMatchValueKind" Elements="LessOrEqual, MoreOrEqual, Closest"/>

    <sys:DataClass Identifier="TSerieNode">
      <sys:Field Identifier="Value" Type="UInt32"/>
      <sys:Field Identifier="LowSerie" Type="TESerie"/>
      <sys:Field Identifier="Previous" Type="TSerieNode"/>
      <sys:Field Identifier="Next" Type="TSerieNode"/>
      <sys:Field Identifier="Less" Type="TSerieNode"/>
      <sys:Field Identifier="More" Type="TSerieNode"/>
    </sys:DataClass>

    <sys:DataClass Identifier="TSerie" DefaultConstructor="none">
      <sys:Field Identifier="Scale" Type="UInt32"/>
      <sys:Field Identifier="Head" Type="TSerieNode"/>
      <sys:Field Identifier="Tail" Type="TSerieNode"/>
      <sys:Field Identifier="Root" Type="TSerieNode"/>
      <sys:Field Identifier="OverFlowFactor" Type="Int64"/>
    </sys:DataClass>
  </sys:Type>
  <Constants>
    <Constant Identifier="MaxInt64" Type="Int64" Expression="9223372036854775807"/>
    <Constant Identifier="CopperResistivity" Type="Extended" Expression="1.75E-8"/>

    <Constant Identifier="cYotta" Type="Char" Expression="'Y'"/>
    <Constant Identifier="cZetta" Type="Char" Expression="'Z'"/>
    <Constant Identifier="cExa" Type="Char" Expression="'E'"/>
    <Constant Identifier="cPeta" Type="Char" Expression="'P'"/>
    <Constant Identifier="cTera" Type="Char" Expression="'T'"/>
    <Constant Identifier="cGiga" Type="Char" Expression="'G'"/>
    <Constant Identifier="cMega" Type="Char" Expression="'M'"/>
    <Constant Identifier="cKilo" Type="Char" Expression="'k'"/>
    <Constant Identifier="cHecto" Type="Char" Expression="'h'"/>
    <Constant Identifier="cDeca" Type="string" Expression="'da'"/>
    <Constant Identifier="cDeci" Type="Char" Expression="'d'"/>
    <Constant Identifier="cCenti" Type="Char" Expression="'c'"/>
    <Constant Identifier="cMilli" Type="Char" Expression="'m'"/>
    <Constant Identifier="cMicro" Type="Char" Expression="'μ'"/>
    <Constant Identifier="cMicroAlt" Type="Char" Expression="'µ'"/>
    <Constant Identifier="cMicroAlt2" Type="Char" Expression="'u'"/>
    <Constant Identifier="cNano" Type="Char" Expression="'n'"/>
    <Constant Identifier="cPico" Type="Char" Expression="'p'"/>
    <Constant Identifier="cFemto" Type="Char" Expression="'f'"/>
    <Constant Identifier="cAtto" Type="Char" Expression="'a'"/>
    <Constant Identifier="cZepto" Type="Char" Expression="'z'"/>
    <Constant Identifier="cYocto" Type="Char" Expression="'y'"/>
    <Constant Identifier="sKibi" Type="string" Expression="'Ki'"/>
    <Constant Identifier="sMebi" Type="string" Expression="'Mi'"/>
    <Constant Identifier="sGibi" Type="string" Expression="'Gi'"/>
    <Constant Identifier="sTebi" Type="string" Expression="'Ti'"/>
    <Constant Identifier="sPebi" Type="string" Expression="'Pi'"/>
    <Constant Identifier="sExbi" Type="string" Expression="'Ei'"/>
    <Constant Identifier="sZebi" Type="string" Expression="'Zi'"/>
    <Constant Identifier="sYobi" Type="string" Expression="'Yi'"/>

    <Constant Identifier="cOhm" Type="Char" Expression="'Ω'"/>
    <Constant Identifier="cWatt" Type="Char" Expression="'W'"/>
    <Constant Identifier="cFarad" Type="Char" Expression="'F'"/>
    <Constant Identifier="cHenry" Type="Char" Expression="'H'"/>
    <Constant Identifier="cVolt" Type="Char" Expression="'V'"/>
    <Constant Identifier="cAmp" Type="Char" Expression="'A'"/>
    <Constant Identifier="cPerc" Type="Char" Expression="'%'"/>
    <Constant Identifier="cHz" Type="string" Expression="'hz'"/>
    <Constant Identifier="cMeter" Type="Char" Expression="'m'"/>

    <Constant Identifier="k" Type="Integer" Expression="1000"/>
    <Constant Identifier="M" Type="Integer" Expression="1000 * k"/>
    <Constant Identifier="G" Type="Integer" Expression="1000 * M"/>
    <Constant Identifier="facMicroToMicro" Type="Int64" Expression="1"/>
    <Constant Identifier="facMilliToMicro" Type="Int64" Expression="k*facMicroToMicro"/>
    <Constant Identifier="facToMicro" Type="Int64" Expression="k*facMilliToMicro"/>
    <Constant Identifier="facKiloToMicro" Type="Int64" Expression="k*facToMicro"/>
    <Constant Identifier="facMegaToMicro" Type="Int64" Expression="k*facKiloToMicro"/>
    <Constant Identifier="facGigaToMicro" Type="Int64" Expression="k*facMegaToMicro"/>

    <Constant Identifier="facFemtoToFemto" Type="Int64" Expression="1"/>
    <Constant Identifier="facPicoToFemto" Type="Int64" Expression="k*facFemtoToFemto"/>
    <Constant Identifier="facNanoToFemto" Type="Int64" Expression="k*facPicoToFemto"/>
    <Constant Identifier="facMicroToFemto" Type="Int64" Expression="k*facNanoToFemto"/>
    <Constant Identifier="facMilliToFemto" Type="Int64" Expression="k*facMicroToFemto"/>
    <Constant Identifier="facToFemto" Type="Int64" Expression="k*facMilliToFemto"/>
    <Constant Identifier="facKiloToFemto" Type="Int64" Expression="k*facToFemto"/>
    
    <Constant Identifier="nano" Type="Extended" Expression="1/1000000000"/>
    <Constant Identifier="micro" Type="Extended" Expression="1/1000000"/>
    <Constant Identifier="Milli" Type="Extended" Expression="1/1000"/>
  </Constants>
  <sys:Variables>
    <sys:Variable Identifier="_E192Serie" Type="TSerie"/>
    <sys:Variable Identifier="_E96Serie" Type="TSerie"/>
    <sys:Variable Identifier="_E48Serie" Type="TSerie"/>
    <sys:Variable Identifier="_E24Serie" Type="TSerie"/>
    <sys:Variable Identifier="_E12Serie" Type="TSerie"/>
    <sys:Variable Identifier="_E6Serie" Type="TSerie"/>
    <sys:Variable Identifier="_E3Serie" Type="TSerie"/>
  </sys:Variables>
  <Procedures>
    <Function Identifier="DecodeReference" Type="Boolean">
      <Parameters>
        <Parameter Identifier="Reference" Type="string"/>
        <Parameter Identifier="Prefix" Type="string" Direction="Output"/>
        <Parameter Identifier="Counter" Type="UInt32" Direction="Output"/>
      </Parameters>
      <Type>
        <Enumeration Identifier="TState" Elements="stStart, stInPrefix, stInNum, stInEndWhitespace"/>
      </Type>
      <Variables>
        <Variable Identifier="State" Type="TState" Init="TState.stStart"/>
        <Variable Identifier="locCounter" Type="UInt64"/>
        <Variable Identifier="locPrefix" Type="string"/>
      </Variables>
      <Block>
        <Execute Statement="Result:= False"/>
        <StringLoop StringValue="Reference" OrdinalIdentifier="ChrI" CharacterIdentifier="Chr">
          <Case Expression="State" Optimalisation="integermapping">
            <On Select="TState.stStart">
              <Case Expression="ChrI" Optimalisation="integermapping" OrdinalType="widechar">
                <On Select="' ', #9">
                </On>
                <On Select="'a'..'z', 'A'..'Z'">
                  <Execute Statement="locPrefix:= Chr"/>
                  <Execute Statement="State:= TState.stInPrefix"/>
                </On>
                <Otherwise>
                  <Exit/>
                </Otherwise>
              </Case>
            </On>
            <On Select="TState.stInPrefix">
              <Case Expression="ChrI" Optimalisation="integermapping" OrdinalType="widechar">
                <On Select="'a'..'z', 'A'..'Z'">
                  <Execute Statement="locPrefix:= locPrefix + Chr"/>
                </On>
                <On Select="'0'..'9'">
                  <Execute Statement="locCounter:= ChrI - CharOrd('0')"/>
                  <Execute Statement="State:= TState.stInNum"/>
                </On>
                <Otherwise>
                  <Exit/>
                </Otherwise>
              </Case>
            </On>
            <On Select="TState.stInNum">
              <Case Expression="ChrI" Optimalisation="integermapping" OrdinalType="widechar">
                <On Select="' ', #9">
                  <Execute Statement="State:= TState.stInEndWhitespace"/>
                </On>
                <On Select="'0'..'9'">
                  <Execute Statement="locCounter:= locCounter * 10 + (ChrI - CharOrd('0'))"/>
                </On>
                <Otherwise>
                  <Exit/>
                </Otherwise>
              </Case>
            </On>
            <On Select="TState.stInEndWhitespace">
              <Case Expression="ChrI" Optimalisation="integermapping" OrdinalType="widechar">
                <On Select="' ', #9">
                </On>
                <Otherwise>
                  <Exit/>
                </Otherwise>
              </Case>
            </On>
          </Case>
        </StringLoop>
        <Case Expression="State" Optimalisation="integermapping">
          <On Select="TState.stInNum, TState.stInEndWhitespace">
            <Execute Statement="Counter:= locCounter"/>
            <Execute Statement="Prefix:= locPrefix"/>
            <Execute Statement="Result:= True"/>
            <!--<rep:Reporter.Information Text="Format('%s = %s - %d', Reference, Prefix, Counter)"/>-->
          </On>
        </Case>
      </Block>
    </Function>

    <!--Non standard micro formatting-->
    <Function Identifier="StrToMicroOhms" Type="Boolean">
      <Parameters>
        <Parameter Identifier="TextValue" Type="string"/>
        <Parameter Identifier="MicroValue" Type="Int64" Direction="Output"/>
      </Parameters>
      <Type>
        <Enumeration Identifier="TState" Elements="stStart, stInNum, stAfterPrefix, stInPrefixFrac, stAfterDecimalChar, stInDecimalFrac, stAfterDecimalPrefix, stFinal"/>
      </Type>
      <Constants>
        <Constant Identifier="cUnit" Type="Char" Expression="cOhm"/>
      </Constants>
      <Variables>
        <Variable Identifier="State" Type="TState" Init="TState.stStart"/>
        <Variable Identifier="Num" Type="UInt64"/>
        <Variable Identifier="Factor" Type="UInt64" Init="facToMicro"/>
        <Variable Identifier="Frac" Type="UInt64"/>
        <Variable Identifier="FracValue" Type="UInt64"/>
        <Variable Identifier="FracDiv" Type="UInt64"/>
        <Variable Identifier="CheckMicroValue" Type="Int64" DisabledChecks="error"/>
      </Variables>
      <Block>
        <Execute Statement="Result:= False"/>
        <StringLoop StringValue="TextValue" OrdinalIdentifier="ChrI">
          <Case Expression="State" Optimalisation="integermapping">
            <On Select="TState.stStart">
              <Case Expression="ChrI" Optimalisation="integermapping" OrdinalType="widechar">
                <On Select="' ', #9">
                </On>
                <On Select="'0'..'9'">
                  <Execute Statement="Num:= ChrI - CharOrd('0')"/>
                  <Execute Statement="State:= TState.stInNum"/>
                  <rep:Reporter.Information Text="Format('Num: %d', Num)" Condition="IsVerbose"/>
                </On>
                <Otherwise>
                  <Exit Result="False"/>
                </Otherwise>
              </Case>
            </On>
            <On Select="TState.stInNum">
              <Case Expression="ChrI" Optimalisation="integermapping" OrdinalType="widechar">
                <On Select="'0'..'9'">
                  <Execute Statement="Num:= Num * 10 + ChrI - CharOrd('0')"/>
                  <rep:Reporter.Information Text="Format('Num: %d', Num)" Condition="IsVerbose"/>
                </On>
                <On Select="cUnit">
                  <Execute Statement="State:= TState.stFinal"/>
                  <rep:Reporter.Information Text="'Final'" Condition="IsVerbose"/>
                </On>
                <On Select="cGiga">
                  <Execute Statement="State:= TState.stAfterPrefix"/>
                  <Execute Statement="Factor:= facGigaToMicro"/>
                  <rep:Reporter.Information Text="Format('Factor: %d', Factor)" Condition="IsVerbose"/>
                </On>
                <On Select="cMega">
                  <Execute Statement="State:= TState.stAfterPrefix"/>
                  <Execute Statement="Factor:= facMegaToMicro"/>
                  <rep:Reporter.Information Text="Format('Factor: %d', Factor)" Condition="IsVerbose"/>
                </On>
                <On Select="cKilo">
                  <Execute Statement="State:= TState.stAfterPrefix"/>
                  <Execute Statement="Factor:= facKiloToMicro"/>
                  <rep:Reporter.Information Text="Format('Factor: %d', Factor)" Condition="IsVerbose"/>
                </On>
                <On Select="'R', 'E'">
                  <Execute Statement="State:= TState.stAfterPrefix"/>
                  <rep:Reporter.Information Text="Format('Factor: %d', Factor)" Condition="IsVerbose"/>
                </On>
                <On Select="cMilli">
                  <Execute Statement="State:= TState.stAfterPrefix"/>
                  <Execute Statement="Factor:= facMilliToMicro"/>
                  <rep:Reporter.Information Text="Format('Factor: %d', Factor)" Condition="IsVerbose"/>
                </On>
                <On Select="',', '.'">
                  <Execute Statement="State:= TState.stAfterDecimalChar"/>
                </On>
                <Otherwise>
                  <Exit Result="False"/>
                </Otherwise>
              </Case>
            </On>
            <On Select="TState.stAfterPrefix">
              <Case Expression="ChrI" Optimalisation="integermapping" OrdinalType="widechar">
                <On Select="'0'..'9'">
                  <Execute Statement="Frac:= ChrI - CharOrd('0')"/>
                  <Execute Statement="FracDiv:= 10"/>
                  <Execute Statement="State:= TState.stInPrefixFrac"/>
                  <rep:Reporter.Information Text="Format('Frac: %d', Frac)" Condition="IsVerbose"/>
                  <rep:Reporter.Information Text="Format('FracDiv: %d', FracDiv)" Condition="IsVerbose"/>
                </On>
                <On Select="cUnit">
                  <Execute Statement="State:= TState.stFinal"/>
                  <rep:Reporter.Information Text="'Final'" Condition="IsVerbose"/>
                </On>
                <Otherwise>
                  <Exit Result="False"/>
                </Otherwise>
              </Case>
            </On>
            <On Select="TState.stAfterDecimalChar">
              <Case Expression="ChrI" Optimalisation="integermapping" OrdinalType="widechar">
                <On Select="'0'..'9'">
                  <Execute Statement="Frac:= ChrI - CharOrd('0')"/>
                  <Execute Statement="FracDiv:= 10"/>
                  <Execute Statement="State:= TState.stInDecimalFrac"/>
                  <rep:Reporter.Information Text="Format('Frac: %d', Frac)" Condition="IsVerbose"/>
                  <rep:Reporter.Information Text="Format('FracDiv: %d', FracDiv)" Condition="IsVerbose"/>
                </On>
                <Otherwise>
                  <Exit Result="False"/>
                </Otherwise>
              </Case>
            </On>
            <On Select="TState.stInPrefixFrac">
              <Case Expression="ChrI" Optimalisation="integermapping" OrdinalType="widechar">
                <On Select="'0'..'9'">
                  <Execute Statement="Frac:= Frac * 10 + ChrI - CharOrd('0')"/>
                  <Execute Statement="FracDiv:= FracDiv * 10"/>
                  <rep:Reporter.Information Text="Format('Frac: %d', Frac)" Condition="IsVerbose"/>
                  <rep:Reporter.Information Text="Format('FracDiv: %d', FracDiv)" Condition="IsVerbose"/>
                </On>
                <On Select="cUnit">
                  <Execute Statement="State:= TState.stFinal"/>
                  <rep:Reporter.Information Text="'Final'" Condition="IsVerbose"/>
                </On>
                <Otherwise>
                  <Exit Result="False"/>
                </Otherwise>
              </Case>
            </On>
            <On Select="TState.stInDecimalFrac">
              <Case Expression="ChrI" Optimalisation="integermapping" OrdinalType="widechar">
                <On Select="'0'..'9'">
                  <Execute Statement="Frac:= Frac * 10 + ChrI - CharOrd('0')"/>
                  <Execute Statement="FracDiv:= FracDiv * 10"/>
                  <rep:Reporter.Information Text="Format('Frac: %d', Frac)" Condition="IsVerbose"/>
                  <rep:Reporter.Information Text="Format('FracDiv: %d', FracDiv)" Condition="IsVerbose"/>
                </On>
                <On Select="cUnit">
                  <Execute Statement="State:= TState.stFinal"/>
                  <rep:Reporter.Information Text="'Final'" Condition="IsVerbose"/>
                </On>
                <On Select="cGiga">
                  <Execute Statement="State:= TState.stAfterDecimalPrefix"/>
                  <Execute Statement="Factor:= facGigaToMicro"/>
                  <rep:Reporter.Information Text="Format('Factor: %d', Factor)" Condition="IsVerbose"/>
                </On>
                <On Select="cMega">
                  <Execute Statement="State:= TState.stAfterDecimalPrefix"/>
                  <Execute Statement="Factor:= facMegaToMicro"/>
                  <rep:Reporter.Information Text="Format('Factor: %d', Factor)" Condition="IsVerbose"/>
                </On>
                <On Select="cKilo">
                  <Execute Statement="State:= TState.stAfterDecimalPrefix"/>
                  <Execute Statement="Factor:= facKiloToMicro"/>
                  <rep:Reporter.Information Text="Format('Factor: %d', Factor)" Condition="IsVerbose"/>
                </On>
                <On Select="cMilli">
                  <Execute Statement="State:= TState.stAfterPrefix"/>
                  <Execute Statement="Factor:= facMilliToMicro"/>
                  <rep:Reporter.Information Text="Format('Factor: %d', Factor)" Condition="IsVerbose"/>
                </On>
                <Otherwise>
                  <Exit Result="False"/>
                </Otherwise>
              </Case>
            </On>
            <On Select="TState.stFinal">
              <Case Expression="ChrI" Optimalisation="integermapping" OrdinalType="widechar">
                <On Select="' ', #9">
                </On>
                <Otherwise>
                  <Exit Result="False"/>
                </Otherwise>
              </Case>
            </On>
          </Case>
        </StringLoop>
        <Case Expression="State" Optimalisation="integermapping">
          <On Select="TState.stStart">
            <Exit Result="False"/>
          </On>
          <On Select="TState.stInNum, TState.stFinal, TState.stAfterPrefix, TState.stInPrefixFrac, TState.stAfterDecimalPrefix, TState.stInDecimalFrac">
            <Choose>
              <When Expression="IsEmpty(Frac)">
                <Execute Statement="CheckMicroValue:= Num * Factor"/>
              </When>
              <Otherwise>
                <WhileLoop Expression="(Frac &gt; 0) and ((Frac mod 10) = 0)">
                  <Execute Statement="Frac:= Frac div 10"/>
                  <Execute Statement="FracDiv:= FracDiv div 10"/>
                </WhileLoop>
                <Exit Condition="FracDiv &gt; Factor" Result="False"/>
                <Execute Statement="CheckMicroValue:= Num * Factor + (Factor div FracDiv) * Frac"/>
              </Otherwise>
            </Choose>
            <Exit Condition="IsError(CheckMicroValue)"/>
            <Execute Statement="MicroValue:= CheckMicroValue"/>
            <Exit Result="True"/>
          </On>
        </Case>
      </Block>
    </Function>

    <Function Identifier="StrValueToMicroVolts" Type="Boolean">
      <Parameters>
        <Parameter Identifier="TextValue" Type="string"/>
        <Parameter Identifier="MicroValue" Type="Int64" Direction="Output"/>
      </Parameters>
      <Type>
        <Enumeration Identifier="TState" Elements="stStart, stInNum, stAfterPrefix, stAfterUnit, stInPrefixFrac, stAfterDecimalChar, stInDecimalFrac, stAfterDecimalPrefix, stFinal"/>
      </Type>
      <Constants>
        <Constant Identifier="cUnit" Type="Char" Expression="cVolt"/>
      </Constants>
      <Variables>
        <Variable Identifier="State" Type="TState" Init="TState.stStart"/>
        <Variable Identifier="Num" Type="UInt64"/>
        <Variable Identifier="Factor" Type="UInt64" Init="facToMicro"/>
        <Variable Identifier="Frac" Type="UInt64"/>
        <Variable Identifier="FracValue" Type="UInt64"/>
        <Variable Identifier="FracDiv" Type="UInt64"/>
        <Variable Identifier="CheckMicroValue" Type="Int64" DisabledChecks="error"/>
      </Variables>
      <Block>
        <Execute Statement="Result:= False"/>
        <StringLoop StringValue="TextValue" OrdinalIdentifier="ChrI">
          <Case Expression="State" Optimalisation="integermapping">
            <On Select="TState.stStart">
              <Case Expression="ChrI" Optimalisation="integermapping" OrdinalType="widechar">
                <On Select="' ', #9">
                </On>
                <On Select="'0'..'9'">
                  <Execute Statement="Num:= ChrI - CharOrd('0')"/>
                  <Execute Statement="State:= TState.stInNum"/>
                  <rep:Reporter.Information Text="Format('Num: %d', Num)" Condition="IsVerbose"/>
                </On>
                <Otherwise>
                  <Exit Result="False"/>
                </Otherwise>
              </Case>
            </On>
            <On Select="TState.stInNum">
              <Case Expression="ChrI" Optimalisation="integermapping" OrdinalType="widechar">
                <On Select="'0'..'9'">
                  <Execute Statement="Num:= Num * 10 + ChrI - CharOrd('0')"/>
                  <rep:Reporter.Information Text="Format('Num: %d', Num)" Condition="IsVerbose"/>
                </On>
                <On Select="cUnit">
                  <Execute Statement="State:= TState.stAfterUnit"/>
                  <rep:Reporter.Information Text="'Unit'" Condition="IsVerbose"/>
                </On>
                <On Select="cKilo">
                  <Execute Statement="State:= TState.stAfterPrefix"/>
                  <Execute Statement="Factor:= facKiloToMicro"/>
                  <rep:Reporter.Information Text="Format('Factor: %d', Factor)" Condition="IsVerbose"/>
                </On>
                <On Select="cMilli">
                  <Execute Statement="State:= TState.stAfterPrefix"/>
                  <Execute Statement="Factor:= facMilliToMicro"/>
                  <rep:Reporter.Information Text="Format('Factor: %d', Factor)" Condition="IsVerbose"/>
                </On>
                <On Select="',', '.'">
                  <Execute Statement="State:= TState.stAfterDecimalChar"/>
                </On>
                <Otherwise>
                  <Exit Result="False"/>
                </Otherwise>
              </Case>
            </On>
            <On Select="TState.stAfterUnit">
              <Case Expression="ChrI" Optimalisation="integermapping" OrdinalType="widechar">
                <On Select="'0'..'9'">
                  <Execute Statement="Frac:= ChrI - CharOrd('0')"/>
                  <Execute Statement="FracDiv:= 10"/>
                  <Execute Statement="State:= TState.stInPrefixFrac"/>
                  <rep:Reporter.Information Text="Format('Frac: %d', Frac)" Condition="IsVerbose"/>
                  <rep:Reporter.Information Text="Format('FracDiv: %d', FracDiv)" Condition="IsVerbose"/>
                </On>
                <On Select="' ', #9">
                  <Execute Statement="State:= TState.stFinal"/>
                </On>
                <Otherwise>
                  <Exit Result="False"/>
                </Otherwise>
              </Case>
            </On>
            <On Select="TState.stAfterPrefix">
              <Case Expression="ChrI" Optimalisation="integermapping" OrdinalType="widechar">
                <On Select="'0'..'9'">
                  <Execute Statement="Frac:= ChrI - CharOrd('0')"/>
                  <Execute Statement="FracDiv:= 10"/>
                  <Execute Statement="State:= TState.stInPrefixFrac"/>
                  <rep:Reporter.Information Text="Format('Frac: %d', Frac)" Condition="IsVerbose"/>
                  <rep:Reporter.Information Text="Format('FracDiv: %d', FracDiv)" Condition="IsVerbose"/>
                </On>
                <On Select="cUnit">
                  <Execute Statement="State:= TState.stFinal"/>
                  <rep:Reporter.Information Text="'Final'" Condition="IsVerbose"/>
                </On>
                <Otherwise>
                  <Exit Result="False"/>
                </Otherwise>
              </Case>
            </On>
            <On Select="TState.stAfterDecimalChar">
              <Case Expression="ChrI" Optimalisation="integermapping" OrdinalType="widechar">
                <On Select="'0'..'9'">
                  <Execute Statement="Frac:= ChrI - CharOrd('0')"/>
                  <Execute Statement="FracDiv:= 10"/>
                  <Execute Statement="State:= TState.stInDecimalFrac"/>
                  <rep:Reporter.Information Text="Format('Frac: %d', Frac)" Condition="IsVerbose"/>
                  <rep:Reporter.Information Text="Format('FracDiv: %d', FracDiv)" Condition="IsVerbose"/>
                </On>
                <Otherwise>
                  <Exit Result="False"/>
                </Otherwise>
              </Case>
            </On>
            <On Select="TState.stInPrefixFrac">
              <Case Expression="ChrI" Optimalisation="integermapping" OrdinalType="widechar">
                <On Select="'0'..'9'">
                  <Execute Statement="Frac:= Frac * 10 + ChrI - CharOrd('0')"/>
                  <Execute Statement="FracDiv:= FracDiv * 10"/>
                  <rep:Reporter.Information Text="Format('Frac: %d', Frac)" Condition="IsVerbose"/>
                  <rep:Reporter.Information Text="Format('FracDiv: %d', FracDiv)" Condition="IsVerbose"/>
                </On>
                <On Select="cUnit">
                  <Execute Statement="State:= TState.stFinal"/>
                  <rep:Reporter.Information Text="'Final'" Condition="IsVerbose"/>
                </On>
                <Otherwise>
                  <Exit Result="False"/>
                </Otherwise>
              </Case>
            </On>
            <On Select="TState.stInDecimalFrac">
              <Case Expression="ChrI" Optimalisation="integermapping" OrdinalType="widechar">
                <On Select="'0'..'9'">
                  <Execute Statement="Frac:= Frac * 10 + ChrI - CharOrd('0')"/>
                  <Execute Statement="FracDiv:= FracDiv * 10"/>
                  <rep:Reporter.Information Text="Format('Frac: %d', Frac)" Condition="IsVerbose"/>
                  <rep:Reporter.Information Text="Format('FracDiv: %d', FracDiv)" Condition="IsVerbose"/>
                </On>
                <On Select="cUnit">
                  <Execute Statement="State:= TState.stFinal"/>
                  <rep:Reporter.Information Text="'Final'" Condition="IsVerbose"/>
                </On>
                <On Select="cKilo">
                  <Execute Statement="State:= TState.stAfterDecimalPrefix"/>
                  <Execute Statement="Factor:= facKiloToMicro"/>
                  <rep:Reporter.Information Text="Format('Factor: %d', Factor)" Condition="IsVerbose"/>
                </On>
                <On Select="cMilli">
                  <Execute Statement="State:= TState.stAfterPrefix"/>
                  <Execute Statement="Factor:= facMilliToMicro"/>
                  <rep:Reporter.Information Text="Format('Factor: %d', Factor)" Condition="IsVerbose"/>
                </On>
                <Otherwise>
                  <Exit Result="False"/>
                </Otherwise>
              </Case>
            </On>
            <On Select="TState.stFinal">
              <Case Expression="ChrI" Optimalisation="integermapping" OrdinalType="widechar">
                <On Select="' ', #9">
                </On>
                <Otherwise>
                  <Exit Result="False"/>
                </Otherwise>
              </Case>
            </On>
          </Case>
        </StringLoop>
        <Case Expression="State" Optimalisation="integermapping">
          <On Select="TState.stStart">
            <Exit Result="False"/>
          </On>
          <On Select="TState.stInNum, TState.stFinal, TState.stAfterPrefix, TState.stInPrefixFrac, TState.stAfterDecimalPrefix, TState.stInDecimalFrac, TState.stAfterUnit">
            <Choose>
              <When Expression="IsEmpty(Frac)">
                <Execute Statement="CheckMicroValue:= Num * Factor"/>
              </When>
              <Otherwise>
                <WhileLoop Expression="(Frac &gt; 0) and ((Frac mod 10) = 0)">
                  <Execute Statement="Frac:= Frac div 10"/>
                  <Execute Statement="FracDiv:= FracDiv div 10"/>
                </WhileLoop>
                <Exit Condition="FracDiv &gt; Factor" Result="False"/>
                <Execute Statement="CheckMicroValue:= Num * Factor + (Factor div FracDiv) * Frac"/>
              </Otherwise>
            </Choose>
            <Exit Condition="IsError(CheckMicroValue)"/>
            <Execute Statement="MicroValue:= CheckMicroValue"/>
            <Exit Result="True"/>
          </On>
        </Case>
      </Block>
    </Function>

    <!--Standard micro formatting-->
    <Function Identifier="StrToMicroWatts" Type="Boolean">
      <Parameters>
        <Parameter Identifier="TextValue" Type="string"/>
        <Parameter Identifier="MicroValue" Type="Int64" Direction="Output"/>
      </Parameters>
      <Type>
        <Enumeration Identifier="TState" Elements="stStart, stInNum, stAfterDecimalChar, stInDecimalFrac, stAfterDecimalPrefix, stAfterPrefix, stFinal"/>
      </Type>
      <Constants>
        <Constant Identifier="cUnit" Type="Char" Expression="cWatt"/>
      </Constants>
      <Variables>
        <Variable Identifier="State" Type="TState" Init="TState.stStart"/>
        <Variable Identifier="Num" Type="UInt64"/>
        <Variable Identifier="Factor" Type="UInt64" Init="facToMicro"/>
        <Variable Identifier="Frac" Type="UInt64"/>
        <Variable Identifier="FracValue" Type="UInt64"/>
        <Variable Identifier="FracDiv" Type="UInt64"/>
        <Variable Identifier="CheckMicroValue" Type="Int64" DisabledChecks="error"/>
      </Variables>
      <Block>
        <Execute Statement="Result:= False"/>
        <StringLoop StringValue="TextValue" OrdinalIdentifier="ChrI">
          <Case Expression="State" Optimalisation="integermapping">
            <On Select="TState.stStart">
              <Case Expression="ChrI" Optimalisation="integermapping" OrdinalType="widechar">
                <On Select="' ', #9">
                </On>
                <On Select="'0'..'9'">
                  <Execute Statement="Num:= ChrI - CharOrd('0')"/>
                  <Execute Statement="State:= TState.stInNum"/>
                  <rep:Reporter.Information Text="Format('Num: %d', Num)" Condition="IsVerbose"/>
                </On>
                <Otherwise>
                  <Exit Result="False"/>
                </Otherwise>
              </Case>
            </On>
            <On Select="TState.stInNum">
              <Case Expression="ChrI" Optimalisation="integermapping" OrdinalType="widechar">
                <On Select="'0'..'9'">
                  <Execute Statement="Num:= Num * 10 + ChrI - CharOrd('0')"/>
                  <rep:Reporter.Information Text="Format('Num: %d', Num)" Condition="IsVerbose"/>
                </On>
                <On Select="cUnit">
                  <Execute Statement="State:= TState.stFinal"/>
                  <rep:Reporter.Information Text="'Final'" Condition="IsVerbose"/>
                </On>
                <On Select="cGiga">
                  <Execute Statement="State:= TState.stAfterPrefix"/>
                  <Execute Statement="Factor:= facGigaToMicro"/>
                  <rep:Reporter.Information Text="Format('Factor: %d', Factor)" Condition="IsVerbose"/>
                </On>
                <On Select="cMega">
                  <Execute Statement="State:= TState.stAfterPrefix"/>
                  <Execute Statement="Factor:= facMegaToMicro"/>
                  <rep:Reporter.Information Text="Format('Factor: %d', Factor)" Condition="IsVerbose"/>
                </On>
                <On Select="cKilo">
                  <Execute Statement="State:= TState.stAfterPrefix"/>
                  <Execute Statement="Factor:= facKiloToMicro"/>
                  <rep:Reporter.Information Text="Format('Factor: %d', Factor)" Condition="IsVerbose"/>
                </On>
                <On Select="cMilli">
                  <Execute Statement="State:= TState.stAfterPrefix"/>
                  <Execute Statement="Factor:= facMilliToMicro"/>
                  <rep:Reporter.Information Text="Format('Factor: %d', Factor)" Condition="IsVerbose"/>
                </On>
                <On Select="cMicro, cMicroAlt, cMicroAlt2">
                  <Execute Statement="State:= TState.stAfterPrefix"/>
                  <Execute Statement="Factor:= facMicroToMicro"/>
                  <rep:Reporter.Information Text="Format('Factor: %d', Factor)" Condition="IsVerbose"/>
                </On>
                <On Select="',', '.'">
                  <Execute Statement="State:= TState.stAfterDecimalChar"/>
                </On>
                <Otherwise>
                  <Exit Result="False"/>
                </Otherwise>
              </Case>
            </On>
            <On Select="TState.stAfterDecimalChar">
              <Case Expression="ChrI" Optimalisation="integermapping" OrdinalType="widechar">
                <On Select="'0'..'9'">
                  <Execute Statement="Frac:= ChrI - CharOrd('0')"/>
                  <Execute Statement="FracDiv:= 10"/>
                  <Execute Statement="State:= TState.stInDecimalFrac"/>
                  <rep:Reporter.Information Text="Format('Frac: %d', Frac)" Condition="IsVerbose"/>
                  <rep:Reporter.Information Text="Format('FracDiv: %d', FracDiv)" Condition="IsVerbose"/>
                </On>
                <Otherwise>
                  <Exit Result="False"/>
                </Otherwise>
              </Case>
            </On>
            <On Select="TState.stInDecimalFrac">
              <Case Expression="ChrI" Optimalisation="integermapping" OrdinalType="widechar">
                <On Select="'0'..'9'">
                  <Execute Statement="Frac:= Frac * 10 + ChrI - CharOrd('0')"/>
                  <Execute Statement="FracDiv:= FracDiv * 10"/>
                  <rep:Reporter.Information Text="Format('Frac: %d', Frac)" Condition="IsVerbose"/>
                  <rep:Reporter.Information Text="Format('FracDiv: %d', FracDiv)" Condition="IsVerbose"/>
                </On>
                <On Select="cUnit">
                  <Execute Statement="State:= TState.stFinal"/>
                  <rep:Reporter.Information Text="'Final'" Condition="IsVerbose"/>
                </On>
                <On Select="cGiga">
                  <Execute Statement="State:= TState.stAfterPrefix"/>
                  <Execute Statement="Factor:= facGigaToMicro"/>
                  <rep:Reporter.Information Text="Format('Factor: %d', Factor)" Condition="IsVerbose"/>
                </On>
                <On Select="cMega">
                  <Execute Statement="State:= TState.stAfterPrefix"/>
                  <Execute Statement="Factor:= facMegaToMicro"/>
                  <rep:Reporter.Information Text="Format('Factor: %d', Factor)" Condition="IsVerbose"/>
                </On>
                <On Select="cKilo">
                  <Execute Statement="State:= TState.stAfterPrefix"/>
                  <Execute Statement="Factor:= facKiloToMicro"/>
                  <rep:Reporter.Information Text="Format('Factor: %d', Factor)" Condition="IsVerbose"/>
                </On>
                <On Select="cMilli">
                  <Execute Statement="State:= TState.stAfterPrefix"/>
                  <Execute Statement="Factor:= facMilliToMicro"/>
                  <rep:Reporter.Information Text="Format('Factor: %d', Factor)" Condition="IsVerbose"/>
                </On>
                <On Select="cMicro, cMicroAlt, cMicroAlt2">
                  <Execute Statement="State:= TState.stAfterPrefix"/>
                  <Execute Statement="Factor:= facMicroToMicro"/>
                  <rep:Reporter.Information Text="Format('Factor: %d', Factor)" Condition="IsVerbose"/>
                </On>
                <Otherwise>
                  <Exit Result="False"/>
                </Otherwise>
              </Case>
            </On>
            <On Select="TState.stAfterPrefix">
              <Case Expression="ChrI" Optimalisation="integermapping" OrdinalType="widechar">
                <On Select="cUnit">
                  <Execute Statement="State:= TState.stFinal"/>
                  <rep:Reporter.Information Text="'Final'" Condition="IsVerbose"/>
                </On>
                <Otherwise>
                  <Exit Result="False"/>
                </Otherwise>
              </Case>
            </On>
            <On Select="TState.stFinal">
              <Case Expression="ChrI" Optimalisation="integermapping" OrdinalType="widechar">
                <On Select="' ', #9">
                </On>
                <Otherwise>
                  <Exit Result="False"/>
                </Otherwise>
              </Case>
            </On>
          </Case>
        </StringLoop>
        <Case Expression="State" Optimalisation="integermapping">
          <On Select="TState.stStart">
            <Exit Result="False"/>
          </On>
          <On Select="TState.stInNum, TState.stFinal, TState.stAfterPrefix, TState.stInDecimalFrac">
            <Choose>
              <When Expression="IsEmpty(Frac)">
                <Execute Statement="CheckMicroValue:= Num * Factor"/>
              </When>
              <Otherwise>
                <WhileLoop Expression="(Frac &gt; 0) and ((Frac mod 10) = 0)">
                  <Execute Statement="Frac:= Frac div 10"/>
                  <Execute Statement="FracDiv:= FracDiv div 10"/>
                </WhileLoop>
                <Exit Condition="FracDiv &gt; Factor" Result="False"/>
                <Execute Statement="CheckMicroValue:= Num * Factor + (Factor div FracDiv) * Frac"/>
              </Otherwise>
            </Choose>
            <Exit Condition="IsError(CheckMicroValue)"/>
            <Execute Statement="MicroValue:= CheckMicroValue"/>
            <Exit Result="True"/>
          </On>
        </Case>
      </Block>

    </Function>

    <Function Identifier="StrToMicroWatts" Type="Int64" IsDeterministic="true">
      <Parameters>
        <Parameter Identifier="TextValue" Type="string"/>
      </Parameters>
      <Block>
        <Variable Identifier="Valid" Type="Boolean" Init="StrToMicroWatts(TextValue, Result)"/>
        <Raise Expression="Exception.Create(Format('Invalid wattage: %s', TextValue))" Condition="not Valid"/>
      </Block>
    </Function>

    <!--Standard micro formatting-->
    <Function Identifier="StrToMicroVolts" Type="Boolean">
      <Parameters>
        <Parameter Identifier="TextValue" Type="string"/>
        <Parameter Identifier="MicroValue" Type="Int64" Direction="Output"/>
      </Parameters>
      <Type>
        <Enumeration Identifier="TState" Elements="stStart, stInNum, stAfterDecimalChar, stInDecimalFrac, stAfterDecimalPrefix, stAfterPrefix, stFinal"/>
      </Type>
      <Constants>
        <Constant Identifier="cUnit" Type="Char" Expression="cVolt"/>
      </Constants>
      <Variables>
        <Variable Identifier="State" Type="TState" Init="TState.stStart"/>
        <Variable Identifier="Num" Type="UInt64"/>
        <Variable Identifier="Factor" Type="UInt64" Init="facToMicro"/>
        <Variable Identifier="Frac" Type="UInt64"/>
        <Variable Identifier="FracValue" Type="UInt64"/>
        <Variable Identifier="FracDiv" Type="UInt64"/>
        <Variable Identifier="CheckMicroValue" Type="Int64" DisabledChecks="error"/>
      </Variables>
      <Block>
        <Execute Statement="Result:= False"/>
        <StringLoop StringValue="TextValue" OrdinalIdentifier="ChrI">
          <Case Expression="State" Optimalisation="integermapping">
            <On Select="TState.stStart">
              <Case Expression="ChrI" Optimalisation="integermapping" OrdinalType="widechar">
                <On Select="' ', #9">
                </On>
                <On Select="'0'..'9'">
                  <Execute Statement="Num:= ChrI - CharOrd('0')"/>
                  <Execute Statement="State:= TState.stInNum"/>
                  <rep:Reporter.Information Text="Format('Num: %d', Num)" Condition="IsVerbose"/>
                </On>
                <Otherwise>
                  <Exit Result="False"/>
                </Otherwise>
              </Case>
            </On>
            <On Select="TState.stInNum">
              <Case Expression="ChrI" Optimalisation="integermapping" OrdinalType="widechar">
                <On Select="'0'..'9'">
                  <Execute Statement="Num:= Num * 10 + ChrI - CharOrd('0')"/>
                  <rep:Reporter.Information Text="Format('Num: %d', Num)" Condition="IsVerbose"/>
                </On>
                <On Select="cUnit">
                  <Execute Statement="State:= TState.stFinal"/>
                  <rep:Reporter.Information Text="'Final'" Condition="IsVerbose"/>
                </On>
                <On Select="cGiga">
                  <Execute Statement="State:= TState.stAfterPrefix"/>
                  <Execute Statement="Factor:= facGigaToMicro"/>
                  <rep:Reporter.Information Text="Format('Factor: %d', Factor)" Condition="IsVerbose"/>
                </On>
                <On Select="cMega">
                  <Execute Statement="State:= TState.stAfterPrefix"/>
                  <Execute Statement="Factor:= facMegaToMicro"/>
                  <rep:Reporter.Information Text="Format('Factor: %d', Factor)" Condition="IsVerbose"/>
                </On>
                <On Select="cKilo">
                  <Execute Statement="State:= TState.stAfterPrefix"/>
                  <Execute Statement="Factor:= facKiloToMicro"/>
                  <rep:Reporter.Information Text="Format('Factor: %d', Factor)" Condition="IsVerbose"/>
                </On>
                <On Select="cMilli">
                  <Execute Statement="State:= TState.stAfterPrefix"/>
                  <Execute Statement="Factor:= facMilliToMicro"/>
                  <rep:Reporter.Information Text="Format('Factor: %d', Factor)" Condition="IsVerbose"/>
                </On>
                <On Select="cMicro, cMicroAlt, cMicroAlt2">
                  <Execute Statement="State:= TState.stAfterPrefix"/>
                  <Execute Statement="Factor:= facMicroToMicro"/>
                  <rep:Reporter.Information Text="Format('Factor: %d', Factor)" Condition="IsVerbose"/>
                </On>
                <On Select="',', '.'">
                  <Execute Statement="State:= TState.stAfterDecimalChar"/>
                </On>
                <Otherwise>
                  <Exit Result="False"/>
                </Otherwise>
              </Case>
            </On>
            <On Select="TState.stAfterDecimalChar">
              <Case Expression="ChrI" Optimalisation="integermapping" OrdinalType="widechar">
                <On Select="'0'..'9'">
                  <Execute Statement="Frac:= ChrI - CharOrd('0')"/>
                  <Execute Statement="FracDiv:= 10"/>
                  <Execute Statement="State:= TState.stInDecimalFrac"/>
                  <rep:Reporter.Information Text="Format('Frac: %d', Frac)" Condition="IsVerbose"/>
                  <rep:Reporter.Information Text="Format('FracDiv: %d', FracDiv)" Condition="IsVerbose"/>
                </On>
                <Otherwise>
                  <Exit Result="False"/>
                </Otherwise>
              </Case>
            </On>
            <On Select="TState.stInDecimalFrac">
              <Case Expression="ChrI" Optimalisation="integermapping" OrdinalType="widechar">
                <On Select="'0'..'9'">
                  <Execute Statement="Frac:= Frac * 10 + ChrI - CharOrd('0')"/>
                  <Execute Statement="FracDiv:= FracDiv * 10"/>
                  <rep:Reporter.Information Text="Format('Frac: %d', Frac)" Condition="IsVerbose"/>
                  <rep:Reporter.Information Text="Format('FracDiv: %d', FracDiv)" Condition="IsVerbose"/>
                </On>
                <On Select="cUnit">
                  <Execute Statement="State:= TState.stFinal"/>
                  <rep:Reporter.Information Text="'Final'" Condition="IsVerbose"/>
                </On>
                <On Select="cGiga">
                  <Execute Statement="State:= TState.stAfterPrefix"/>
                  <Execute Statement="Factor:= facGigaToMicro"/>
                  <rep:Reporter.Information Text="Format('Factor: %d', Factor)" Condition="IsVerbose"/>
                </On>
                <On Select="cMega">
                  <Execute Statement="State:= TState.stAfterPrefix"/>
                  <Execute Statement="Factor:= facMegaToMicro"/>
                  <rep:Reporter.Information Text="Format('Factor: %d', Factor)" Condition="IsVerbose"/>
                </On>
                <On Select="cKilo">
                  <Execute Statement="State:= TState.stAfterPrefix"/>
                  <Execute Statement="Factor:= facKiloToMicro"/>
                  <rep:Reporter.Information Text="Format('Factor: %d', Factor)" Condition="IsVerbose"/>
                </On>
                <On Select="cMilli">
                  <Execute Statement="State:= TState.stAfterPrefix"/>
                  <Execute Statement="Factor:= facMilliToMicro"/>
                  <rep:Reporter.Information Text="Format('Factor: %d', Factor)" Condition="IsVerbose"/>
                </On>
                <On Select="cMicro, cMicroAlt, cMicroAlt2">
                  <Execute Statement="State:= TState.stAfterPrefix"/>
                  <Execute Statement="Factor:= facMicroToMicro"/>
                  <rep:Reporter.Information Text="Format('Factor: %d', Factor)" Condition="IsVerbose"/>
                </On>
                <Otherwise>
                  <Exit Result="False"/>
                </Otherwise>
              </Case>
            </On>
            <On Select="TState.stAfterPrefix">
              <Case Expression="ChrI" Optimalisation="integermapping" OrdinalType="widechar">
                <On Select="cUnit">
                  <Execute Statement="State:= TState.stFinal"/>
                  <rep:Reporter.Information Text="'Final'" Condition="IsVerbose"/>
                </On>
                <Otherwise>
                  <Exit Result="False"/>
                </Otherwise>
              </Case>
            </On>
            <On Select="TState.stFinal">
              <Case Expression="ChrI" Optimalisation="integermapping" OrdinalType="widechar">
                <On Select="' ', #9">
                </On>
                <Otherwise>
                  <Exit Result="False"/>
                </Otherwise>
              </Case>
            </On>
          </Case>
        </StringLoop>
        <Case Expression="State" Optimalisation="integermapping">
          <On Select="TState.stStart">
            <Exit Result="False"/>
          </On>
          <On Select="TState.stInNum, TState.stFinal, TState.stAfterPrefix, TState.stInDecimalFrac">
            <Choose>
              <When Expression="IsEmpty(Frac)">
                <Execute Statement="CheckMicroValue:= Num * Factor"/>
              </When>
              <Otherwise>
                <WhileLoop Expression="(Frac &gt; 0) and ((Frac mod 10) = 0)">
                  <Execute Statement="Frac:= Frac div 10"/>
                  <Execute Statement="FracDiv:= FracDiv div 10"/>
                </WhileLoop>
                <Exit Condition="FracDiv &gt; Factor" Result="False"/>
                <Execute Statement="CheckMicroValue:= Num * Factor + (Factor div FracDiv) * Frac"/>
              </Otherwise>
            </Choose>
            <Exit Condition="IsError(CheckMicroValue)"/>
            <Execute Statement="MicroValue:= CheckMicroValue"/>
            <Exit Result="True"/>
          </On>
        </Case>
      </Block>
    </Function>

    <Function Identifier="StrToMicroVolts" Type="Int64" IsDeterministic="true">
      <Parameters>
        <Parameter Identifier="TextValue" Type="string"/>
      </Parameters>
      <Block>
        <Variable Identifier="Valid" Type="Boolean" Init="StrToMicroVolts(TextValue, Result)"/>
        <Raise Expression="Exception.Create(Format('Invalid voltage: %s', TextValue))" Condition="not Valid"/>
      </Block>
    </Function>

    <Function Identifier="StrToMicroAmps" Type="Boolean">
      <Parameters>
        <Parameter Identifier="TextValue" Type="string"/>
        <Parameter Identifier="MicroValue" Type="Int64" Direction="Output"/>
      </Parameters>
      <Type>
        <Enumeration Identifier="TState" Elements="stStart, stInNum, stAfterDecimalChar, stInDecimalFrac, stAfterDecimalPrefix, stAfterPrefix, stFinal"/>
      </Type>
      <Constants>
        <Constant Identifier="cUnit" Type="Char" Expression="cAmp"/>
      </Constants>
      <Variables>
        <Variable Identifier="State" Type="TState" Init="TState.stStart"/>
        <Variable Identifier="Num" Type="UInt64"/>
        <Variable Identifier="Factor" Type="UInt64" Init="facToMicro"/>
        <Variable Identifier="Frac" Type="UInt64"/>
        <Variable Identifier="FracValue" Type="UInt64"/>
        <Variable Identifier="FracDiv" Type="UInt64"/>
        <Variable Identifier="CheckMicroValue" Type="Int64" DisabledChecks="error"/>
      </Variables>
      <Block>
        <Execute Statement="Result:= False"/>
        <StringLoop StringValue="TextValue" OrdinalIdentifier="ChrI">
          <Case Expression="State" Optimalisation="integermapping">
            <On Select="TState.stStart">
              <Case Expression="ChrI" Optimalisation="integermapping" OrdinalType="widechar">
                <On Select="' ', #9">
                </On>
                <On Select="'0'..'9'">
                  <Execute Statement="Num:= ChrI - CharOrd('0')"/>
                  <Execute Statement="State:= TState.stInNum"/>
                  <rep:Reporter.Information Text="Format('Num: %d', Num)" Condition="IsVerbose"/>
                </On>
                <Otherwise>
                  <Exit Result="False"/>
                </Otherwise>
              </Case>
            </On>
            <On Select="TState.stInNum">
              <Case Expression="ChrI" Optimalisation="integermapping" OrdinalType="widechar">
                <On Select="'0'..'9'">
                  <Execute Statement="Num:= Num * 10 + ChrI - CharOrd('0')"/>
                  <rep:Reporter.Information Text="Format('Num: %d', Num)" Condition="IsVerbose"/>
                </On>
                <On Select="cUnit">
                  <Execute Statement="State:= TState.stFinal"/>
                  <rep:Reporter.Information Text="'Final'" Condition="IsVerbose"/>
                </On>
                <On Select="cGiga">
                  <Execute Statement="State:= TState.stAfterPrefix"/>
                  <Execute Statement="Factor:= facGigaToMicro"/>
                  <rep:Reporter.Information Text="Format('Factor: %d', Factor)" Condition="IsVerbose"/>
                </On>
                <On Select="cMega">
                  <Execute Statement="State:= TState.stAfterPrefix"/>
                  <Execute Statement="Factor:= facMegaToMicro"/>
                  <rep:Reporter.Information Text="Format('Factor: %d', Factor)" Condition="IsVerbose"/>
                </On>
                <On Select="cKilo">
                  <Execute Statement="State:= TState.stAfterPrefix"/>
                  <Execute Statement="Factor:= facKiloToMicro"/>
                  <rep:Reporter.Information Text="Format('Factor: %d', Factor)" Condition="IsVerbose"/>
                </On>
                <On Select="cMilli">
                  <Execute Statement="State:= TState.stAfterPrefix"/>
                  <Execute Statement="Factor:= facMilliToMicro"/>
                  <rep:Reporter.Information Text="Format('Factor: %d', Factor)" Condition="IsVerbose"/>
                </On>
                <On Select="cMicro, cMicroAlt, cMicroAlt2">
                  <Execute Statement="State:= TState.stAfterPrefix"/>
                  <Execute Statement="Factor:= facMicroToMicro"/>
                  <rep:Reporter.Information Text="Format('Factor: %d', Factor)" Condition="IsVerbose"/>
                </On>
                <On Select="',', '.'">
                  <Execute Statement="State:= TState.stAfterDecimalChar"/>
                </On>
                <Otherwise>
                  <Exit Result="False"/>
                </Otherwise>
              </Case>
            </On>
            <On Select="TState.stAfterDecimalChar">
              <Case Expression="ChrI" Optimalisation="integermapping" OrdinalType="widechar">
                <On Select="'0'..'9'">
                  <Execute Statement="Frac:= ChrI - CharOrd('0')"/>
                  <Execute Statement="FracDiv:= 10"/>
                  <Execute Statement="State:= TState.stInDecimalFrac"/>
                  <rep:Reporter.Information Text="Format('Frac: %d', Frac)" Condition="IsVerbose"/>
                  <rep:Reporter.Information Text="Format('FracDiv: %d', FracDiv)" Condition="IsVerbose"/>
                </On>
                <Otherwise>
                  <Exit Result="False"/>
                </Otherwise>
              </Case>
            </On>
            <On Select="TState.stInDecimalFrac">
              <Case Expression="ChrI" Optimalisation="integermapping" OrdinalType="widechar">
                <On Select="'0'..'9'">
                  <Execute Statement="Frac:= Frac * 10 + ChrI - CharOrd('0')"/>
                  <Execute Statement="FracDiv:= FracDiv * 10"/>
                  <rep:Reporter.Information Text="Format('Frac: %d', Frac)" Condition="IsVerbose"/>
                  <rep:Reporter.Information Text="Format('FracDiv: %d', FracDiv)" Condition="IsVerbose"/>
                </On>
                <On Select="cUnit">
                  <Execute Statement="State:= TState.stFinal"/>
                  <rep:Reporter.Information Text="'Final'" Condition="IsVerbose"/>
                </On>
                <On Select="cGiga">
                  <Execute Statement="State:= TState.stAfterPrefix"/>
                  <Execute Statement="Factor:= facGigaToMicro"/>
                  <rep:Reporter.Information Text="Format('Factor: %d', Factor)" Condition="IsVerbose"/>
                </On>
                <On Select="cMega">
                  <Execute Statement="State:= TState.stAfterPrefix"/>
                  <Execute Statement="Factor:= facMegaToMicro"/>
                  <rep:Reporter.Information Text="Format('Factor: %d', Factor)" Condition="IsVerbose"/>
                </On>
                <On Select="cKilo">
                  <Execute Statement="State:= TState.stAfterPrefix"/>
                  <Execute Statement="Factor:= facKiloToMicro"/>
                  <rep:Reporter.Information Text="Format('Factor: %d', Factor)" Condition="IsVerbose"/>
                </On>
                <On Select="cMilli">
                  <Execute Statement="State:= TState.stAfterPrefix"/>
                  <Execute Statement="Factor:= facMilliToMicro"/>
                  <rep:Reporter.Information Text="Format('Factor: %d', Factor)" Condition="IsVerbose"/>
                </On>
                <On Select="cMicro, cMicroAlt, cMicroAlt2">
                  <Execute Statement="State:= TState.stAfterPrefix"/>
                  <Execute Statement="Factor:= facMicroToMicro"/>
                  <rep:Reporter.Information Text="Format('Factor: %d', Factor)" Condition="IsVerbose"/>
                </On>
                <Otherwise>
                  <Exit Result="False"/>
                </Otherwise>
              </Case>
            </On>
            <On Select="TState.stAfterPrefix">
              <Case Expression="ChrI" Optimalisation="integermapping" OrdinalType="widechar">
                <On Select="cUnit">
                  <Execute Statement="State:= TState.stFinal"/>
                  <rep:Reporter.Information Text="'Final'" Condition="IsVerbose"/>
                </On>
                <Otherwise>
                  <Exit Result="False"/>
                </Otherwise>
              </Case>
            </On>
            <On Select="TState.stFinal">
              <Case Expression="ChrI" Optimalisation="integermapping" OrdinalType="widechar">
                <On Select="' ', #9">
                </On>
                <Otherwise>
                  <Exit Result="False"/>
                </Otherwise>
              </Case>
            </On>
          </Case>
        </StringLoop>
        <Case Expression="State" Optimalisation="integermapping">
          <On Select="TState.stStart">
            <Exit Result="False"/>
          </On>
          <On Select="TState.stInNum, TState.stFinal, TState.stAfterPrefix, TState.stInDecimalFrac">
            <Choose>
              <When Expression="IsEmpty(Frac)">
                <Execute Statement="CheckMicroValue:= Num * Factor"/>
              </When>
              <Otherwise>
                <WhileLoop Expression="(Frac &gt; 0) and ((Frac mod 10) = 0)">
                  <Execute Statement="Frac:= Frac div 10"/>
                  <Execute Statement="FracDiv:= FracDiv div 10"/>
                </WhileLoop>
                <Exit Condition="FracDiv &gt; Factor" Result="False"/>
                <Execute Statement="CheckMicroValue:= Num * Factor + (Factor div FracDiv) * Frac"/>
              </Otherwise>
            </Choose>
            <Exit Condition="IsError(CheckMicroValue)"/>
            <Execute Statement="MicroValue:= CheckMicroValue"/>
            <Exit Result="True"/>
          </On>
        </Case>
      </Block>
    </Function>

    <!--Non standard micro formatting-->
    <Function Identifier="StrToMicroPerc" Type="Boolean">
      <Parameters>
        <Parameter Identifier="TextValue" Type="string"/>
        <Parameter Identifier="MicroValue" Type="Int64" Direction="Output"/>
      </Parameters>
      <Type>
        <Enumeration Identifier="TState" Elements="stStart, stInNum, stAfterDecimalChar, stInDecimalFrac, stFinal"/>
      </Type>
      <Constants>
        <Constant Identifier="cUnit" Type="Char" Expression="cPerc"/>
      </Constants>
      <Variables>
        <Variable Identifier="State" Type="TState" Init="TState.stStart"/>
        <Variable Identifier="Num" Type="UInt64"/>
        <Variable Identifier="Factor" Type="UInt64" Init="facToMicro"/>
        <Variable Identifier="Frac" Type="UInt64"/>
        <Variable Identifier="FracValue" Type="UInt64"/>
        <Variable Identifier="FracDiv" Type="UInt64"/>
        <Variable Identifier="CheckMicroValue" Type="Int64" DisabledChecks="error"/>
      </Variables>
      <Block>
        <Execute Statement="Result:= False"/>
        <StringLoop StringValue="TextValue" OrdinalIdentifier="ChrI">
          <Case Expression="State" Optimalisation="integermapping">
            <On Select="TState.stStart">
              <Case Expression="ChrI" Optimalisation="integermapping" OrdinalType="widechar">
                <On Select="' ', #9">
                </On>
                <On Select="'0'..'9'">
                  <Execute Statement="Num:= ChrI - CharOrd('0')"/>
                  <Execute Statement="State:= TState.stInNum"/>
                  <rep:Reporter.Information Text="Format('Num: %d', Num)" Condition="IsVerbose"/>
                </On>
                <Otherwise>
                  <Exit Result="False"/>
                </Otherwise>
              </Case>
            </On>
            <On Select="TState.stInNum">
              <Case Expression="ChrI" Optimalisation="integermapping" OrdinalType="widechar">
                <On Select="'0'..'9'">
                  <Execute Statement="Num:= Num * 10 + ChrI - CharOrd('0')"/>
                  <rep:Reporter.Information Text="Format('Num: %d', Num)" Condition="IsVerbose"/>
                </On>
                <On Select="cUnit">
                  <Execute Statement="State:= TState.stFinal"/>
                  <rep:Reporter.Information Text="'Final'" Condition="IsVerbose"/>
                </On>
                <On Select="',', '.'">
                  <Execute Statement="State:= TState.stAfterDecimalChar"/>
                </On>
                <Otherwise>
                  <Exit Result="False"/>
                </Otherwise>
              </Case>
            </On>
            <On Select="TState.stAfterDecimalChar">
              <Case Expression="ChrI" Optimalisation="integermapping" OrdinalType="widechar">
                <On Select="'0'..'9'">
                  <Execute Statement="Frac:= ChrI - CharOrd('0')"/>
                  <Execute Statement="FracDiv:= 10"/>
                  <Execute Statement="State:= TState.stInDecimalFrac"/>
                  <rep:Reporter.Information Text="Format('Frac: %d', Frac)" Condition="IsVerbose"/>
                  <rep:Reporter.Information Text="Format('FracDiv: %d', FracDiv)" Condition="IsVerbose"/>
                </On>
                <Otherwise>
                  <Exit Result="False"/>
                </Otherwise>
              </Case>
            </On>
            <On Select="TState.stInDecimalFrac">
              <Case Expression="ChrI" Optimalisation="integermapping" OrdinalType="widechar">
                <On Select="'0'..'9'">
                  <Execute Statement="Frac:= Frac * 10 + ChrI - CharOrd('0')"/>
                  <Execute Statement="FracDiv:= FracDiv * 10"/>
                  <rep:Reporter.Information Text="Format('Frac: %d', Frac)" Condition="IsVerbose"/>
                  <rep:Reporter.Information Text="Format('FracDiv: %d', FracDiv)" Condition="IsVerbose"/>
                </On>
                <On Select="cUnit">
                  <Execute Statement="State:= TState.stFinal"/>
                  <rep:Reporter.Information Text="'Final'" Condition="IsVerbose"/>
                </On>
                <Otherwise>
                  <Exit Result="False"/>
                </Otherwise>
              </Case>
            </On>
            <On Select="TState.stFinal">
              <Case Expression="ChrI" Optimalisation="integermapping" OrdinalType="widechar">
                <On Select="' ', #9">
                </On>
                <Otherwise>
                  <Exit Result="False"/>
                </Otherwise>
              </Case>
            </On>
          </Case>
        </StringLoop>
        <Case Expression="State" Optimalisation="integermapping">
          <On Select="TState.stStart">
            <Exit Result="False"/>
          </On>
          <On Select="TState.stInNum, TState.stFinal, TState.stInDecimalFrac">
            <Choose>
              <When Expression="IsEmpty(Frac)">
                <Execute Statement="CheckMicroValue:= Num * Factor"/>
              </When>
              <Otherwise>
                <WhileLoop Expression="(Frac &gt; 0) and ((Frac mod 10) = 0)">
                  <Execute Statement="Frac:= Frac div 10"/>
                  <Execute Statement="FracDiv:= FracDiv div 10"/>
                </WhileLoop>
                <Exit Condition="FracDiv &gt; Factor" Result="False"/>
                <Execute Statement="CheckMicroValue:= Num * Factor + (Factor div FracDiv) * Frac"/>
              </Otherwise>
            </Choose>
            <Exit Condition="IsError(CheckMicroValue)"/>
            <Execute Statement="MicroValue:= CheckMicroValue"/>
            <Exit Result="True"/>
          </On>
        </Case>
      </Block>
    </Function>

    <!--Standard Femto formatting-->
    <Function Identifier="StrToFemtoFarads" Type="Boolean">
      <Parameters>
        <Parameter Identifier="TextValue" Type="string"/>
        <Parameter Identifier="FemtoValue" Type="Int64" Direction="Output"/>
      </Parameters>
      <Type>
        <Enumeration Identifier="TState" Elements="stStart, stInNum, stAfterDecimalChar, stInDecimalFrac, stAfterDecimalPrefix, stAfterPrefix, stFinal"/>
      </Type>
      <Constants>
        <Constant Identifier="cUnit" Type="Char" Expression="cFarad"/>
      </Constants>
      <Variables>
        <Variable Identifier="State" Type="TState" Init="TState.stStart"/>
        <Variable Identifier="Num" Type="UInt64"/>
        <Variable Identifier="Factor" Type="UInt64" Init="facToFemto"/>
        <Variable Identifier="Frac" Type="UInt64"/>
        <Variable Identifier="FracValue" Type="UInt64"/>
        <Variable Identifier="FracDiv" Type="UInt64"/>
        <Variable Identifier="CheckFemtoValue" Type="Int64" DisabledChecks="error"/>
      </Variables>
      <Block>
        <Execute Statement="Result:= False"/>
        <StringLoop StringValue="TextValue" OrdinalIdentifier="ChrI">
          <Case Expression="State" Optimalisation="integermapping">
            <On Select="TState.stStart">
              <Case Expression="ChrI" Optimalisation="integermapping" OrdinalType="widechar">
                <On Select="' ', #9">
                </On>
                <On Select="'0'..'9'">
                  <Execute Statement="Num:= ChrI - CharOrd('0')"/>
                  <Execute Statement="State:= TState.stInNum"/>
                  <rep:Reporter.Information Text="Format('Num: %d', Num)" Condition="IsVerbose"/>
                </On>
                <Otherwise>
                  <Exit Result="False"/>
                </Otherwise>
              </Case>
            </On>
            <On Select="TState.stInNum">
              <Case Expression="ChrI" Optimalisation="integermapping" OrdinalType="widechar">
                <On Select="'0'..'9'">
                  <Execute Statement="Num:= Num * 10 + ChrI - CharOrd('0')"/>
                  <rep:Reporter.Information Text="Format('Num: %d', Num)" Condition="IsVerbose"/>
                </On>
                <On Select="cUnit">
                  <Execute Statement="State:= TState.stFinal"/>
                  <rep:Reporter.Information Text="'Final'" Condition="IsVerbose"/>
                </On>
                <On Select="cKilo">
                  <Execute Statement="State:= TState.stAfterPrefix"/>
                  <Execute Statement="Factor:= facKiloToFemto"/>
                  <rep:Reporter.Information Text="Format('Factor: %d', Factor)" Condition="IsVerbose"/>
                </On>
                <On Select="cMilli">
                  <Execute Statement="State:= TState.stAfterPrefix"/>
                  <Execute Statement="Factor:= facMilliToFemto"/>
                  <rep:Reporter.Information Text="Format('Factor: %d', Factor)" Condition="IsVerbose"/>
                </On>
                <On Select="cMicro, cMicroAlt, cMicroAlt2">
                  <Execute Statement="State:= TState.stAfterPrefix"/>
                  <Execute Statement="Factor:= facMicroToFemto"/>
                  <rep:Reporter.Information Text="Format('Factor: %d', Factor)" Condition="IsVerbose"/>
                </On>
                <On Select="cNano">
                  <Execute Statement="State:= TState.stAfterPrefix"/>
                  <Execute Statement="Factor:= facNanoToFemto"/>
                  <rep:Reporter.Information Text="Format('Factor: %d', Factor)" Condition="IsVerbose"/>
                </On>
                <On Select="cPico">
                  <Execute Statement="State:= TState.stAfterPrefix"/>
                  <Execute Statement="Factor:= facPicoToFemto"/>
                  <rep:Reporter.Information Text="Format('Factor: %d', Factor)" Condition="IsVerbose"/>
                </On>
                <On Select="cFemto">
                  <Execute Statement="State:= TState.stAfterPrefix"/>
                  <Execute Statement="Factor:= facFemtoToFemto"/>
                  <rep:Reporter.Information Text="Format('Factor: %d', Factor)" Condition="IsVerbose"/>
                </On>
                <On Select="',', '.'">
                  <Execute Statement="State:= TState.stAfterDecimalChar"/>
                </On>
                <Otherwise>
                  <Exit Result="False"/>
                </Otherwise>
              </Case>
            </On>
            <On Select="TState.stAfterDecimalChar">
              <Case Expression="ChrI" Optimalisation="integermapping" OrdinalType="widechar">
                <On Select="'0'..'9'">
                  <Execute Statement="Frac:= ChrI - CharOrd('0')"/>
                  <Execute Statement="FracDiv:= 10"/>
                  <Execute Statement="State:= TState.stInDecimalFrac"/>
                  <rep:Reporter.Information Text="Format('Frac: %d', Frac)" Condition="IsVerbose"/>
                  <rep:Reporter.Information Text="Format('FracDiv: %d', FracDiv)" Condition="IsVerbose"/>
                </On>
                <Otherwise>
                  <Exit Result="False"/>
                </Otherwise>
              </Case>
            </On>
            <On Select="TState.stInDecimalFrac">
              <Case Expression="ChrI" Optimalisation="integermapping" OrdinalType="widechar">
                <On Select="'0'..'9'">
                  <Execute Statement="Frac:= Frac * 10 + ChrI - CharOrd('0')"/>
                  <Execute Statement="FracDiv:= FracDiv * 10"/>
                  <rep:Reporter.Information Text="Format('Frac: %d', Frac)" Condition="IsVerbose"/>
                  <rep:Reporter.Information Text="Format('FracDiv: %d', FracDiv)" Condition="IsVerbose"/>
                </On>
                <On Select="cUnit">
                  <Execute Statement="State:= TState.stFinal"/>
                  <rep:Reporter.Information Text="'Final'" Condition="IsVerbose"/>
                </On>
                <On Select="cKilo">
                  <Execute Statement="State:= TState.stAfterPrefix"/>
                  <Execute Statement="Factor:= facKiloToFemto"/>
                  <rep:Reporter.Information Text="Format('Factor: %d', Factor)" Condition="IsVerbose"/>
                </On>
                <On Select="cMilli">
                  <Execute Statement="State:= TState.stAfterPrefix"/>
                  <Execute Statement="Factor:= facMilliToFemto"/>
                  <rep:Reporter.Information Text="Format('Factor: %d', Factor)" Condition="IsVerbose"/>
                </On>
                <On Select="cMicro, cMicroAlt, cMicroAlt2">
                  <Execute Statement="State:= TState.stAfterPrefix"/>
                  <Execute Statement="Factor:= facMicroToFemto"/>
                  <rep:Reporter.Information Text="Format('Factor: %d', Factor)" Condition="IsVerbose"/>
                </On>
                <On Select="cNano">
                  <Execute Statement="State:= TState.stAfterPrefix"/>
                  <Execute Statement="Factor:= facNanoToFemto"/>
                  <rep:Reporter.Information Text="Format('Factor: %d', Factor)" Condition="IsVerbose"/>
                </On>
                <On Select="cPico">
                  <Execute Statement="State:= TState.stAfterPrefix"/>
                  <Execute Statement="Factor:= facPicoToFemto"/>
                  <rep:Reporter.Information Text="Format('Factor: %d', Factor)" Condition="IsVerbose"/>
                </On>
                <On Select="cFemto">
                  <Execute Statement="State:= TState.stAfterPrefix"/>
                  <Execute Statement="Factor:= facFemtoToFemto"/>
                  <rep:Reporter.Information Text="Format('Factor: %d', Factor)" Condition="IsVerbose"/>
                </On>
                <Otherwise>
                  <Exit Result="False"/>
                </Otherwise>
              </Case>
            </On>
            <On Select="TState.stAfterPrefix">
              <Case Expression="ChrI" Optimalisation="integermapping" OrdinalType="widechar">
                <On Select="cUnit">
                  <Execute Statement="State:= TState.stFinal"/>
                  <rep:Reporter.Information Text="'Final'" Condition="IsVerbose"/>
                </On>
                <Otherwise>
                  <Exit Result="False"/>
                </Otherwise>
              </Case>
            </On>
            <On Select="TState.stFinal">
              <Case Expression="ChrI" Optimalisation="integermapping" OrdinalType="widechar">
                <On Select="' ', #9">
                </On>
                <Otherwise>
                  <Exit Result="False"/>
                </Otherwise>
              </Case>
            </On>
          </Case>
        </StringLoop>
        <Case Expression="State" Optimalisation="integermapping">
          <On Select="TState.stStart">
            <Exit Result="False"/>
          </On>
          <On Select="TState.stInNum, TState.stFinal, TState.stAfterPrefix, TState.stInDecimalFrac">
            <Choose>
              <When Expression="IsEmpty(Frac)">
                <Execute Statement="CheckFemtoValue:= Num * Factor"/>
              </When>
              <Otherwise>
                <WhileLoop Expression="(Frac &gt; 0) and ((Frac mod 10) = 0)">
                  <Execute Statement="Frac:= Frac div 10"/>
                  <Execute Statement="FracDiv:= FracDiv div 10"/>
                </WhileLoop>
                <Exit Condition="FracDiv &gt; Factor" Result="False"/>
                <Execute Statement="CheckFemtoValue:= Num * Factor + (Factor div FracDiv) * Frac"/>
              </Otherwise>
            </Choose>
            <Exit Condition="IsError(CheckFemtoValue)"/>
            <Execute Statement="FemtoValue:= CheckFemtoValue"/>
            <Exit Result="True"/>
          </On>
        </Case>
      </Block>
    </Function>

    <Function Identifier="StrToFemtoHenry" Type="Boolean">
      <Parameters>
        <Parameter Identifier="TextValue" Type="string"/>
        <Parameter Identifier="FemtoValue" Type="Int64" Direction="Output"/>
      </Parameters>
      <Type>
        <Enumeration Identifier="TState" Elements="stStart, stInNum, stAfterDecimalChar, stInDecimalFrac, stAfterDecimalPrefix, stAfterPrefix, stFinal"/>
      </Type>
      <Constants>
        <Constant Identifier="cUnit" Type="Char" Expression="cHenry"/>
      </Constants>
      <Variables>
        <Variable Identifier="State" Type="TState" Init="TState.stStart"/>
        <Variable Identifier="Num" Type="UInt64"/>
        <Variable Identifier="Factor" Type="UInt64" Init="facToFemto"/>
        <Variable Identifier="Frac" Type="UInt64"/>
        <Variable Identifier="FracValue" Type="UInt64"/>
        <Variable Identifier="FracDiv" Type="UInt64"/>
        <Variable Identifier="CheckFemtoValue" Type="Int64" DisabledChecks="error"/>
      </Variables>
      <Block>
        <Execute Statement="Result:= False"/>
        <StringLoop StringValue="TextValue" OrdinalIdentifier="ChrI">
          <Case Expression="State" Optimalisation="integermapping">
            <On Select="TState.stStart">
              <Case Expression="ChrI" Optimalisation="integermapping" OrdinalType="widechar">
                <On Select="' ', #9">
                </On>
                <On Select="'0'..'9'">
                  <Execute Statement="Num:= ChrI - CharOrd('0')"/>
                  <Execute Statement="State:= TState.stInNum"/>
                  <rep:Reporter.Information Text="Format('Num: %d', Num)" Condition="IsVerbose"/>
                </On>
                <Otherwise>
                  <Exit Result="False"/>
                </Otherwise>
              </Case>
            </On>
            <On Select="TState.stInNum">
              <Case Expression="ChrI" Optimalisation="integermapping" OrdinalType="widechar">
                <On Select="'0'..'9'">
                  <Execute Statement="Num:= Num * 10 + ChrI - CharOrd('0')"/>
                  <rep:Reporter.Information Text="Format('Num: %d', Num)" Condition="IsVerbose"/>
                </On>
                <On Select="cUnit">
                  <Execute Statement="State:= TState.stFinal"/>
                  <rep:Reporter.Information Text="'Final'" Condition="IsVerbose"/>
                </On>
                <On Select="cKilo">
                  <Execute Statement="State:= TState.stAfterPrefix"/>
                  <Execute Statement="Factor:= facKiloToFemto"/>
                  <rep:Reporter.Information Text="Format('Factor: %d', Factor)" Condition="IsVerbose"/>
                </On>
                <On Select="cMilli">
                  <Execute Statement="State:= TState.stAfterPrefix"/>
                  <Execute Statement="Factor:= facMilliToFemto"/>
                  <rep:Reporter.Information Text="Format('Factor: %d', Factor)" Condition="IsVerbose"/>
                </On>
                <On Select="cMicro, cMicroAlt, cMicroAlt2">
                  <Execute Statement="State:= TState.stAfterPrefix"/>
                  <Execute Statement="Factor:= facMicroToFemto"/>
                  <rep:Reporter.Information Text="Format('Factor: %d', Factor)" Condition="IsVerbose"/>
                </On>
                <On Select="cNano">
                  <Execute Statement="State:= TState.stAfterPrefix"/>
                  <Execute Statement="Factor:= facNanoToFemto"/>
                  <rep:Reporter.Information Text="Format('Factor: %d', Factor)" Condition="IsVerbose"/>
                </On>
                <On Select="cPico">
                  <Execute Statement="State:= TState.stAfterPrefix"/>
                  <Execute Statement="Factor:= facPicoToFemto"/>
                  <rep:Reporter.Information Text="Format('Factor: %d', Factor)" Condition="IsVerbose"/>
                </On>
                <On Select="cFemto">
                  <Execute Statement="State:= TState.stAfterPrefix"/>
                  <Execute Statement="Factor:= facFemtoToFemto"/>
                  <rep:Reporter.Information Text="Format('Factor: %d', Factor)" Condition="IsVerbose"/>
                </On>
                <On Select="',', '.'">
                  <Execute Statement="State:= TState.stAfterDecimalChar"/>
                </On>
                <Otherwise>
                  <Exit Result="False"/>
                </Otherwise>
              </Case>
            </On>
            <On Select="TState.stAfterDecimalChar">
              <Case Expression="ChrI" Optimalisation="integermapping" OrdinalType="widechar">
                <On Select="'0'..'9'">
                  <Execute Statement="Frac:= ChrI - CharOrd('0')"/>
                  <Execute Statement="FracDiv:= 10"/>
                  <Execute Statement="State:= TState.stInDecimalFrac"/>
                  <rep:Reporter.Information Text="Format('Frac: %d', Frac)" Condition="IsVerbose"/>
                  <rep:Reporter.Information Text="Format('FracDiv: %d', FracDiv)" Condition="IsVerbose"/>
                </On>
                <Otherwise>
                  <Exit Result="False"/>
                </Otherwise>
              </Case>
            </On>
            <On Select="TState.stInDecimalFrac">
              <Case Expression="ChrI" Optimalisation="integermapping" OrdinalType="widechar">
                <On Select="'0'..'9'">
                  <Execute Statement="Frac:= Frac * 10 + ChrI - CharOrd('0')"/>
                  <Execute Statement="FracDiv:= FracDiv * 10"/>
                  <rep:Reporter.Information Text="Format('Frac: %d', Frac)" Condition="IsVerbose"/>
                  <rep:Reporter.Information Text="Format('FracDiv: %d', FracDiv)" Condition="IsVerbose"/>
                </On>
                <On Select="cUnit">
                  <Execute Statement="State:= TState.stFinal"/>
                  <rep:Reporter.Information Text="'Final'" Condition="IsVerbose"/>
                </On>
                <On Select="cKilo">
                  <Execute Statement="State:= TState.stAfterPrefix"/>
                  <Execute Statement="Factor:= facKiloToFemto"/>
                  <rep:Reporter.Information Text="Format('Factor: %d', Factor)" Condition="IsVerbose"/>
                </On>
                <On Select="cMilli">
                  <Execute Statement="State:= TState.stAfterPrefix"/>
                  <Execute Statement="Factor:= facMilliToFemto"/>
                  <rep:Reporter.Information Text="Format('Factor: %d', Factor)" Condition="IsVerbose"/>
                </On>
                <On Select="cMicro, cMicroAlt, cMicroAlt2">
                  <Execute Statement="State:= TState.stAfterPrefix"/>
                  <Execute Statement="Factor:= facMicroToFemto"/>
                  <rep:Reporter.Information Text="Format('Factor: %d', Factor)" Condition="IsVerbose"/>
                </On>
                <On Select="cNano">
                  <Execute Statement="State:= TState.stAfterPrefix"/>
                  <Execute Statement="Factor:= facNanoToFemto"/>
                  <rep:Reporter.Information Text="Format('Factor: %d', Factor)" Condition="IsVerbose"/>
                </On>
                <On Select="cPico">
                  <Execute Statement="State:= TState.stAfterPrefix"/>
                  <Execute Statement="Factor:= facPicoToFemto"/>
                  <rep:Reporter.Information Text="Format('Factor: %d', Factor)" Condition="IsVerbose"/>
                </On>
                <On Select="cFemto">
                  <Execute Statement="State:= TState.stAfterPrefix"/>
                  <Execute Statement="Factor:= facFemtoToFemto"/>
                  <rep:Reporter.Information Text="Format('Factor: %d', Factor)" Condition="IsVerbose"/>
                </On>
                <Otherwise>
                  <Exit Result="False"/>
                </Otherwise>
              </Case>
            </On>
            <On Select="TState.stAfterPrefix">
              <Case Expression="ChrI" Optimalisation="integermapping" OrdinalType="widechar">
                <On Select="cUnit">
                  <Execute Statement="State:= TState.stFinal"/>
                  <rep:Reporter.Information Text="'Final'" Condition="IsVerbose"/>
                </On>
                <Otherwise>
                  <Exit Result="False"/>
                </Otherwise>
              </Case>
            </On>
            <On Select="TState.stFinal">
              <Case Expression="ChrI" Optimalisation="integermapping" OrdinalType="widechar">
                <On Select="' ', #9">
                </On>
                <Otherwise>
                  <Exit Result="False"/>
                </Otherwise>
              </Case>
            </On>
          </Case>
        </StringLoop>
        <Case Expression="State" Optimalisation="integermapping">
          <On Select="TState.stStart">
            <Exit Result="False"/>
          </On>
          <On Select="TState.stInNum, TState.stFinal, TState.stAfterPrefix, TState.stInDecimalFrac">
            <Choose>
              <When Expression="IsEmpty(Frac)">
                <Execute Statement="CheckFemtoValue:= Num * Factor"/>
              </When>
              <Otherwise>
                <WhileLoop Expression="(Frac &gt; 0) and ((Frac mod 10) = 0)">
                  <Execute Statement="Frac:= Frac div 10"/>
                  <Execute Statement="FracDiv:= FracDiv div 10"/>
                </WhileLoop>
                <Exit Condition="FracDiv &gt; Factor" Result="False"/>
                <Execute Statement="CheckFemtoValue:= Num * Factor + (Factor div FracDiv) * Frac"/>
              </Otherwise>
            </Choose>
            <Exit Condition="IsError(CheckFemtoValue)"/>
            <Execute Statement="FemtoValue:= CheckFemtoValue"/>
            <Exit Result="True"/>
          </On>
        </Case>
      </Block>
    </Function>

    <Function Identifier="FormatUnitValue">
      <Parameters>
        <Parameter Identifier="Value" Type="Int64"/>
        <Parameter Identifier="UnitType" Type="TDisplayUnitType"/>
      </Parameters>
      <Variables>
        <Variable Identifier="Factor" Type="Int64"/>
        <Variable Identifier="FactorType" Type="TFactorType" Init="TFactorType.ftMicro"/>
        <Variable Identifier="Prefix" Type="TPrefix"/>
        <Variable Identifier="NumValue" Type="Int64" Init="0"/>
        <Variable Identifier="UnitS" Type="Char"/>
        <Variable Identifier="StartPrefix" Type="TPrefix"/>
        <Variable Identifier="EndPrefix" Type="TPrefix"/>
      </Variables>
      <Block>
        <Case Expression="UnitType" Optimalisation="integermapping">
          <On Select="TDisplayUnitType.duMicroVoltage">
            <Execute Statement="UnitS:= cVolt"/>
          </On>
          <On Select="TDisplayUnitType.duMicroAmp">
            <Execute Statement="UnitS:= cAmp"/>
          </On>
          <On Select="TDisplayUnitType.duMicroResistance">
            <Execute Statement="UnitS:= cOhm"/>
          </On>
          <On Select="TDisplayUnitType.duFemtoCapacitance">
            <Execute Statement="UnitS:= cFarad"/>
            <Execute Statement="FactorType:= TFactorType.ftFemto"/>
          </On>
          <On Select="TDisplayUnitType.duFemtoInductance">
            <Execute Statement="UnitS:= cHenry"/>
            <Execute Statement="FactorType:= TFactorType.ftFemto"/>
          </On>
          <On Select="TDisplayUnitType.duMicroPercentage">
            <Execute Statement="FactorType:= TFactorType.ftMicroAsSingle"/>
            <Execute Statement="UnitS:= cPerc"/>
          </On>
          <On Select="TDisplayUnitType.duMicroPower">
            <Execute Statement="UnitS:= cWatt"/>
          </On>
        </Case>
        <Exit Result="'0' + UnitS" Condition="Value = 0"/>
        <Case Expression="FactorType" Optimalisation="integermapping">
          <On Select="TFactorType.ftFemto">
            <Execute Statement="StartPrefix:= TPrefix.pfKilo"/>
            <Execute Statement="Factor:= facKiloToFemto"/>
            <Execute Statement="EndPrefix:= TPrefix.pfPico"/>
          </On>
          <On Select="TFactorType.ftMicro">
            <Execute Statement="StartPrefix:= TPrefix.pfGiga"/>
            <Execute Statement="Factor:= facGigaToMicro"/>
            <Execute Statement="EndPrefix:= TPrefix.pfMicro"/>
          </On>
          <On Select="TFactorType.ftMicroAsSingle">
            <Execute Statement="StartPrefix:= TPrefix.pfNone"/>
            <Execute Statement="Factor:= facToMicro"/>
            <Execute Statement="EndPrefix:= TPrefix.pfNone"/>
          </On>
        </Case>
        <Execute Statement="Prefix:= EndPrefix"/>
        <ForLoop Indexer="Index" From="StartPrefix" To="EndPrefix">
          <Execute Statement="Factor:= Factor div k" Condition="Index &lt;&gt; StartPrefix"/>
          <Execute Statement="NumValue:= Value div Factor"/>
          <ConditionalBlock Expression="NumValue &gt; 0">
            <Execute Statement="Prefix:= Index"/>
            <Break/>
          </ConditionalBlock>
        </ForLoop>
        <Case Expression="UnitType" Optimalisation="integermapping">
          <On Select="TDisplayUnitType.duFemtoCapacitance">
            <Case Expression="Prefix" Optimalisation="integermapping">
              <On Select="TPrefix.pfMilli">
                <Choose>
                  <When Expression="NumValue &gt;= 100">
                    <Execute Statement="Factor:= Factor * k"/>
                    <Execute Statement="NumValue:= Value div Factor"/>
                    <Execute Statement="Prefix:= TPrefix.pfNone"/>
                  </When>
                  <Otherwise>
                    <Execute Statement="Factor:= Factor div k"/>
                    <Execute Statement="NumValue:= Value div Factor"/>
                    <Execute Statement="Prefix:= TPrefix.pfMicro"/>
                  </Otherwise>
                </Choose>
              </On>
              <On Select="TPrefix.pfKilo">
                <Execute Statement="Factor:= Factor div k"/>
                <Execute Statement="NumValue:= Value div Factor"/>
                <Execute Statement="Prefix:= TPrefix.pfNone"/>
              </On>
            </Case>
          </On>
        </Case>
        <Execute Statement="Result:= Format('%d', NumValue)"/>
        <Execute Statement="Value:= Value - (NumValue * Factor)"/>
        <Execute Statement="Factor:= Factor div 10"/>
        <ConditionalBlock Expression="Value &gt; 0">
          <Execute Statement="Result:= Result + ','"/>
          <RepeatUntilLoop Expression="Value = 0">
            <Execute Statement="NumValue:= Value div Factor"/>
            <Execute Statement="Value:= Value - (NumValue * Factor)"/>
            <Execute Statement="Result:= Result + Format('%d', NumValue)"/>
            <Execute Statement="Factor:= Factor div 10"/>
          </RepeatUntilLoop>
        </ConditionalBlock>
        <Case Expression="Prefix" Optimalisation="integermapping">
          <On Select="TPrefix.pfTera">
            <Execute Statement="Result:= Result + cTera + UnitS"/>
          </On>
          <On Select="TPrefix.pfGiga">
            <Execute Statement="Result:= Result + cGiga + UnitS"/>
          </On>
          <On Select="TPrefix.pfMega">
            <Execute Statement="Result:= Result + cMega + UnitS"/>
          </On>
          <On Select="TPrefix.pfKilo">
            <Execute Statement="Result:= Result + cKilo + UnitS"/>
          </On>
          <On Select="TPrefix.pfNone">
            <Execute Statement="Result:= Result + UnitS"/>
          </On>
          <On Select="TPrefix.pfMilli">
            <Execute Statement="Result:= Result + cMilli + UnitS"/>
          </On>
          <On Select="TPrefix.pfMicro">
            <Execute Statement="Result:= Result + cMicro + UnitS"/>
          </On>
          <On Select="TPrefix.pfNano">
            <Execute Statement="Result:= Result + cNano + UnitS"/>
          </On>
          <On Select="TPrefix.pfPico">
            <Execute Statement="Result:= Result + cPico + UnitS"/>
          </On>
          <On Select="TPrefix.pfFemto">
            <Execute Statement="Result:= Result + cFemto + UnitS"/>
          </On>
        </Case>
      </Block>
    </Function>

    <Function Identifier="FormatMicroOhm">
      <Parameters>
        <Parameter Identifier="MicroValue" Type="Int64"/>
      </Parameters>
      <Block>
        <Execute Statement="Result:= FormatUnitValue(MicroValue, TDisplayUnitType.duMicroResistance)"/>
      </Block>
    </Function>

    <Function Identifier="FormatMicroWatt">
      <Parameters>
        <Parameter Identifier="MicroValue" Type="Int64"/>
      </Parameters>
      <Block>
        <Execute Statement="Result:= FormatUnitValue(MicroValue, TDisplayUnitType.duMicroPower)"/>
      </Block>
    </Function>

    <Function Identifier="FormatMicroVolt">
      <Parameters>
        <Parameter Identifier="MicroValue" Type="Int64"/>
      </Parameters>
      <Block>
        <Execute Statement="Result:= FormatUnitValue(MicroValue, TDisplayUnitType.duMicroVoltage)"/>
      </Block>
    </Function>

    <Function Identifier="FormatMicroAmp">
      <Parameters>
        <Parameter Identifier="MicroValue" Type="Int64"/>
      </Parameters>
      <Block>
        <Execute Statement="Result:= FormatUnitValue(MicroValue, TDisplayUnitType.duMicroAmp)"/>
      </Block>
    </Function>

    <Function Identifier="FormatFemtoFarad">
      <Parameters>
        <Parameter Identifier="FemtoValue" Type="Int64"/>
      </Parameters>
      <Block>
        <Exit Result="'0µF'" Condition="FemtoValue = 0"/>
        <Execute Statement="Result:= FormatUnitValue(FemtoValue, TDisplayUnitType.duFemtoCapacitance)"/>
      </Block>
    </Function>

    <Function Identifier="FormatFemtoHenry">
      <Parameters>
        <Parameter Identifier="FemtoValue" Type="Int64"/>
      </Parameters>
      <Block>
        <Exit Result="'0mH'" Condition="FemtoValue = 0"/>
        <Execute Statement="Result:= FormatUnitValue(FemtoValue, TDisplayUnitType.duFemtoInductance)"/>
      </Block>
    </Function>

    <Function Identifier="FormatMicroPercentage">
      <Parameters>
        <Parameter Identifier="MicroValue" Type="Int64"/>
      </Parameters>
      <Block>
        <Execute Statement="Result:= FormatUnitValue(MicroValue, TDisplayUnitType.duMicroPercentage)"/>
      </Block>
    </Function>

    <Function Identifier="CreatePrefix" Type="string" IsDeterministic="1">
      <Parameters>
        <Parameter Identifier="Value" Type="Extended"/>
        <Parameter Identifier="aUnit"/>
        <Parameter Identifier="IsCapacitance" Type="Boolean"/>
      </Parameters>
      <Variables>
        <Variable Identifier="Prefix" Type="string" Init="''"/>
      </Variables>
      <Block>
        <rep:Reporter.Information Text="'CreatePrefix'" Condition="IsDebugging"/>
        <Choose>
          <When Expression="(Value &gt;= M) or (Value &lt;= -M)">
            <Execute Statement="Prefix:= cMega"/>
            <Execute Statement="Value:= Value / M"/>
          </When>
          <When Expression="(Value &gt;= k) or (Value &lt;= -k)">
            <Execute Statement="Prefix:= cKilo"/>
            <Execute Statement="Value:= Value / k"/>
          </When>
          <When Expression="(Value &gt;= 1) or (Value &lt;= -1)">
            <Execute Statement="Prefix:= ''"/>
          </When>
          <When Expression="((Value &gt;= Milli) or (Value &lt;= -Milli)) and not IsCapacitance">
            <Execute Statement="Prefix:= cMilli"/>
            <Execute Statement="Value:= Value * 1000"/>
          </When>
          <When Expression="(Value &gt;= micro) or (Value &lt;= -micro)">
            <Execute Statement="Prefix:= cMicro"/>
            <Execute Statement="Value:= Value * 1000000"/>
          </When>
          <When Expression="(Value &gt;= nano) or (Value &lt;= -nano)">
            <Execute Statement="Prefix:= cNano"/>
            <Execute Statement="Value:= Value * 1000000000"/>
          </When>
        </Choose>
        <Execute Statement="Result:= Format('%.2f%s%s', Value, Prefix, aUnit)"/>
      </Block>
    </Function>
    <Function Identifier="FormatVoltage" Type="string" IsDeterministic="1">
      <Parameters>
        <Parameter Identifier="voltValue" Type="Extended"/>
      </Parameters>
      <Block>
        <Execute Statement="Result:= CreatePrefix(voltValue, cVolt, False)"/>
      </Block>
    </Function>
    <Function Identifier="FormatDistance" Type="string" IsDeterministic="1">
      <Parameters>
        <Parameter Identifier="mValue" Type="Extended"/>
      </Parameters>
      <Block>
        <Execute Statement="Result:= CreatePrefix(mValue, cMeter, False)"/>
      </Block>
    </Function>
    <Function Identifier="FormatCurrent" Type="string" IsDeterministic="1">
      <Parameters>
        <Parameter Identifier="ampValue" Type="Extended"/>
      </Parameters>
      <Block>
        <Execute Statement="Result:= CreatePrefix(ampValue, cAmp, False)"/>
      </Block>
    </Function>
    <Function Identifier="FormatFrequency" Type="string" IsDeterministic="1">
      <Parameters>
        <Parameter Identifier="freqValue" Type="Extended"/>
      </Parameters>
      <Block>
        <Execute Statement="Result:= CreatePrefix(freqValue, cHz, False)"/>
      </Block>
    </Function>
    <Function Identifier="FormatCapacitance" Type="string" IsDeterministic="1">
      <Parameters>
        <Parameter Identifier="faradValue" Type="Extended"/>
      </Parameters>
      <Block>
        <Execute Statement="Result:= CreatePrefix(faradValue, cFarad, True)"/>
      </Block>
    </Function>
    <Function Identifier="FormatPower" Type="string" IsDeterministic="1">
      <Parameters>
        <Parameter Identifier="wattValue" Type="Extended"/>
      </Parameters>
      <Block>
        <Execute Statement="Result:= CreatePrefix(wattValue, cWatt, False)"/>
      </Block>
    </Function>
    <Function Identifier="FormatResistance" Type="string" IsDeterministic="1">
      <Parameters>
        <Parameter Identifier="Value" Type="Extended"/>
      </Parameters>
      <Block>
        <Execute Statement="Result:= CreatePrefix(Value, cOhm, False)"/>
      </Block>
    </Function>
    <Function Identifier="WireResistance" Type="Extended" IsDeterministic="1">
      <Parameters>
        <Parameter Identifier="mWireLength" Type="Extended"/>
        <Parameter Identifier="m2WireSurface" Type="Extended"/>
        <Parameter Identifier="Resistivity" Type="Extended"/>
      </Parameters>
      <Block>
        <Execute Statement="Result:= mWireLength * Resistivity / m2WireSurface"/>
      </Block>
    </Function>

    <Function Identifier="CopperWireResistance" Type="Extended" IsDeterministic="1">
      <Parameters>
        <Parameter Identifier="mWireLength" Type="Extended"/>
        <Parameter Identifier="m2WireSurface" Type="Extended"/>
      </Parameters>
      <Block>
        <Execute Statement="Result:= WireResistance(mWireLength, m2WireSurface, CopperResistivity)"/>
      </Block>
    </Function>

    <Function Identifier="RippleVoltage" Type="Extended" IsDeterministic="1">
      <Parameters>
        <Parameter Identifier="ampLoadCurrent" Type="Extended"/>
        <Parameter Identifier="faradCapacitor" Type="Extended"/>
        <Parameter Identifier="Factor" Type="Extended"/>
      </Parameters>
      <Block>
        <Execute Statement="Result:= Factor * ampLoadCurrent / (faradCapacitor * 1000)"/>
      </Block>
    </Function>

    <Function Identifier="DoubleFaseRippleVoltage" Type="Extended" IsDeterministic="1">
      <Parameters>
        <Parameter Identifier="ampLoadCurrent" Type="Extended"/>
        <Parameter Identifier="faradCapacitor" Type="Extended"/>
      </Parameters>
      <Block>
        <Execute Statement="Result:= RippleVoltage(ampLoadCurrent, faradCapacitor, 1.5)"/>
      </Block>
    </Function>

    <Function Identifier="SignificantTrunc" Type="Int64" IsDeterministic="1">
      <Parameters>
        <Parameter Identifier="Value" Type="Int64"/>
        <Parameter Identifier="OrderValue" Type="Int64"/>
      </Parameters>
      <Variables>
        <Variable Identifier="Modulus" Type="Int64" Init="1"/>
        <Variable Identifier="Factor" Type="Int64" Init="1"/>
      </Variables>
      <Block>
        <WhileLoop Expression="(Value div OrderValue) &gt; 0">
          <Execute Statement="OrderValue:= OrderValue * 10"/>
          <Execute Statement="Factor:= Factor * 10"/>
        </WhileLoop>
        <Execute Statement="Result:= Value div Factor * Factor"/>
      </Block>
    </Function>

    <Function Identifier="TSerie.FindNode" Type="TSerieNode">
      <Parameters>
        <Parameter Identifier="Value" Type="UInt64"/>
      </Parameters>
      <Block>
        <Choose>
          <When Expression="Value &gt; Tail.Value">
            <RepeatUntilLoop Expression="Value &lt;= Tail.Value">
              <Exit Result="ObjNil" Condition="Value mod 10 &lt;&gt; 0"/>
              <Execute Statement="Value:= Value div 10"/>
              <rep:Reporter.Information Text="Format('Value: %d', Value)" Condition="IsDebugging"/>
            </RepeatUntilLoop>
          </When>
          <When Expression="Value = 0">
            <Exit Result="ObjNil"/>
          </When>
          <When Expression="Value &lt; Head.Value">
            <RepeatUntilLoop Expression="Value &gt;= Head.Value">
              <Execute Statement="Value:= Value * 10"/>
              <rep:Reporter.Information Text="Format('Value: %d', Value)" Condition="IsDebugging"/>
            </RepeatUntilLoop>
          </When>
        </Choose>
        <rep:Reporter.Information Text="Format('Value: %d', Value)" Condition="IsDebugging"/>

        <Execute Statement="Result:= Root"/>
        <WhileLoop Expression="Assigned(Result)">
          <rep:Reporter.Information Text="Format('Result: %d', Result.Value)" Condition="IsDebugging"/>
          <Choose>
            <When Expression="Value &lt; Result.Value">
              <Execute Statement="Result:= Result.Less"/>
            </When>
            <When Expression="Value &gt; Result.Value">
              <Execute Statement="Result:= Result.More"/>
            </When>
            <Otherwise>
              <Exit/>
            </Otherwise>
          </Choose>
        </WhileLoop>
      </Block>
    </Function>

    <Function Identifier="TSerie.MatchNode" Type="TSerieNode">
      <Parameters>
        <Parameter Identifier="Value" Type="Int64"/>
        <Parameter Identifier="MatchedValue" Type="Int64" Direction="Output"/>
        <Parameter Identifier="MatchKind" Type="TMatchValueKind"/>
      </Parameters>
      <Variables>
        <!--Values equal or below can be scaled one more time -->
        <Variable Identifier="Less" Type="TSerieNode"/>
        <Variable Identifier="More" Type="TSerieNode"/>
        <Variable Identifier="OverFlowFactor" Type="Int64"/>
        <Variable Identifier="MatchFactor" Type="Int64" Init="1"/>
        <Variable Identifier="ValueFactor" Type="Int64" Init="1"/>
        <Variable Identifier="ValueDivisor" Type="Int64" Init="1"/>
        <Variable Identifier="ScaledValue" Type="Int64" Init="Value"/>
        <Variable Identifier="MoreValue" Type="Int64"/>
        <Variable Identifier="LessValue" Type="Int64"/>
        <Variable Identifier="LessValueFactor" Type="Int64"/>
      </Variables>
      <Block>
        <rep:Reporter.Information Text="Format('Value: %d', Value)" Condition="IsDebugging"/>
        <Choose>
          <When Expression="Value &gt;= Tail.Value">
            <!-- 
            Tail.Value * 10 is max value when rapped
            Tail.Value * 10 * 10 because this value must be able to be scaled
            -->
            <Execute Statement="OverFlowFactor:= MaxInt64 div (Tail.Value * 100)" />
            <rep:Reporter.Information Text="Format('OverFlowFactor: %d', OverFlowFactor)" Condition="IsDebugging"/>
            <RepeatUntilLoop Expression="ScaledValue &lt;= Tail.Value * MatchFactor">
              <rep:Reporter.Information Text="Format('ScaledValue: %d', ScaledValue)" Condition="IsDebugging"/>
              <Choose>
                <When Expression="MatchFactor &gt; OverFlowFactor">
                  <rep:Reporter.Information Text="Format('MatchFactor would overflow: %d', MatchFactor)" Condition="IsDebugging"/>
                  <Execute Statement="ValueDivisor:= ValueDivisor * 10"/>
                  <Case Expression="MatchKind" Optimalisation="integermapping">
                    <On Select="TMatchValueKind.LessOrEqual">
                      <Execute Statement="ScaledValue:= Value div ValueDivisor"/>
                    </On>
                    <On Select="TMatchValueKind.MoreOrEqual">
                      <Execute Statement="ScaledValue:= (Value + ValueDivisor - 1) div ValueDivisor"/>
                    </On>
                    <Otherwise>
                      <Execute Statement="ScaledValue:= (Value + ValueDivisor shr 1) div ValueDivisor"/>
                    </Otherwise>
                  </Case>
                </When>
                <Otherwise>
                  <Execute Statement="MatchFactor:= MatchFactor * 10"/>
                </Otherwise>
              </Choose>
              <rep:Reporter.Information Text="Format('ScaledValue: %d; MatchFactor: %d', ScaledValue, MatchFactor)" Condition="IsDebugging"/>
            </RepeatUntilLoop>
          </When>
          <When Expression="Value = 0">
            <Execute Statement="MatchedValue:= 0"/>
            <Exit Result="ObjNil"/>
          </When>
          <When Expression="Value &lt; Head.Value">
            <RepeatUntilLoop Expression="ScaledValue &gt;= Head.Value">
              <Execute Statement="ValueFactor:= ValueFactor * 10"/>
              <Execute Statement="ScaledValue:= Value * ValueFactor"/>
              <rep:Reporter.Information Text="Format('ScaledValue: %d', ScaledValue)" Condition="IsDebugging"/>
            </RepeatUntilLoop>
          </When>
        </Choose>
        <rep:Reporter.Information Text="Format('ScaledValue: %d; MatchFactor: %d; ValueFactor: %d; ValueDivisor: %d', ScaledValue, MatchFactor, ValueFactor, ValueDivisor)" Condition="IsDebugging"/>

        <Execute Statement="Result:= Root"/>
        <WhileLoop Expression="Assigned(Result)">
          <rep:Reporter.Information Text="Format('Result: %d', Result.Value)" Condition="IsDebugging"/>
          <Choose>
            <When Expression="ScaledValue &lt; Result.Value * MatchFactor">
              <Execute Statement="More:= Result"/>
              <Execute Statement="Result:= Result.Less"/>
            </When>
            <When Expression="ScaledValue &gt; Result.Value * MatchFactor">
              <Execute Statement="Less:= Result"/>
              <Execute Statement="Result:= Result.More"/>
            </When>
            <Otherwise>
              <rep:Reporter.Information Text="'Perfect match'" Condition="IsDebugging"/>
              <Case Expression="MatchKind" Optimalisation="integermapping">
                <On Select="TMatchValueKind.LessOrEqual">
                  <Execute Statement="MatchedValue:= (Result.Value * MatchFactor) div ValueFactor * ValueDivisor"/>
                </On>
                <On Select="TMatchValueKind.MoreOrEqual">
                  <Execute Statement="MatchedValue:= (Result.Value * MatchFactor + ValueFactor - 1) div ValueFactor * ValueDivisor"/>
                </On>
                <Otherwise>
                  <Execute Statement="MatchedValue:= (Result.Value * MatchFactor + ValueFactor shr 1) div ValueFactor * ValueDivisor"/>
                </Otherwise>
              </Case>
              <Exit/>
            </Otherwise>
          </Choose>
        </WhileLoop>
        <rep:Reporter.Information Text="'Inperfect match'" Condition="IsDebugging"/>
        <Case Expression="MatchKind" Optimalisation="integermapping">
          <On Select="TMatchValueKind.LessOrEqual">
            <Block Condition="IsEmpty(Less)">
              <Execute Statement="ValueFactor:= ValueFactor * 10"/>
              <Execute Statement="Less:= Tail"/>
              <rep:Reporter.Information Text="'Less:= Tail'" Condition="IsDebugging"/>
            </Block>
            <rep:Reporter.Information Text="Format('Less: %d', Less.Value)" Condition="IsDebugging"/>
            <Execute Statement="Result:= Less"/>
            <Execute Statement="MatchedValue:= (Result.Value * MatchFactor + ValueFactor shr 1) div ValueFactor * ValueDivisor"/>
          </On>
          <On Select="TMatchValueKind.MoreOrEqual">
            <Block Condition="IsEmpty(More)">
              <Execute Statement="MatchFactor:= MatchFactor * 10"/>
              <Execute Statement="More:= Head"/>
            </Block>
            <rep:Reporter.Information Text="Format('More: %d', More.Value)" Condition="IsDebugging"/>
            <Execute Statement="Result:= More"/>
            <Execute Statement="MatchedValue:= (Result.Value * MatchFactor + ValueFactor shr 1) div ValueFactor * ValueDivisor"/>
          </On>
          <Otherwise>
            <Execute Statement="LessValueFactor:= ValueFactor"/>
            <Block Condition="IsEmpty(Less)">
              <rep:Reporter.Information Text="'Less:= Head'" Condition="IsDebugging"/>
              <Execute Statement="LessValueFactor:= LessValueFactor * 10"/>
              <Execute Statement="Less:= Tail"/>
            </Block>
            <rep:Reporter.Information Text="Format('Less: %d', Less.Value)" Condition="IsDebugging"/>
            <Execute Statement="LessValue:= (Less.Value * MatchFactor + LessValueFactor shr 1) div LessValueFactor * ValueDivisor"/>
            <Block Condition="IsEmpty(More)">
              <rep:Reporter.Information Text="'More:= Tail'" Condition="IsDebugging"/>
              <Execute Statement="MatchFactor:= MatchFactor * 10"/>
              <Execute Statement="More:= Head"/>
            </Block>
            <rep:Reporter.Information Text="Format('More: %d', More.Value)" Condition="IsDebugging"/>
            <Execute Statement="MoreValue:= (More.Value * MatchFactor + ValueFactor shr 1) div ValueFactor * ValueDivisor"/>
            <rep:Reporter.Information Text="Format('%d vs %d', LessValue, MoreValue)" Condition="IsDebugging"/>
            <Choose>
              <When Expression="(Value - LessValue) &lt; (MoreValue - Value)">
                <Execute Statement="Result:= Less"/>
                <Execute Statement="MatchedValue:= LessValue"/>
              </When>
              <Otherwise>
                <Execute Statement="Result:= More"/>
                <Execute Statement="MatchedValue:= MoreValue"/>
              </Otherwise>
            </Choose>
          </Otherwise>
        </Case>
      </Block>
    </Function>
    
    <Function Identifier="TSerie.ValueMicro" Type="Extended">
      <Parameters>
        <Parameter Identifier="Value" Type="Extended"/>
        <Parameter Identifier="MatchKind" Type="TMatchValueKind"/>
      </Parameters>
      <Variables>
        <Variable Identifier="MatchedValue" Type="Int64"/>
      </Variables>
      <Block>
        <Execute Statement="MatchNode(Round(Value * facToMicro), MatchedValue, MatchKind)"/>
        <Execute Statement="Result:= MatchedValue * micro"/>
      </Block>
    </Function>

    <Constructor Identifier="TSerie.Create">
      <Parameters>
        <Parameter Identifier="SerieType" Type="TESerie"/>
      </Parameters>
      <Variables>
        <Variable Identifier="Head" Type="TSerieNode" />
        <Variable Identifier="Tail" Type="TSerieNode" />
      </Variables>
      <Procedures>

        <Procedure Identifier="AddValue">
          <Parameters>
            <Parameter Identifier="Value" Type="UInt32"/>
            <Parameter Identifier="LowSerie" Type="TESerie"/>
          </Parameters>
          <Variables>
            <Variable Identifier="NewNode" Type="TSerieNode" Init="TSerieNode.Create(Value, LowSerie)"/>
          </Variables>
          <Block>
            <Choose>
              <When Expression="IsEmpty(Head)">
                <Execute Statement="Head:= NewNode"/>
              </When>
              <Otherwise>
                <Execute Statement="NewNode.Previous:= Tail"/>
                <Execute Statement="Tail.Next:= NewNode"/>
              </Otherwise>
            </Choose>
            <Execute Statement="Tail:= NewNode"/>
          </Block>
        </Procedure>

        <Procedure Identifier="InitESerie2">
          <Block>
            <Execute Statement="Self.Scale:= 10"/>
            <Execute Statement="AddValue(10, TESerie.E3)"  Condition="SerieType &gt;=TESerie.E3"/>
            <Execute Statement="AddValue(11, TESerie.E24)" Condition="SerieType &gt;=TESerie.E24"/>
            <Execute Statement="AddValue(12, TESerie.E12)" Condition="SerieType &gt;=TESerie.E12"/>
            <Execute Statement="AddValue(13, TESerie.E24)" Condition="SerieType &gt;=TESerie.E24"/>
            <Execute Statement="AddValue(15, TESerie.E6)"  Condition="SerieType &gt;=TESerie.E6"/>
            <Execute Statement="AddValue(16, TESerie.E24)" Condition="SerieType &gt;=TESerie.E24"/>
            <Execute Statement="AddValue(18, TESerie.E12)" Condition="SerieType &gt;=TESerie.E12"/>
            <Execute Statement="AddValue(20, TESerie.E24)" Condition="SerieType &gt;=TESerie.E24"/>
            <Execute Statement="AddValue(22, TESerie.E3)"  Condition="SerieType &gt;=TESerie.E3"/>
            <Execute Statement="AddValue(24, TESerie.E24)" Condition="SerieType &gt;=TESerie.E24"/>
            <Execute Statement="AddValue(27, TESerie.E12)" Condition="SerieType &gt;=TESerie.E12"/>
            <Execute Statement="AddValue(30, TESerie.E24)" Condition="SerieType &gt;=TESerie.E24"/>
            <Execute Statement="AddValue(33, TESerie.E6)"  Condition="SerieType &gt;=TESerie.E6"/>
            <Execute Statement="AddValue(36, TESerie.E24)" Condition="SerieType &gt;=TESerie.E24"/>
            <Execute Statement="AddValue(39, TESerie.E12)" Condition="SerieType &gt;=TESerie.E12"/>
            <Execute Statement="AddValue(43, TESerie.E24)" Condition="SerieType &gt;=TESerie.E24"/>
            <Execute Statement="AddValue(47, TESerie.E3)"  Condition="SerieType &gt;=TESerie.E3"/>
            <Execute Statement="AddValue(51, TESerie.E24)" Condition="SerieType &gt;=TESerie.E24"/>
            <Execute Statement="AddValue(56, TESerie.E12)" Condition="SerieType &gt;=TESerie.E12"/>
            <Execute Statement="AddValue(62, TESerie.E24)" Condition="SerieType &gt;=TESerie.E24"/>
            <Execute Statement="AddValue(68, TESerie.E6)"  Condition="SerieType &gt;=TESerie.E6"/>
            <Execute Statement="AddValue(75, TESerie.E24)" Condition="SerieType &gt;=TESerie.E24"/>
            <Execute Statement="AddValue(82, TESerie.E12)" Condition="SerieType &gt;=TESerie.E12"/>
            <Execute Statement="AddValue(91, TESerie.E24)" Condition="SerieType &gt;=TESerie.E24"/>
          </Block>
        </Procedure>

        <Procedure Identifier="InitESerie3">
          <Block>
            <Execute Statement="Self.Scale:= 100"/>
            <Execute Statement="AddValue(100, TESerie.E48)"  Condition="SerieType &gt;=TESerie.E48"/>
            <Execute Statement="AddValue(101, TESerie.E192)" Condition="SerieType &gt;=TESerie.E192"/>
            <Execute Statement="AddValue(102, TESerie.E96)"  Condition="SerieType &gt;=TESerie.E96"/>
            <Execute Statement="AddValue(104, TESerie.E192)" Condition="SerieType &gt;=TESerie.E192"/>
            <Execute Statement="AddValue(105, TESerie.E48)"  Condition="SerieType &gt;=TESerie.E48"/>
            <Execute Statement="AddValue(106, TESerie.E192)" Condition="SerieType &gt;=TESerie.E192"/>
            <Execute Statement="AddValue(107, TESerie.E96)"  Condition="SerieType &gt;=TESerie.E96"/>
            <Execute Statement="AddValue(109, TESerie.E192)" Condition="SerieType &gt;=TESerie.E192"/>
            <Execute Statement="AddValue(110, TESerie.E48)"  Condition="SerieType &gt;=TESerie.E48"/>
            <Execute Statement="AddValue(111, TESerie.E192)" Condition="SerieType &gt;=TESerie.E192"/>
            <Execute Statement="AddValue(113, TESerie.E96)"  Condition="SerieType &gt;=TESerie.E96"/>
            <Execute Statement="AddValue(114, TESerie.E192)" Condition="SerieType &gt;=TESerie.E192"/>
            <Execute Statement="AddValue(115, TESerie.E48)"  Condition="SerieType &gt;=TESerie.E48"/>
            <Execute Statement="AddValue(117, TESerie.E192)" Condition="SerieType &gt;=TESerie.E192"/>
            <Execute Statement="AddValue(118, TESerie.E96)"  Condition="SerieType &gt;=TESerie.E96"/>
            <Execute Statement="AddValue(120, TESerie.E192)" Condition="SerieType &gt;=TESerie.E192"/>
            <Execute Statement="AddValue(121, TESerie.E48)"  Condition="SerieType &gt;=TESerie.E48"/>
            <Execute Statement="AddValue(123, TESerie.E192)" Condition="SerieType &gt;=TESerie.E192"/>
            <Execute Statement="AddValue(124, TESerie.E96)"  Condition="SerieType &gt;=TESerie.E96"/>
            <Execute Statement="AddValue(126, TESerie.E192)" Condition="SerieType &gt;=TESerie.E192"/>
            <Execute Statement="AddValue(127, TESerie.E48)"  Condition="SerieType &gt;=TESerie.E48"/>
            <Execute Statement="AddValue(129, TESerie.E192)" Condition="SerieType &gt;=TESerie.E192"/>
            <Execute Statement="AddValue(130, TESerie.E96)"  Condition="SerieType &gt;=TESerie.E96"/>
            <Execute Statement="AddValue(132, TESerie.E192)" Condition="SerieType &gt;=TESerie.E192"/>
            <Execute Statement="AddValue(133, TESerie.E48)"  Condition="SerieType &gt;=TESerie.E48"/>
            <Execute Statement="AddValue(135, TESerie.E192)" Condition="SerieType &gt;=TESerie.E192"/>
            <Execute Statement="AddValue(137, TESerie.E96)"  Condition="SerieType &gt;=TESerie.E96"/>
            <Execute Statement="AddValue(138, TESerie.E192)" Condition="SerieType &gt;=TESerie.E192"/>
            <Execute Statement="AddValue(140, TESerie.E48)"  Condition="SerieType &gt;=TESerie.E48"/>
            <Execute Statement="AddValue(142, TESerie.E192)" Condition="SerieType &gt;=TESerie.E192"/>
            <Execute Statement="AddValue(143, TESerie.E96)"  Condition="SerieType &gt;=TESerie.E96"/>
            <Execute Statement="AddValue(145, TESerie.E192)" Condition="SerieType &gt;=TESerie.E192"/>
            <Execute Statement="AddValue(147, TESerie.E48)"  Condition="SerieType &gt;=TESerie.E48"/>
            <Execute Statement="AddValue(149, TESerie.E192)" Condition="SerieType &gt;=TESerie.E192"/>
            <Execute Statement="AddValue(150, TESerie.E96)"  Condition="SerieType &gt;=TESerie.E96"/>
            <Execute Statement="AddValue(152, TESerie.E192)" Condition="SerieType &gt;=TESerie.E192"/>
            <Execute Statement="AddValue(154, TESerie.E48)"  Condition="SerieType &gt;=TESerie.E48"/>
            <Execute Statement="AddValue(156, TESerie.E192)" Condition="SerieType &gt;=TESerie.E192"/>
            <Execute Statement="AddValue(158, TESerie.E96)"  Condition="SerieType &gt;=TESerie.E96"/>
            <Execute Statement="AddValue(160, TESerie.E192)" Condition="SerieType &gt;=TESerie.E192"/>
            <Execute Statement="AddValue(162, TESerie.E48)"  Condition="SerieType &gt;=TESerie.E48"/>
            <Execute Statement="AddValue(164, TESerie.E192)" Condition="SerieType &gt;=TESerie.E192"/>
            <Execute Statement="AddValue(165, TESerie.E96)"  Condition="SerieType &gt;=TESerie.E96"/>
            <Execute Statement="AddValue(167, TESerie.E192)" Condition="SerieType &gt;=TESerie.E192"/>
            <Execute Statement="AddValue(169, TESerie.E48)"  Condition="SerieType &gt;=TESerie.E48"/>
            <Execute Statement="AddValue(172, TESerie.E192)" Condition="SerieType &gt;=TESerie.E192"/>
            <Execute Statement="AddValue(174, TESerie.E96)"  Condition="SerieType &gt;=TESerie.E96"/>
            <Execute Statement="AddValue(176, TESerie.E192)" Condition="SerieType &gt;=TESerie.E192"/>
            <Execute Statement="AddValue(178, TESerie.E48)"  Condition="SerieType &gt;=TESerie.E48"/>
            <Execute Statement="AddValue(180, TESerie.E192)" Condition="SerieType &gt;=TESerie.E192"/>
            <Execute Statement="AddValue(182, TESerie.E96)"  Condition="SerieType &gt;=TESerie.E96"/>
            <Execute Statement="AddValue(184, TESerie.E192)" Condition="SerieType &gt;=TESerie.E192"/>
            <Execute Statement="AddValue(187, TESerie.E48)"  Condition="SerieType &gt;=TESerie.E48"/>
            <Execute Statement="AddValue(189, TESerie.E192)" Condition="SerieType &gt;=TESerie.E192"/>
            <Execute Statement="AddValue(191, TESerie.E96)"  Condition="SerieType &gt;=TESerie.E96"/>
            <Execute Statement="AddValue(193, TESerie.E192)" Condition="SerieType &gt;=TESerie.E192"/>
            <Execute Statement="AddValue(196, TESerie.E48)"  Condition="SerieType &gt;=TESerie.E48"/>
            <Execute Statement="AddValue(198, TESerie.E192)" Condition="SerieType &gt;=TESerie.E192"/>
            <Execute Statement="AddValue(200, TESerie.E96)"  Condition="SerieType &gt;=TESerie.E96"/>
            <Execute Statement="AddValue(203, TESerie.E192)" Condition="SerieType &gt;=TESerie.E192"/>
            <Execute Statement="AddValue(205, TESerie.E48)"  Condition="SerieType &gt;=TESerie.E48"/>
            <Execute Statement="AddValue(208, TESerie.E192)" Condition="SerieType &gt;=TESerie.E192"/>
            <Execute Statement="AddValue(210, TESerie.E96)"  Condition="SerieType &gt;=TESerie.E96"/>
            <Execute Statement="AddValue(213, TESerie.E192)" Condition="SerieType &gt;=TESerie.E192"/>
            <Execute Statement="AddValue(215, TESerie.E48)"  Condition="SerieType &gt;=TESerie.E48"/>
            <Execute Statement="AddValue(218, TESerie.E192)" Condition="SerieType &gt;=TESerie.E192"/>
            <Execute Statement="AddValue(221, TESerie.E96)"  Condition="SerieType &gt;=TESerie.E96"/>
            <Execute Statement="AddValue(223, TESerie.E192)" Condition="SerieType &gt;=TESerie.E192"/>
            <Execute Statement="AddValue(226, TESerie.E48)"  Condition="SerieType &gt;=TESerie.E48"/>
            <Execute Statement="AddValue(229, TESerie.E192)" Condition="SerieType &gt;=TESerie.E192"/>
            <Execute Statement="AddValue(232, TESerie.E96)"  Condition="SerieType &gt;=TESerie.E96"/>
            <Execute Statement="AddValue(234, TESerie.E192)" Condition="SerieType &gt;=TESerie.E192"/>
            <Execute Statement="AddValue(237, TESerie.E48)"  Condition="SerieType &gt;=TESerie.E48"/>
            <Execute Statement="AddValue(240, TESerie.E192)" Condition="SerieType &gt;=TESerie.E192"/>
            <Execute Statement="AddValue(243, TESerie.E96)"  Condition="SerieType &gt;=TESerie.E96"/>
            <Execute Statement="AddValue(246, TESerie.E192)" Condition="SerieType &gt;=TESerie.E192"/>
            <Execute Statement="AddValue(249, TESerie.E48)"  Condition="SerieType &gt;=TESerie.E48"/>
            <Execute Statement="AddValue(252, TESerie.E192)" Condition="SerieType &gt;=TESerie.E192"/>
            <Execute Statement="AddValue(255, TESerie.E96)"  Condition="SerieType &gt;=TESerie.E96"/>
            <Execute Statement="AddValue(258, TESerie.E192)" Condition="SerieType &gt;=TESerie.E192"/>
            <Execute Statement="AddValue(261, TESerie.E48)"  Condition="SerieType &gt;=TESerie.E48"/>
            <Execute Statement="AddValue(264, TESerie.E192)" Condition="SerieType &gt;=TESerie.E192"/>
            <Execute Statement="AddValue(267, TESerie.E96)"  Condition="SerieType &gt;=TESerie.E96"/>
            <Execute Statement="AddValue(271, TESerie.E192)" Condition="SerieType &gt;=TESerie.E192"/>
            <Execute Statement="AddValue(274, TESerie.E48)"  Condition="SerieType &gt;=TESerie.E48"/>
            <Execute Statement="AddValue(277, TESerie.E192)" Condition="SerieType &gt;=TESerie.E192"/>
            <Execute Statement="AddValue(280, TESerie.E96)"  Condition="SerieType &gt;=TESerie.E96"/>
            <Execute Statement="AddValue(284, TESerie.E192)" Condition="SerieType &gt;=TESerie.E192"/>
            <Execute Statement="AddValue(287, TESerie.E48)"  Condition="SerieType &gt;=TESerie.E48"/>
            <Execute Statement="AddValue(291, TESerie.E192)" Condition="SerieType &gt;=TESerie.E192"/>
            <Execute Statement="AddValue(294, TESerie.E96)" Condition="SerieType &gt;=TESerie.E96"/>
            <Execute Statement="AddValue(298, TESerie.E192)" Condition="SerieType &gt;=TESerie.E192"/>
            <Execute Statement="AddValue(301, TESerie.E48)" Condition="SerieType &gt;=TESerie.E48"/>
            <Execute Statement="AddValue(305, TESerie.E192)" Condition="SerieType &gt;=TESerie.E192"/>
            <Execute Statement="AddValue(309, TESerie.E96)" Condition="SerieType &gt;=TESerie.E96"/>
            <Execute Statement="AddValue(312, TESerie.E192)" Condition="SerieType &gt;=TESerie.E192"/>
            <Execute Statement="AddValue(316, TESerie.E48)"  Condition="SerieType &gt;=TESerie.E48"/>
            <Execute Statement="AddValue(320, TESerie.E192)" Condition="SerieType &gt;=TESerie.E192"/>
            <Execute Statement="AddValue(324, TESerie.E96)"  Condition="SerieType &gt;=TESerie.E96"/>
            <Execute Statement="AddValue(328, TESerie.E192)" Condition="SerieType &gt;=TESerie.E192"/>
            <Execute Statement="AddValue(332, TESerie.E48)"  Condition="SerieType &gt;=TESerie.E48"/>
            <Execute Statement="AddValue(336, TESerie.E192)" Condition="SerieType &gt;=TESerie.E192"/>
            <Execute Statement="AddValue(340, TESerie.E96)"  Condition="SerieType &gt;=TESerie.E96"/>
            <Execute Statement="AddValue(344, TESerie.E192)" Condition="SerieType &gt;=TESerie.E192"/>
            <Execute Statement="AddValue(348, TESerie.E48)"  Condition="SerieType &gt;=TESerie.E48"/>
            <Execute Statement="AddValue(352, TESerie.E192)" Condition="SerieType &gt;=TESerie.E192"/>
            <Execute Statement="AddValue(357, TESerie.E96)"  Condition="SerieType &gt;=TESerie.E96"/>
            <Execute Statement="AddValue(361, TESerie.E192)" Condition="SerieType &gt;=TESerie.E192"/>
            <Execute Statement="AddValue(365, TESerie.E48)"  Condition="SerieType &gt;=TESerie.E48"/>
            <Execute Statement="AddValue(370, TESerie.E192)" Condition="SerieType &gt;=TESerie.E192"/>
            <Execute Statement="AddValue(374, TESerie.E96)"  Condition="SerieType &gt;=TESerie.E96"/>
            <Execute Statement="AddValue(379, TESerie.E192)" Condition="SerieType &gt;=TESerie.E192"/>
            <Execute Statement="AddValue(383, TESerie.E48)"  Condition="SerieType &gt;=TESerie.E48"/>
            <Execute Statement="AddValue(388, TESerie.E192)" Condition="SerieType &gt;=TESerie.E192"/>
            <Execute Statement="AddValue(392, TESerie.E96)"  Condition="SerieType &gt;=TESerie.E96"/>
            <Execute Statement="AddValue(397, TESerie.E192)" Condition="SerieType &gt;=TESerie.E192"/>
            <Execute Statement="AddValue(402, TESerie.E48)"  Condition="SerieType &gt;=TESerie.E48"/>
            <Execute Statement="AddValue(407, TESerie.E192)" Condition="SerieType &gt;=TESerie.E192"/>
            <Execute Statement="AddValue(412, TESerie.E96)"  Condition="SerieType &gt;=TESerie.E96"/>
            <Execute Statement="AddValue(417, TESerie.E192)" Condition="SerieType &gt;=TESerie.E192"/>
            <Execute Statement="AddValue(422, TESerie.E48)"  Condition="SerieType &gt;=TESerie.E48"/>
            <Execute Statement="AddValue(427, TESerie.E192)" Condition="SerieType &gt;=TESerie.E192"/>
            <Execute Statement="AddValue(432, TESerie.E96)"  Condition="SerieType &gt;=TESerie.E96"/>
            <Execute Statement="AddValue(437, TESerie.E192)" Condition="SerieType &gt;=TESerie.E192"/>
            <Execute Statement="AddValue(442, TESerie.E48)"  Condition="SerieType &gt;=TESerie.E48"/>
            <Execute Statement="AddValue(448, TESerie.E192)" Condition="SerieType &gt;=TESerie.E192"/>
            <Execute Statement="AddValue(453, TESerie.E96)"  Condition="SerieType &gt;=TESerie.E96"/>
            <Execute Statement="AddValue(459, TESerie.E192)" Condition="SerieType &gt;=TESerie.E192"/>
            <Execute Statement="AddValue(464, TESerie.E48)"  Condition="SerieType &gt;=TESerie.E48"/>
            <Execute Statement="AddValue(470, TESerie.E192)" Condition="SerieType &gt;=TESerie.E192"/>
            <Execute Statement="AddValue(475, TESerie.E96)"  Condition="SerieType &gt;=TESerie.E96"/>
            <Execute Statement="AddValue(481, TESerie.E192)" Condition="SerieType &gt;=TESerie.E192"/>
            <Execute Statement="AddValue(487, TESerie.E48)"  Condition="SerieType &gt;=TESerie.E48"/>
            <Execute Statement="AddValue(493, TESerie.E192)" Condition="SerieType &gt;=TESerie.E192"/>
            <Execute Statement="AddValue(499, TESerie.E96)"  Condition="SerieType &gt;=TESerie.E96"/>
            <Execute Statement="AddValue(505, TESerie.E192)" Condition="SerieType &gt;=TESerie.E192"/>
            <Execute Statement="AddValue(511, TESerie.E48)"  Condition="SerieType &gt;=TESerie.E48"/>
            <Execute Statement="AddValue(517, TESerie.E192)" Condition="SerieType &gt;=TESerie.E192"/>
            <Execute Statement="AddValue(523, TESerie.E96)"  Condition="SerieType &gt;=TESerie.E96"/>
            <Execute Statement="AddValue(530, TESerie.E192)" Condition="SerieType &gt;=TESerie.E192"/>
            <Execute Statement="AddValue(536, TESerie.E48)"  Condition="SerieType &gt;=TESerie.E48"/>
            <Execute Statement="AddValue(542, TESerie.E192)" Condition="SerieType &gt;=TESerie.E192"/>
            <Execute Statement="AddValue(549, TESerie.E96)"  Condition="SerieType &gt;=TESerie.E96"/>
            <Execute Statement="AddValue(556, TESerie.E192)" Condition="SerieType &gt;=TESerie.E192"/>
            <Execute Statement="AddValue(562, TESerie.E48)"  Condition="SerieType &gt;=TESerie.E48"/>
            <Execute Statement="AddValue(569, TESerie.E192)" Condition="SerieType &gt;=TESerie.E192"/>
            <Execute Statement="AddValue(576, TESerie.E96)"  Condition="SerieType &gt;=TESerie.E96"/>
            <Execute Statement="AddValue(583, TESerie.E192)" Condition="SerieType &gt;=TESerie.E192"/>
            <Execute Statement="AddValue(590, TESerie.E48)"  Condition="SerieType &gt;=TESerie.E48"/>
            <Execute Statement="AddValue(597, TESerie.E192)" Condition="SerieType &gt;=TESerie.E192"/>
            <Execute Statement="AddValue(604, TESerie.E96)"  Condition="SerieType &gt;=TESerie.E96"/>
            <Execute Statement="AddValue(612, TESerie.E192)" Condition="SerieType &gt;=TESerie.E192"/>
            <Execute Statement="AddValue(619, TESerie.E48)"  Condition="SerieType &gt;=TESerie.E48"/>
            <Execute Statement="AddValue(626, TESerie.E192)" Condition="SerieType &gt;=TESerie.E192"/>
            <Execute Statement="AddValue(634, TESerie.E96)"  Condition="SerieType &gt;=TESerie.E96"/>
            <Execute Statement="AddValue(642, TESerie.E192)" Condition="SerieType &gt;=TESerie.E192"/>
            <Execute Statement="AddValue(649, TESerie.E48)"  Condition="SerieType &gt;=TESerie.E48"/>
            <Execute Statement="AddValue(657, TESerie.E192)" Condition="SerieType &gt;=TESerie.E192"/>
            <Execute Statement="AddValue(665, TESerie.E96)"  Condition="SerieType &gt;=TESerie.E96"/>
            <Execute Statement="AddValue(673, TESerie.E192)" Condition="SerieType &gt;=TESerie.E192"/>
            <Execute Statement="AddValue(681, TESerie.E48)"  Condition="SerieType &gt;=TESerie.E48"/>
            <Execute Statement="AddValue(690, TESerie.E192)" Condition="SerieType &gt;=TESerie.E192"/>
            <Execute Statement="AddValue(698, TESerie.E96)"  Condition="SerieType &gt;=TESerie.E96"/>
            <Execute Statement="AddValue(706, TESerie.E192)" Condition="SerieType &gt;=TESerie.E192"/>
            <Execute Statement="AddValue(715, TESerie.E48)"  Condition="SerieType &gt;=TESerie.E48"/>
            <Execute Statement="AddValue(723, TESerie.E192)" Condition="SerieType &gt;=TESerie.E192"/>
            <Execute Statement="AddValue(732, TESerie.E96)"  Condition="SerieType &gt;=TESerie.E96"/>
            <Execute Statement="AddValue(741, TESerie.E192)" Condition="SerieType &gt;=TESerie.E192"/>
            <Execute Statement="AddValue(750, TESerie.E48)"  Condition="SerieType &gt;=TESerie.E48"/>
            <Execute Statement="AddValue(759, TESerie.E192)" Condition="SerieType &gt;=TESerie.E192"/>
            <Execute Statement="AddValue(768, TESerie.E96)"  Condition="SerieType &gt;=TESerie.E96"/>
            <Execute Statement="AddValue(777, TESerie.E192)" Condition="SerieType &gt;=TESerie.E192"/>
            <Execute Statement="AddValue(787, TESerie.E48)"  Condition="SerieType &gt;=TESerie.E48"/>
            <Execute Statement="AddValue(796, TESerie.E192)" Condition="SerieType &gt;=TESerie.E192"/>
            <Execute Statement="AddValue(806, TESerie.E96)"  Condition="SerieType &gt;=TESerie.E96"/>
            <Execute Statement="AddValue(816, TESerie.E192)" Condition="SerieType &gt;=TESerie.E192"/>
            <Execute Statement="AddValue(825, TESerie.E48)"  Condition="SerieType &gt;=TESerie.E48"/>
            <Execute Statement="AddValue(835, TESerie.E192)" Condition="SerieType &gt;=TESerie.E192"/>
            <Execute Statement="AddValue(845, TESerie.E96)"  Condition="SerieType &gt;=TESerie.E96"/>
            <Execute Statement="AddValue(856, TESerie.E192)" Condition="SerieType &gt;=TESerie.E192"/>
            <Execute Statement="AddValue(866, TESerie.E48)"  Condition="SerieType &gt;=TESerie.E48"/>
            <Execute Statement="AddValue(876, TESerie.E192)" Condition="SerieType &gt;=TESerie.E192"/>
            <Execute Statement="AddValue(887, TESerie.E96)"  Condition="SerieType &gt;=TESerie.E96"/>
            <Execute Statement="AddValue(898, TESerie.E192)" Condition="SerieType &gt;=TESerie.E192"/>
            <Execute Statement="AddValue(909, TESerie.E48)"  Condition="SerieType &gt;=TESerie.E48"/>
            <Execute Statement="AddValue(920, TESerie.E192)" Condition="SerieType &gt;=TESerie.E192"/>
            <Execute Statement="AddValue(931, TESerie.E96)"  Condition="SerieType &gt;=TESerie.E96"/>
            <Execute Statement="AddValue(942, TESerie.E192)" Condition="SerieType &gt;=TESerie.E192"/>
            <Execute Statement="AddValue(953, TESerie.E48)"  Condition="SerieType &gt;=TESerie.E48"/>
            <Execute Statement="AddValue(965, TESerie.E192)" Condition="SerieType &gt;=TESerie.E192"/>
            <Execute Statement="AddValue(976, TESerie.E96)"  Condition="SerieType &gt;=TESerie.E96"/>
            <Execute Statement="AddValue(988, TESerie.E192)" Condition="SerieType &gt;=TESerie.E192"/>
          </Block>
        </Procedure>

        <FunctionHeader Identifier="GetRootNode" Type="TSerieNode">
          <Parameters>
            <Parameter Identifier="Head" Type="TSerieNode"/>
            <Parameter Identifier="Tail" Type="TSerieNode"/>
          </Parameters>
        </FunctionHeader>
        <Implementation Identifier="GetRootNode">
          <Variables>
            <Variable Identifier="Head2x" Type="TSerieNode"/>
          </Variables>
          <Block>
            <!--
Result := Head;
  if Head = Tail then
  begin
    Result^.RecLess := nil;
    Result^.RecMore := nil;
    Exit;
  end;
            -->
            <Execute Statement="Result:= Head"/>
            <Block Condition="Head = Tail">
              <Execute Statement="Result.Less := ObjNil"/>
              <Execute Statement="Result.More := ObjNil"/>
              <Exit/>
            </Block>
            <!--
  Head2x := Head;
Continue:
  Head2x := Head2x^.RecNext;
  if Head2x = Tail then
    goto Done;
  Head2x := Head2x^.RecNext;
  Result := Result^.RecNext;
  if Head2x = Tail then
    goto Done;
  goto Continue;
Done:
            -->
            <Execute Statement="Head2x:= Head"/>
            <RepeatUntilLoop Expression="Head2x = Tail">
              <Execute Statement="Head2x:= Head2x.Next"/>
              <Break Condition="Head2x = Tail"/>
              <Execute Statement="Head2x:= Head2x.Next"/>
              <Execute Statement="Result:= Result.Next"/>
            </RepeatUntilLoop>
            <!--
  Result^.RecLess := nil;
  Result^.RecMore := nil;
  if Result <> Head then
  begin
    Result^.RecLess := GetRootNode(Head, Result^.RecPrev);
  end;
  if Result <> Tail then
  begin
    Result^.RecMore := GetRootNode(Result^.RecNext, Tail);
  end;
            -->
            <Choose>
              <When Expression="Result &lt;&gt; Head">
                <Execute Statement="Result.Less := GetRootNode(Head, Result.Previous)"/>
              </When>
              <Otherwise>
                <Execute Statement="Result.Less := ObjNil"/>
              </Otherwise>
            </Choose>
            <Choose>
              <When Expression="Result &lt;&gt; Tail">
                <Execute Statement="Result.More := GetRootNode(Result.Next, Tail)"/>
              </When>
              <Otherwise>
                <Execute Statement="Result.More := ObjNil"/>
              </Otherwise>
            </Choose>
          </Block>
        </Implementation>

      </Procedures>
      <Block>
        <Choose>
          <When Expression="SerieType &gt;= TESerie.E48">
            <Execute Statement="InitESerie3"/>
          </When>
          <Otherwise>
            <Execute Statement="InitESerie2"/>
          </Otherwise>
        </Choose>
        <Execute Statement="Self.Head:= Head"/>
        <Execute Statement="Self.Tail:= Tail"/>
        <Execute Statement="Self.Root:= GetRootNode(Head, Tail)"/>
      </Block>
    </Constructor>

    <!--<Function Identifier="GetSerieValue" Type="Extended">
      <Parameters>
        <Parameter Identifier="Value" Type="Extended"/>
        <Parameter Identifier="Serie" Type="TSerie"/>
        <Parameter Identifier="IsMinimal" Type="Boolean"/>
      </Parameters>
      <Variables>
        <Variable Identifier="Scale" Type="Int64" Init="1"/>
        <Variable Identifier="ScaledValue" Type="Int64" Init="Round(Scale * Value)"/>
        <Variable Identifier="SerieScale" Type="Int64" Init="1"/>
        <Variable Identifier="RunningValue" Type="TSerieNode" Init="Serie.FirstValue"/>
        <Variable Identifier="PrevRunningValue" Type="TSerieNode" Init="ObjNil"/>
      </Variables>
      <Block>
        <Execute Statement="Result:= 0.0"/>
        <rep:Reporter.Information Text="Format('ScaledValue: %d', ScaledValue)" Condition="IsVerbose" Markup="Header2"/>
        <rep:Reporter.Information Text="Format('  Value: %f', Value)" Condition="IsVerbose"/>
        <Choose>
          <When Expression="Value = 0">
            <Execute Statement="Result:= 0"/>
            <Exit/>
          </When>
          <When Expression="ScaledValue &lt; Serie.FirstValue.Value">
            <RepeatUntilLoop Expression="ScaledValue &gt;= Serie.FirstValue.Value">
              <Execute Statement="Scale:= Scale * 10"/>
              -->
    <!--<rep:Reporter.Information Text="Format('  Serie.FirstValue.Value: %d', Serie.FirstValue.Value)" Condition="IsVerbose"/>
              <rep:Reporter.Information Text="Format('  Scale: %d', Scale)" Condition="IsVerbose"/>-->
    <!--
              <Execute Statement="ScaledValue:= Round(Scale * Value)"/>
              -->
    <!--<rep:Reporter.Information Text="Format('  ScaledValue: %d', ScaledValue)" Condition="IsVerbose"/>-->
    <!--
            </RepeatUntilLoop>
          </When>
          <Otherwise>
            <WhileLoop Expression="ScaledValue &gt; Serie.LastValue.Value">
              <Execute Statement="SerieScale:= SerieScale * 10"/>
              -->
    <!--<rep:Reporter.Information Text="Format('  Serie.LastValue.Value: %d', Serie.LastValue.Value)" Condition="IsVerbose"/>
              <rep:Reporter.Information Text="Format('  SerieScale: %d', SerieScale)" Condition="IsVerbose"/>-->
    <!--
              <Execute Statement="ScaledValue:= Round(Value / SerieScale)"/>
              -->
    <!--<rep:Reporter.Information Text="Format('  ScaledValue: %d', ScaledValue)" Condition="IsVerbose"/>-->
    <!--
            </WhileLoop>
          </Otherwise>
        </Choose>
        <WhileLoop Expression="Assigned(RunningValue)">
          <Break Condition="ScaledValue &lt;= RunningValue.Value"/>
          <Execute Statement="PrevRunningValue:= RunningValue"/>
          <Execute Statement="RunningValue:= RunningValue.Next"/>
        </WhileLoop>
        <Choose>
          <When Expression="IsMinimal">
            <Choose>
              <When Expression="not Assigned(RunningValue)">
                <Execute Statement="Result:= Serie.LastValue.Value * SerieScale / (Scale * 10)"/>
              </When>
              <Otherwise>
                <Execute Statement="Result:= RunningValue.Value * SerieScale / Scale"/>
              </Otherwise>
            </Choose>
          </When>
          <Otherwise>
            <Choose>
              <When Expression="not Assigned(PrevRunningValue)">
                <Execute Statement="Result:= Serie.LastValue.Value * SerieScale / (Scale * 10)"/>
              </When>
              <When Expression="not Assigned(RunningValue)">
                <Execute Statement="Result:= Serie.LastValue.Value * SerieScale / (Scale * 10)"/>
              </When>
              <When Expression="ScaledValue = RunningValue.Value">
                <Execute Statement="Result:= RunningValue.Value * SerieScale / Scale"/>
              </When>
              <Otherwise>
                <Execute Statement="Result:= PrevRunningValue.Value * SerieScale / Scale"/>
              </Otherwise>
            </Choose>
          </Otherwise>
        </Choose>
      </Block>

    </Function>-->
    <Function Identifier="GetESerie" Type="TSerie">
      <Parameters>
        <Parameter Identifier="ESerie" Type="TESerie"/>
      </Parameters>
      <Block>
        <Case Expression="ESerie" Optimalisation="integermapping">
          <On Select="TESerie.E3">
            <Choose>
              <When Expression="IsEmpty(_E3Serie)">
                <Execute Statement="Result:= TSerie.Create(ESerie)"/>
                <Execute Statement="_E3Serie:= Result"/>
              </When>
              <Otherwise>
                <Execute Statement="Result:= _E3Serie"/>
              </Otherwise>
            </Choose>
          </On>
          <On Select="TESerie.E6">
            <Choose>
              <When Expression="IsEmpty(_E6Serie)">
                <Execute Statement="Result:= TSerie.Create(ESerie)"/>
                <Execute Statement="_E6Serie:= Result"/>
              </When>
              <Otherwise>
                <Execute Statement="Result:= _E6Serie"/>
              </Otherwise>
            </Choose>
          </On>
          <On Select="TESerie.E12">
            <Choose>
              <When Expression="IsEmpty(_E12Serie)">
                <Execute Statement="Result:= TSerie.Create(ESerie)"/>
                <Execute Statement="_E12Serie:= Result"/>
              </When>
              <Otherwise>
                <Execute Statement="Result:= _E12Serie"/>
              </Otherwise>
            </Choose>
          </On>
          <On Select="TESerie.E24">
            <Choose>
              <When Expression="IsEmpty(_E24Serie)">
                <Execute Statement="Result:= TSerie.Create(ESerie)"/>
                <Execute Statement="_E24Serie:= Result"/>
              </When>
              <Otherwise>
                <Execute Statement="Result:= _E24Serie"/>
              </Otherwise>
            </Choose>
          </On>
          <On Select="TESerie.E48">
            <Choose>
              <When Expression="IsEmpty(_E48Serie)">
                <Execute Statement="Result:= TSerie.Create(ESerie)"/>
                <Execute Statement="_E48Serie:= Result"/>
              </When>
              <Otherwise>
                <Execute Statement="Result:= _E48Serie"/>
              </Otherwise>
            </Choose>
          </On>
          <On Select="TESerie.E96">
            <Choose>
              <When Expression="IsEmpty(_E96Serie)">
                <Execute Statement="Result:= TSerie.Create(ESerie)"/>
                <Execute Statement="_E96Serie:= Result"/>
              </When>
              <Otherwise>
                <Execute Statement="Result:= _E96Serie"/>
              </Otherwise>
            </Choose>
          </On>
          <On Select="TESerie.E192">
            <Choose>
              <When Expression="IsEmpty(_E192Serie)">
                <Execute Statement="Result:= TSerie.Create(ESerie)"/>
                <Execute Statement="_E192Serie:= Result"/>
              </When>
              <Otherwise>
                <Execute Statement="Result:= _E192Serie"/>
              </Otherwise>
            </Choose>
          </On>
        </Case>
      </Block>
    </Function>

    <Procedure Identifier="TSerie.Report">
      <Variables>
        <Variable Identifier="RunningValue" Type="TSerieNode" Init="Head"/>
        <Variable Identifier="Scale" Type="UInt32" Init="Self.Scale"/>
      </Variables>
      <Block>
        <Choose>
          <When Expression="Scale &gt;= 100">
            <WhileLoop Expression="Assigned(RunningValue)">
              <rep:Reporter.Information Text="Format('%d: %.2f',  RunningValue.Value, RunningValue.Value / Scale)"/>
              <Execute Statement="RunningValue:= RunningValue.Next"/>
            </WhileLoop>
          </When>
          <Otherwise>
            <WhileLoop Expression="Assigned(RunningValue)">
              <rep:Reporter.Information Text="Format('%d: %.1f',  RunningValue.Value, RunningValue.Value / Scale)"/>
              <Execute Statement="RunningValue:= RunningValue.Next"/>
            </WhileLoop>
          </Otherwise>
        </Choose>
      </Block>
    </Procedure>
  </Procedures>
</pkg:Library>