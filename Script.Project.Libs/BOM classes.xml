<?xml version="1.0" encoding="utf-8" standalone="no"?>
<pkg:Library
  xsi:schemaLocation="urn:schemas-www-wisware.nl-scriptingpackages ../XmlSchemas.Common.XmlScript/XMLScripting.Packages.xsd"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xmlns="urn:schemas-www-wisware.nl-xmlscripting"
  xmlns:ado="urn:schemas-www-wisware.nl-xmlscripting-ado"
  xmlns:fil="urn:schemas-www-wisware.nl-xmlscripting-filemanagement"
  xmlns:fwl="urn:schemas-www-wisware.nl-xmlscripting-windowsfirewall"
  xmlns:inx="urn:schemas-www-wisware.nl-xmlscripting-index"
  xmlns:lil="urn:schemas-www-wisware.nl-xmlscripting-linkedlist"
  xmlns:msx="urn:schemas-www-wisware.nl-xmlscripting-xml"
  xmlns:pkg="urn:schemas-www-wisware.nl-scriptingpackages"
  xmlns:reg="urn:schemas-www-wisware.nl-xmlscripting-registry"
  xmlns:rep="urn:schemas-www-wisware.nl-xmlscripting-report"
  xmlns:sts="urn:schemas-www-wisware.nl-xmlscripting-showstatus"
  xmlns:sys="urn:schemas-www-wisware.nl-xmlscripting"
  xmlns:syu="urn:schemas-www-wisware.nl-xmlscripting-sysutils"
  xmlns:stm="urn:schemas-www-wisware.nl-xmlscripting-statemanagement">
  <Uses>
    <Use Identifier="EnumerationUtils"/>
    <Use Identifier="ScienceUnits"/>
    <Use Identifier="ScienceIniHelper"/>
    <Use Identifier="ElectronicsUtils"/>
    <Use Identifier="ElectronicsReportUtils"/>
    <Use Identifier="BomStrings"/>
    <Use Identifier="BomEnumerations"/>
  </Uses>
  <Type>
    <DataClass.Forwarded Identifier="TComponentSpec"/>
    <DataClass.Forwarded Identifier="TStorageLocation"/>
    <DataClass.Forwarded Identifier="TPickRequest"/>

    <DataClass Identifier="TStorageLocationCategory">
      <Field Identifier="Name" Type="string"/>
      <Field Identifier="Description" Type="string"/>
      <Field Identifier="Parent" Type="TStorageLocationCategory"/>
      <Field Identifier="FirstChild" Type="TStorageLocationCategory"/>
      <Field Identifier="LastChild" Type="TStorageLocationCategory"/>
      <Field Identifier="NextSibling" Type="TStorageLocationCategory"/>
      <Field Identifier="FirstStorageLocation" Type="TStorageLocation"/>
      <Field Identifier="LastStorageLocation" Type="TStorageLocation"/>
    </DataClass>

    <DataClass Identifier="TStorageLocation">
      <Field Identifier="Name" Type="string"/>
      <Field Identifier="Category" Type="TStorageLocationCategory"/>
      <Field Identifier="NextSibling" Type="TStorageLocation"/>
      <Field Identifier="FirstPickRequest" Type="TPickRequest"/>
      <Field Identifier="LastPickRequest" Type="TPickRequest"/>
    </DataClass>

    <DataClass Identifier="TSchemaComponent" DefaultConstructor="none">
      <Field Identifier="Reference" Type="string"/>
      <Field Identifier="Prefix" Type="string"/>
      <Field Identifier="Counter" Type="UInt32"/>
      <Field Identifier="Decoded" Type="Boolean"/>
      <Field Identifier="Next" Type="TSchemaComponent"/>
    </DataClass>

    <DataClass Identifier="TStockCategory">
      <Field Identifier="ID" Type="Integer"/>
      <Field Identifier="Name" Type="string"/>
      <Field Identifier="ParentCategory" Type="TStockCategory"/>
      <Field Identifier="ComponentSpec" Type="TComponentSpec"/>
      <Field Identifier="FDeepSearchState" Type="TDeepSearchstate"/>
      <Field Identifier="SpecsAreInherited" Type="Boolean"/>
    </DataClass>

    <DataClass Identifier="TComponentValue" DefaultConstructor="createandsetfields">
      <Field Identifier="Name" Type="string"/>
      <Field Identifier="Value" Type="string"/>
      <Field Identifier="Next" Type="TComponentValue"/>
    </DataClass>

    <!--<DataClass Identifier="TFootprintInfo">
      <Field Identifier="ID" Type="Integer"/>
      <Field Identifier="Name" Type="string"/>
      <Field Identifier="Footprint" Type="TFootprint"/>
    </DataClass>-->

    <DataClass Identifier="TStockComponent" DefaultConstructor="createonly">
      <Field Identifier="ID" Type="Integer"/>
      <Field Identifier="Name" Type="string"/>
      <Field Identifier="NeedsReview" Type="Boolean"/>
      <Field Identifier="Description" Type="string"/>
      <Field Identifier="PartCondition" Type="string"/>
      <Field Identifier="Status" Type="string"/>
      <Field Identifier="Comment" Type="string"/>
      <Field Identifier="ProductionRemarks" Type="string"/>
      <Field Identifier="Amount" Type="UInt32"/>
      <Field Identifier="PickedCount" Type="UInt32"/>
      <Field Identifier="Location" Type="TStorageLocation"/>
      <Field Identifier="InternalPartNumber" Type="string"/>
      <!--<Field Identifier="FootPrintInfo" Type="TFootprintInfo"/>-->
      <Field Identifier="StockCategory" Type="TStockCategory"/>
      <Field Identifier="Next" Type="TStockComponent"/>
    </DataClass>

    <DataClass Identifier="TSpecificationLink" DefaultConstructor="createandsetfields">
      <Field Identifier="StockComponentSpec" Type="TComponentSpec"/>
      <Field Identifier="Next" Type="TSpecificationLink"/>
    </DataClass>

    <DataClass Identifier="TPickRequest" DefaultConstructor="createandsetfields">
      <Field Identifier="SchemaComponentSpec" Type="TComponentSpec"/>
      <Field Identifier="StockSpec" Type="TComponentSpec"/>
      <Field Identifier="StockComponent" Type="TStockComponent"/>
      <Field Identifier="Next" Type="TPickRequest"/>
    </DataClass>

    <DataClass Identifier="TSpecificationLinks" DefaultConstructor="createandsetfields">
      <Field Identifier="Head" Type="TSpecificationLink"/>
      <Field Identifier="Tail" Type="TSpecificationLink"/>
    </DataClass>

    <DataClass Identifier="TSpecificationIndex" DefaultConstructor="createandsetfields">
      <VirtualMethod Identifier="vmGetKey"/>
      <VirtualMethod Identifier="vmFinalize" IsFinalizer="true"/>
      <Field Identifier="HashList" Type="TAbstractBoxedValueMappingHashIndex"/>
      <Field Identifier="HashListLoaded" Type="Boolean"/>
    </DataClass>

    <DataClass Identifier="TSpecReportContext">
      <Field Identifier="ColumnOffset" Type="Integer"/>
      <Field Identifier="ColumnManager" Type="TTextColumnManager"/>
      <Field Identifier="Measure" Type="Boolean"/>
    </DataClass>

    <DataClass Identifier="TBaseReportContext">
      <Field Identifier="SpecContext" Type="TSpecReportContext"/>
      <Field Identifier="Measure" Type="Boolean"/>
    </DataClass>

    <DataClass Identifier="TStockReportContext" Inherit="TBaseReportContext">
    </DataClass>

    <DataClass Identifier="TSchemaReportContext" Inherit="TBaseReportContext">
    </DataClass>

    <DataClass Identifier="TDesignatorsReportContext" Inherit="TBaseReportContext">
    </DataClass>

    <DataClass Identifier="TComponentSpec" DefaultConstructor="createonly">
      <VirtualMethod Identifier="vmHandleLibSource"/>
      <VirtualMethod Identifier="vmHandleField"/>
      <VirtualMethod Identifier="vmCheckComponentKind"/>
      <VirtualMethod Identifier="vmSpecificationAsString"/>
      <VirtualMethod Identifier="vmApplyTemplate"/>
      <VirtualMethod Identifier="vmDoesMatchSpecification"/>
      <VirtualMethod Identifier="vmCategoryMatchScore"/>
      <Field Identifier="Template" Type="TComponentSpec"/>
      <Field Identifier="ComponentKind" Type="TComponentKind"/>
      <Field Identifier="ComponentKindVT" Type="TValueType"/>
      <Field Identifier="ErrorComponentKind" Type="string"/>
      <Field Identifier="Footprint" Type="string"/>
      <Field Identifier="FootprintMask" Type="TAnsiMaskObject"/>
      <Field Identifier="FootprintVT" Type="TValueType"/>
      <Field Identifier="ErrorFootprint" Type="string"/>
      <Field Identifier="ID" Type="Integer"/>
      <Field Identifier="SchemaComponentHead" Type="TSchemaComponent"/>
      <Field Identifier="SchemaComponentTail" Type="TSchemaComponent"/>
      <Field Identifier="StockComponentHead" Type="TStockComponent"/>
      <Field Identifier="StockComponentTail" Type="TStockComponent"/>
      <Field Identifier="MatchedSpecLinkHead" Type="TSpecificationLink"/>
      <Field Identifier="MatchedSpecLinkTail" Type="TSpecificationLink"/>
      <Field Identifier="MatchedStockCategory" Type="TStockCategory"/>
      <Field Identifier="InternalPartNumberVT" Type="TValueType"/>
      <Field Identifier="InternalPartNumber" Type="string"/>
      <Field Identifier="PartNumberVT" Type="TValueType"/>
      <Field Identifier="PartNumber" Type="string"/>
      <Field Identifier="ManufacturerVT" Type="TValueType"/>
      <Field Identifier="Manufacturer" Type="string"/>
      <Field Identifier="SchemaUsageCount" Type="Integer"/>
      <Field Identifier="ComponentDesignators" Type="string"/>
      <Field Identifier="PickedCount" Type="UInt32"/>
      <Field Identifier="Next" Type="TComponentSpec"/>
    </DataClass>

    <DataClass Identifier="TPassiveSpec" Inherit="TComponentSpec">
      <VirtualMethod Identifier="vmGetValue"/>
      <VirtualMethod Identifier="vmSetValue"/>
    </DataClass>

    <DataClass Identifier="TComponentCategory" DefaultConstructor="createonly">
      <VirtualMethod Identifier="vmCreateSpecification"/>
      <VirtualMethod Identifier="vmIsValidSpecification"/>
      <VirtualMethod Identifier="vmCompareSpecifications"/>
      <VirtualMethod Identifier="vmReportComponentHeader"/>
      <VirtualMethod Identifier="vmLoadTemplatesFromIniFile"/>
      <VirtualMethod Identifier="vmGetTemplate"/>
      <VirtualMethod Identifier="vmCanExtractTemplateFromIniFile"/>
      <VirtualMethod Identifier="vmIndexSearchSpecifications"/>
      <Field Identifier="Next" Type="TComponentCategory"/>
      <Field Identifier="ComponentSpecHead" Type="TComponentSpec"/>
      <Field Identifier="ComponentSpecTail" Type="TComponentSpec"/>
    </DataClass>

    <DataClass Identifier="TUnitConvertor" DefaultConstructor="none">
      <Field Identifier="SiUnit" Type="TSiUnit"/>
      <Field Identifier="UnitStr" Type="UnitString"/>
      <!--<-<TUnitConvertor.Fields-->
      <Field Identifier="AllowPrefixTera" Type="Boolean"/>
      <Field Identifier="AllowPrefixGiga" Type="Boolean"/>
      <Field Identifier="AllowPrefixMega" Type="Boolean"/>
      <Field Identifier="AllowPrefixKilo" Type="Boolean"/>
      <Field Identifier="AllowPrefixMilli" Type="Boolean"/>
      <Field Identifier="AllowPrefixMicro" Type="Boolean"/>
      <Field Identifier="AllowPrefixNano" Type="Boolean"/>
      <Field Identifier="AllowPrefixPico" Type="Boolean"/>
      <Field Identifier="AllowPrefixFemto" Type="Boolean"/>
      <!-->->-->
    </DataClass>

  </Type>

  <Variables>
    <Variable Identifier="MaskManager" Type="TAnsiMaskManager"/>
    <Variable Identifier="SymbolComponentKindIndex" Type="TMappingCaseInSensitiveUnicodeStringToInt64" Init="TMappingCaseInSensitiveUnicodeStringToInt64.Create"/>
    <Variable Identifier="E192Serie" Type="TSerie" Init="GetESerie(TESerie.E192)"/>
    <Variable Identifier="E24Serie" Type="TSerie" Init="GetESerie(TESerie.E24)"/>
    <Variable Identifier="HideESerieOfValue" Type="Boolean" Init="False"/>
    <Variable Identifier="HideResistorMaxAmpVolt" Type="Boolean" Init="False"/>
    <Variable Identifier="HideZenerDiodeMaxAmp" Type="Boolean" Init="False"/>
    <Variable Identifier="HideFootPrint" Type="Boolean" Init="False"/>
    <Variable Identifier="SheetInfo" Type="TSheetInfo" Init="TSheetInfo.All"/>
    <Variable Identifier="SeperateComponents" Type="Boolean" Init="True"/>
    <Variable Identifier="SkipFootprintMatching" Type="Boolean" Init="False"/>
    <Variable Identifier="MaxShowResistorVoltage" Type="Voltage" Init="1⌠kV⌡"/>
    <!--<-<Variables.Converters-->
    <Variable Identifier="ucNone" Type="TUnitConvertor"/>
    <Variable Identifier="ucOhm" Type="TUnitConvertor"/>
    <Variable Identifier="ucWatt" Type="TUnitConvertor"/>
    <Variable Identifier="ucFarad" Type="TUnitConvertor"/>
    <Variable Identifier="ucHenry" Type="TUnitConvertor"/>
    <Variable Identifier="ucVolt" Type="TUnitConvertor"/>
    <Variable Identifier="ucAmp" Type="TUnitConvertor"/>
    <Variable Identifier="ucPerc" Type="TUnitConvertor"/>
    <Variable Identifier="ucHz" Type="TUnitConvertor"/>
    <Variable Identifier="ucMeter" Type="TUnitConvertor"/>
    <Variable Identifier="ucSecond" Type="TUnitConvertor"/>
    <!-->->-->
  </Variables>

  <Procedures>
    <Function Identifier="EDecimalQuantityToStr" Type="string">
      <Parameters>
        <Parameter Identifier="Value" Type="DecimalQuantity"/>
        <Parameter Identifier="UnitPostFix" Type="TUnitPostFix"/>
      </Parameters>
      <Block>
        <Case Expression="UnitPostFix" Optimalisation="integermapping">
          <On Select="TUnitPostFix.None">
            <DecimalQuantity.Format Expression="Value">
              <Group MatchedUnit="MatchedUnit" ScaledValue="ScaledValue"  ScaledUncertaintyValue="ScaledUncertaintyValue">
                <Match Unit="GΩ" UnitOverride="'G'" ScaledValue.Min="1"/>
                <Match Unit="MΩ" UnitOverride="'M'" ScaledValue.Min="1"/>
                <Match Unit="kΩ" UnitOverride="'k'" ScaledValue.Min="1"/>
                <Match Unit="Ω" UnitOverride="''" ScaledValue.Min="1"/>
                <Match Unit="mΩ" UnitOverride="'m'" ScaledValue.Min="1"/>
                <Match Unit="μΩ" UnitOverride="'μ'" ScaledValue.Min="1"/>
                <Match Unit="nΩ" UnitOverride="'n'"/>
                <Match Unit="MV" UnitOverride="'M'" ScaledValue.Min="1"/>
                <Match Unit="kV" UnitOverride="'k'" ScaledValue.Min="1"/>
                <Match Unit="V" UnitOverride="''" ScaledValue.Min="1"/>
                <Match Unit="mV" UnitOverride="'m'" ScaledValue.Min="1"/>
                <Match Unit="μV" UnitOverride="'μ'" ScaledValue.Min="1"/>
                <Match Unit="nV" UnitOverride="'n'"/>
                <Match Unit="kA" UnitOverride="'k'" ScaledValue.Min="1"/>
                <Match Unit="A" UnitOverride="''" ScaledValue.Min="1"/>
                <Match Unit="mA" UnitOverride="'m'" ScaledValue.Min="1"/>
                <Match Unit="μA" UnitOverride="'μ'" ScaledValue.Min="1"/>
                <Match Unit="nA" UnitOverride="'n'"/>
                <Match Unit="MW" UnitOverride="'M'" ScaledValue.Min="1"/>
                <Match Unit="kW" UnitOverride="'k'" ScaledValue.Min="1"/>
                <Match Unit="W" UnitOverride="''" ScaledValue.Min="1"/>
                <Match Unit="mW" UnitOverride="'m'" ScaledValue.Min="1"/>
                <Match Unit="μW" UnitOverride="'μ'" ScaledValue.Min="1"/>
                <Match Unit="nW" UnitOverride="'n'"/>
                <Match Unit="kF" UnitOverride="'k'" ScaledValue.Min="1"/>
                <Match Unit="F" UnitOverride="''" ScaledValue.Min="1"/>
                <Match Unit="mF" UnitOverride="'m'" ScaledValue.Min="1"/>
                <Match Unit="μF" UnitOverride="'μ'" ScaledValue.Min="1"/>
                <Match Unit="nF" UnitOverride="'n'" ScaledValue.Min="1"/>
                <Match Unit="pF" UnitOverride="'p'"/>
                <Match Unit="%" UnitOverride="''"/>
                <Block>
                  <Execute Statement="Result:= DecimalToStr(ScaledValue, 32, TDF.EngineringNoTrailingZero, True) + MatchedUnit"/>
                </Block>
              </Group>
              <Otherwise>
                <Execute Statement="Result:= DecimalQuantityToStr(Value, 32, TDF.EngineringNoTrailingZero, True)"/>
              </Otherwise>
            </DecimalQuantity.Format>
          </On>
          <Otherwise>
            <DecimalQuantity.Format Expression="Value">
              <Group MatchedUnit="MatchedUnit" ScaledValue="ScaledValue" ScaledUncertaintyValue="ScaledUncertaintyValue">
                <Match Unit="GΩ" ScaledValue.Min="1"/>
                <Match Unit="MΩ" ScaledValue.Min="1"/>
                <Match Unit="kΩ" ScaledValue.Min="1"/>
                <Match Unit="Ω" ScaledValue.Min="1"/>
                <Match Unit="mΩ" ScaledValue.Min="1"/>
                <Match Unit="μΩ" ScaledValue.Min="1"/>
                <Match Unit="nΩ" ScaledValue.Min="1e-100"/>
                <Match Unit="Ω"/>
                <Match Unit="MV" ScaledValue.Min="1"/>
                <Match Unit="kV" ScaledValue.Min="1"/>
                <Match Unit="V" ScaledValue.Min="1"/>
                <Match Unit="mV" ScaledValue.Min="1"/>
                <Match Unit="μV" ScaledValue.Min="1"/>
                <Match Unit="nV"/>
                <Match Unit="kA" ScaledValue.Min="1"/>
                <Match Unit="A" ScaledValue.Min="1"/>
                <Match Unit="mA" ScaledValue.Min="1"/>
                <Match Unit="μA" ScaledValue.Min="1"/>
                <Match Unit="nA"/>
                <Match Unit="MW" ScaledValue.Min="1"/>
                <Match Unit="kW" ScaledValue.Min="1"/>
                <Match Unit="W" ScaledValue.Min="1"/>
                <Match Unit="mW" ScaledValue.Min="1"/>
                <Match Unit="μW" ScaledValue.Min="1"/>
                <Match Unit="nW"/>
                <Match Unit="kF" ScaledValue.Min="1"/>
                <Match Unit="F" ScaledValue.Min="1"/>
                <!--<Match Unit="mF" ScaledValue.Min="1"/>-->
                <Match Unit="μF" ScaledValue.Min="1"/>
                <Match Unit="nF" ScaledValue.Min="1"/>
                <Match Unit="pF"/>
                <Block>
                  <Case Expression="UnitPostFix" Optimalisation="integermapping">
                    <On Select="TUnitPostFix.Compact">
                      <Execute Statement="Result:= DecimalToStr(ScaledValue, 14, TDF.NormSigNoTrailingZero, True) + MatchedUnit"/>
                    </On>
                    <Otherwise>
                      <Execute Statement="Result:= DecimalToStr(ScaledValue, 14, TDF.NormSigNoTrailingZero, True) + ' ' + MatchedUnit"/>
                    </Otherwise>
                  </Case>
                </Block>
              </Group>
              <Group  MatchedUnit="MatchedUnit" ScaledValue="ScaledValue" ScaledUncertaintyValue="ScaledUncertaintyValue">
                <Match Unit="%"/>
                <Block>
                  <Execute Statement="Result:= DecimalToStr(ScaledValue, 14, TDF.NormSigNoTrailingZero, True) + MatchedUnit"/>
                </Block>
              </Group>
              <Otherwise>
                <Execute Statement="Result:= DecimalQuantityToStr(Value, 14, TDF.NormSigNoTrailingZero, True)"/>
              </Otherwise>
            </DecimalQuantity.Format>
          </Otherwise>
        </Case>
      </Block>
    </Function>

    <Function Identifier="MaxVoltAmpToStr" Type="string">
      <Parameters>
        <Parameter Identifier="Value" Type="Quantity"/>
      </Parameters>
      <Block>
        <DecimalQuantity.Format Expression="Value">
          <Group MatchedUnit="MatchedUnit" ScaledValue="ScaledValue" ScaledUncertaintyValue="ScaledUncertaintyValue">
            <Match Unit="MV" ScaledValue.Min="1"/>
            <Match Unit="kV" ScaledValue.Min="1"/>
            <Match Unit="V" ScaledValue.Min="1"/>
            <Match Unit="mV" ScaledValue.Min="1"/>
            <Match Unit="μV" ScaledValue.Min="1"/>
            <Match Unit="nV"/>
            <Match Unit="kA" ScaledValue.Min="1"/>
            <Match Unit="A" ScaledValue.Min="1"/>
            <Match Unit="mA" ScaledValue.Min="1"/>
            <Match Unit="μA" ScaledValue.Min="1"/>
            <Match Unit="nA"/>
            <Block>
              <Execute Statement="Result:= DecimalToStr(ScaledValue, 3, TDF.EngineringNoTrailingZero, True) + MatchedUnit"/>
            </Block>
          </Group>
          <Otherwise>
            <Execute Statement="Result:= DecimalQuantityToStr(Value, 3, TDF.EngineringNoTrailingZero, True)"/>
          </Otherwise>
        </DecimalQuantity.Format>
      </Block>
    </Function>

    <Function Identifier="CompareStateStringValue" Type="Integer">
      <Parameters>
        <Parameter Identifier="ItemIDA" Type="Integer"/>
        <Parameter Identifier="ValueA" Type="string"/>
        <Parameter Identifier="ValueTypeA" Type="TValueType"/>
        <Parameter Identifier="ItemIDB" Type="Integer"/>
        <Parameter Identifier="ValueB" Type="string"/>
        <Parameter Identifier="ValueTypeB" Type="TValueType"/>
      </Parameters>
      <Block>
        <Execute Statement="Result:= 0"/>
        <Case Expression="ValueTypeA">
          <On Select="TValueType.Unspecified, TValueType.Cleared, TValueType.ClearedByTemplate">
            <Case Expression="ValueTypeB">
              <On Select="TValueType.Error, TValueType.ErrorByTemplate">
                <Exit Result="-1"/>
              </On>
              <On Select="TValueType.Specified, TValueType.SpecifiedByTemplate">
                <Execute Statement="Result:= 1"/>
              </On>
            </Case>
          </On>
          <On Select="TValueType.Specified, TValueType.SpecifiedByTemplate">
            <Case Expression="ValueTypeB">
              <On Select="TValueType.Unspecified, TValueType.Cleared, TValueType.ClearedByTemplate, TValueType.Error, TValueType.ErrorByTemplate">
                <Execute Statement="Result:= -1"/>
              </On>
              <On Select="TValueType.Specified, TValueType.SpecifiedByTemplate">
                <Execute Statement="Result:= CompareText(ValueA, ValueB)"/>
              </On>
            </Case>
          </On>
          <On Select="TValueType.Error, TValueType.ErrorByTemplate">
            <Case Expression="ValueTypeB">
              <On Select="TValueType.Error, TValueType.ErrorByTemplate">
                <Exit Result="-1" Condition="ItemIDA &lt; ItemIDB"/>
              </On>
              <Otherwise>
                <Execute Statement="Result:= 1"/>
              </Otherwise>
            </Case>
          </On>
        </Case>
      </Block>
    </Function>

    <!--<Function Identifier="FootprintAsString" Type="string" IsDeterministic="true">
      <Parameters>
        <Parameter Identifier="Footprint" Type="TFootprint"/>
      </Parameters>
      <Block>
        <Execute Statement="Result:= ''"/>
        <Case Expression="Footprint">
          <On Select="TFootprint.THT">
            <Execute Statement="Result:= sFootprintTHT"/>
          </On>
          <On Select="TFootprint.SMD">
            <Execute Statement="Result:= sFootprintSMD"/>
          </On>
          <Otherwise>
            <Execute Statement="Result:= sFootprintNamingMissing"/>
          </Otherwise>
        </Case>
      </Block>
    </Function>-->

    <Function Identifier="ESerieOfValue" Type="string" IsDeterministic="true">
      <Parameters>
        <Parameter Identifier="Value" Type="Decimal"/>
      </Parameters>
      <Variables>
        <Variable Identifier="SerieNode" Type="TSerieNode"/>
      </Variables>
      <Block>
        <Execute Statement="Result:= ''"/>
        <Exit Condition="HideESerieOfValue"/>
        <Execute Statement="SerieNode:= E24Serie.FindNode(Value)"/>
        <Execute Statement="SerieNode:= E192Serie.FindNode(Value)" Condition="not Assigned(SerieNode)"/>
        <Exit  Condition="not Assigned(SerieNode)"/>
        <Case Expression="SerieNode.LowSerie" Optimalisation="integermapping">
          <On Select="TESerie.E1, TESerie.E3">
            <Execute Statement="Result:= 'E3'"/>
          </On>
          <On Select="TESerie.E6">
            <Execute Statement="Result:= 'E6'"/>
          </On>
          <On Select="TESerie.E12">
            <Execute Statement="Result:= 'E12'"/>
          </On>
          <On Select="TESerie.E24">
            <Execute Statement="Result:= 'E24'"/>
          </On>
          <On Select="TESerie.E48">
            <Execute Statement="Result:= 'E48'"/>
          </On>
          <On Select="TESerie.E96">
            <Execute Statement="Result:= 'E96'"/>
          </On>
          <On Select="TESerie.E192">
            <Execute Statement="Result:= 'E192'"/>
          </On>
        </Case>
      </Block>
    </Function>

    <Function Identifier="CompareStateValue" Type="Integer">
      <Parameters>
        <Parameter Identifier="ItemIDA" Type="Integer"/>
        <Parameter Identifier="ValueA" Type="Int64"/>
        <Parameter Identifier="ValueTypeA" Type="TValueType"/>
        <Parameter Identifier="ItemIDB" Type="Integer"/>
        <Parameter Identifier="ValueB" Type="Int64"/>
        <Parameter Identifier="ValueTypeB" Type="TValueType"/>
      </Parameters>
      <Block>
        <Execute Statement="Result:= 0"/>
        <Case Expression="ValueTypeA">
          <On Select="TValueType.Unspecified, TValueType.Cleared, TValueType.ClearedByTemplate">
            <Case Expression="ValueTypeB">
              <On Select="TValueType.Error, TValueType.ErrorByTemplate">
                <Exit Result="-1"/>
              </On>
              <On Select="TValueType.Specified, TValueType.SpecifiedByTemplate">
                <Execute Statement="Result:= 1"/>
              </On>
            </Case>
          </On>
          <On Select="TValueType.Specified, TValueType.SpecifiedByTemplate">
            <Case Expression="ValueTypeB">
              <On Select="TValueType.Unspecified, TValueType.Cleared, TValueType.ClearedByTemplate">
                <Execute Statement="Result:= -1"/>
              </On>
              <On Select="TValueType.Error, TValueType.ErrorByTemplate">
                <Exit Result="-1"/>
              </On>
              <On Select="TValueType.Specified, TValueType.SpecifiedByTemplate">
                <Choose>
                  <When Expression="ValueA &lt; ValueB">
                    <Execute Statement="Result:= -1"/>
                  </When>
                  <When Expression="ValueA &gt; ValueB">
                    <Execute Statement="Result:= 1"/>
                  </When>
                </Choose>
              </On>
            </Case>
          </On>
          <On Select="TValueType.Error, TValueType.ErrorByTemplate">
            <Case Expression="ValueTypeB">
              <On Select="TValueType.Error, TValueType.ErrorByTemplate">
                <Exit Result="-1" Condition="ItemIDA &lt; ItemIDB"/>
                <Execute Statement="Result:= 1"/>
              </On>
              <Otherwise>
                <Execute Statement="Result:= 1"/>
              </Otherwise>
            </Case>
          </On>
        </Case>
      </Block>
    </Function>

    <Function Identifier="CompareStateValueRange" Type="Integer">
      <Parameters>
        <Parameter Identifier="ItemIDA" Type="Integer"/>
        <Parameter Identifier="ValueTypeA" Type="TValueType"/>
        <Parameter Identifier="ValueA" Type="DecimalQuantity"/>
        <Parameter Identifier="UpperBoundA" Type="DecimalQuantity"/>
        <Parameter Identifier="BoundTypeA" Type="TBoundType"/>
        <Parameter Identifier="ItemIDB" Type="Integer"/>
        <Parameter Identifier="ValueTypeB" Type="TValueType"/>
        <Parameter Identifier="ValueB" Type="DecimalQuantity"/>
        <Parameter Identifier="UpperBoundB" Type="DecimalQuantity"/>
        <Parameter Identifier="BoundTypeB" Type="TBoundType"/>
      </Parameters>
      <Type>
        <Enumeration Identifier="TValueState" Elements="Valid, Invalid"/>
        <Enumeration Identifier="TValuePriority" Elements="UpperBound, Exact, LowerBound"/>
      </Type>
      <Variables>
        <Variable Identifier="CheckValueStateA" Type="TValueState" Init="TValueState.Invalid"/>
        <Variable Identifier="CheckValueA" Type="DecimalQuantity"/>
        <Variable Identifier="CheckValuePriorityA" Type="TValuePriority"/>

        <Variable Identifier="CheckValueStateB" Type="TValueState" Init="TValueState.Invalid"/>
        <Variable Identifier="CheckValueB" Type="DecimalQuantity"/>
        <Variable Identifier="CheckValuePriorityB" Type="TValuePriority"/>
      </Variables>
      <Block>
        <Execute Statement="Result:= 0"/>
        <Case Expression="ValueTypeA" Optimalisation="integermapping">
          <On Select="TValueType.Specified, TValueType.SpecifiedByTemplate">
            <Execute Statement="CheckValueStateA:= TValueState.Valid"/>
            <Execute Statement="CheckValueA:= ValueA"/>
            <Execute Statement="CheckValuePriorityA:= TValuePriority.Exact"/>
          </On>
          <On Select="TValueType.SpecifiedEx, TValueType.SpecifiedExByTemplate">
            <Execute Statement="CheckValueStateA:= TValueState.Valid"/>
            <Case Expression="BoundTypeA">
              <On Select="TBoundType.Lower, TBoundType.Range">
                <Execute Statement="CheckValueA:= ValueA"/>
                <Execute Statement="CheckValuePriorityA:= TValuePriority.LowerBound"/>
              </On>
              <On Select="TBoundType.Upper">
                <Execute Statement="CheckValueA:= UpperBoundA"/>
                <Execute Statement="CheckValuePriorityA:= TValuePriority.UpperBound"/>
              </On>
            </Case>
          </On>
        </Case>

        <Case Expression="ValueTypeB" Optimalisation="integermapping">
          <On Select="TValueType.Specified, TValueType.SpecifiedByTemplate">
            <Execute Statement="CheckValueStateB:= TValueState.Valid"/>
            <Execute Statement="CheckValueB:= ValueB"/>
            <Execute Statement="CheckValuePriorityB:= TValuePriority.Exact"/>
          </On>
          <On Select="TValueType.SpecifiedEx, TValueType.SpecifiedExByTemplate">
            <Execute Statement="CheckValueStateB:= TValueState.Valid"/>
            <Case Expression="BoundTypeB">
              <On Select="TBoundType.Lower, TBoundType.Range">
                <Execute Statement="CheckValueB:= ValueB"/>
                <Execute Statement="CheckValuePriorityB:= TValuePriority.LowerBound"/>
              </On>
              <On Select="TBoundType.Upper">
                <Execute Statement="CheckValueB:= UpperBoundB"/>
                <Execute Statement="CheckValuePriorityB:= TValuePriority.UpperBound"/>
              </On>
            </Case>
          </On>
        </Case>
        <Execute Statement="Result:= CheckValueStateA - CheckValueStateB"/>
        <Exit Condition="(Result &lt;&gt; 0) or (CheckValueStateA = TValueState.Invalid)"/>
        <Choose>
          <When Expression="CheckValueA &lt; CheckValueB">
            <Exit Result="-1"/>
          </When>
          <When Expression="CheckValueA &gt; CheckValueB">
            <Exit Result="1"/>
          </When>
        </Choose>
        <Execute Statement="Result:= CheckValuePriorityA - CheckValuePriorityB"/>
        <Exit Condition="(Result &lt;&gt; 0)"/>

        <Execute Statement="CheckValueStateA:= TValueState.Invalid"/>
        <Case Expression="ValueTypeA" Optimalisation="integermapping">
          <On Select="TValueType.SpecifiedEx, TValueType.SpecifiedExByTemplate">
            <Case Expression="BoundTypeA">
              <On Select="TBoundType.Range">
                <Execute Statement="CheckValueA:= UpperBoundA"/>
                <Execute Statement="CheckValueStateA:= TValueState.Valid"/>
              </On>
            </Case>
          </On>
        </Case>

        <Execute Statement="CheckValueStateB:= TValueState.Invalid"/>
        <Case Expression="ValueTypeB" Optimalisation="integermapping">
          <On Select="TValueType.SpecifiedEx, TValueType.SpecifiedExByTemplate">
            <Case Expression="BoundTypeB">
              <On Select="TBoundType.Range">
                <Execute Statement="CheckValueB:= UpperBoundB"/>
                <Execute Statement="CheckValueStateB:= TValueState.Valid"/>
              </On>
            </Case>
          </On>
        </Case>

        <Execute Statement="Result:= CheckValueStateA - CheckValueStateB"/>
        <Exit Condition="(Result &lt;&gt; 0) or (CheckValueStateA = TValueState.Invalid)"/>
        <Choose>
          <When Expression="CheckValueA &lt; CheckValueB">
            <Exit Result="-1"/>
          </When>
          <When Expression="CheckValueA &gt; CheckValueB">
            <Exit Result="-1"/>
          </When>
        </Choose>
      </Block>
    </Function>

    <Function Identifier="CompareStateEnumValue" Type="Integer">
      <Parameters>
        <Parameter Identifier="ItemIDA" Type="Integer"/>
        <Parameter Identifier="ValueTypeA" Type="TValueType"/>
        <Parameter Identifier="ValueA" Type="TEnumBase"/>
        <Parameter Identifier="SetA" Type="TFlags"/>
        <Parameter Identifier="ItemIDB" Type="Integer"/>
        <Parameter Identifier="ValueTypeB" Type="TValueType"/>
        <Parameter Identifier="ValueB" Type="TEnumBase"/>
        <Parameter Identifier="SetB" Type="TFlags"/>
      </Parameters>
      <Type>
        <Enumeration Identifier="TValueState" Elements="Valid, Invalid"/>
      </Type>
      <Variables>
        <Variable Identifier="CheckValueStateA" Type="TValueState" Init="TValueState.Invalid"/>
        <Variable Identifier="CheckSetA" Type="TFlags"/>

        <Variable Identifier="CheckValueStateB" Type="TValueState" Init="TValueState.Invalid"/>
        <Variable Identifier="CheckSetB" Type="TFlags"/>
      </Variables>
      <Block>
        <Execute Statement="Result:= 0"/>
        <Case Expression="ValueTypeA" Optimalisation="integermapping">
          <On Select="TValueType.Specified, TValueType.SpecifiedByTemplate">
            <Execute Statement="CheckValueStateA:= TValueState.Valid"/>
            <Execute Statement="CheckSetA:= Flags(ValueA)"/>
          </On>
          <On Select="TValueType.SpecifiedEx, TValueType.SpecifiedExByTemplate">
            <Execute Statement="CheckValueStateA:= TValueState.Valid"/>
            <Execute Statement="CheckSetA:= SetA"/>
          </On>
        </Case>

        <Case Expression="ValueTypeB" Optimalisation="integermapping">
          <On Select="TValueType.Specified, TValueType.SpecifiedByTemplate">
            <Execute Statement="CheckValueStateB:= TValueState.Valid"/>
            <Execute Statement="CheckSetB:= Flags(ValueB)"/>
          </On>
          <On Select="TValueType.SpecifiedEx, TValueType.SpecifiedExByTemplate">
            <Execute Statement="CheckValueStateB:= TValueState.Valid"/>
            <Execute Statement="CheckSetB:= SetB"/>
          </On>
        </Case>

        <Execute Statement="Result:= CheckValueStateA - CheckValueStateB"/>
        <Exit Condition="(Result &lt;&gt; 0) or (CheckValueStateA = TValueState.Invalid)"/>
        <Exit Condition="SetA = SetB"/>
        <Flags.Loop Flags="SetA xor SetB" OrdinalIdentifier="I">
          <Choose>
            <When Expression="InFlags(I, SetA) and InFlags(I, SetB)">
              <Raise Expression="Exception.Create('Should not happen')"/>
            </When>
            <When Expression="InFlags(I, SetA)">
              <Execute Statement="Result:= 1"/>
            </When>
            <When Expression="InFlags(I, SetB)">
              <Execute Statement="Result:= -1"/>
            </When>
            <Otherwise>
              <Raise Expression="Exception.Create('Should not happen')"/>
            </Otherwise>
          </Choose>
          <Break/>
        </Flags.Loop>
      </Block>
    </Function>

    <Function Identifier="CompareStateValueRange" Type="Integer">
      <Parameters>
        <Parameter Identifier="ItemIDA" Type="Integer"/>
        <Parameter Identifier="ValueA" Type="DecimalQuantity"/>
        <Parameter Identifier="ValueTypeA" Type="TValueType"/>
        <Parameter Identifier="ValueMinA" Type="DecimalQuantity"/>
        <Parameter Identifier="ValueMinTypeA" Type="TValueType"/>
        <Parameter Identifier="ValueMaxA" Type="DecimalQuantity"/>
        <Parameter Identifier="ValueMaxTypeA" Type="TValueType"/>
        <Parameter Identifier="ItemIDB" Type="Integer"/>
        <Parameter Identifier="ValueB" Type="DecimalQuantity"/>
        <Parameter Identifier="ValueTypeB" Type="TValueType"/>
        <Parameter Identifier="ValueMinB" Type="DecimalQuantity"/>
        <Parameter Identifier="ValueMinTypeB" Type="TValueType"/>
        <Parameter Identifier="ValueMaxB" Type="DecimalQuantity"/>
        <Parameter Identifier="ValueMaxTypeB" Type="TValueType"/>
      </Parameters>
      <Type>
        <Enumeration Identifier="TSource" Elements="None, Min, Value, Max, SourceEnd"/>
      </Type>
      <Variables>
        <Variable Identifier="CheckValueA" Type="DecimalQuantity"/>
        <Variable Identifier="CheckTypeA" Type="TValueType"/>
        <Variable Identifier="CheckValueB" Type="DecimalQuantity"/>
        <Variable Identifier="CheckTypeB" Type="TValueType"/>
      </Variables>
      <Block>
        <Variable Identifier="SourceA" Type="TSource" Init="TSource.None"/>
        <Variable Identifier="SourceB" Type="TSource" Init="TSource.None"/>
        <Variable Identifier="MinSource" Type="TSource" Init="TSource.Min"/>
        <Execute Statement="Result:= 0"/>
        <RepeatUntilLoop Expression="MinSource &gt;= TSource.SourceEnd">
          <ForLoop  Indexer="I" From="MinSource" To="TSource.SourceEnd">
            <Execute Statement="SourceA:= I"/>
            <Case Expression="I" Optimalisation="integermapping">
              <On Select="TSource.Min">
                <Execute Statement="CheckTypeA:= ValueMinTypeA"/>
                <Case Expression="ValueMinTypeA">
                  <On Select="TValueType.Specified, TValueType.SpecifiedByTemplate">
                    <Execute Statement="CheckValueA:= ValueMinA"/>
                    <Break/>
                  </On>
                  <On Select="TValueType.Error, TValueType.ErrorByTemplate">
                    <Break/>
                  </On>
                </Case>
              </On>
              <On Select="TSource.Value">
                <Execute Statement="CheckTypeA:= ValueTypeA"/>
                <Case Expression="ValueTypeA">
                  <On Select="TValueType.Specified, TValueType.SpecifiedByTemplate">
                    <Execute Statement="CheckValueA:= ValueA"/>
                    <Break/>
                  </On>
                  <On Select="TValueType.Error, TValueType.ErrorByTemplate">
                    <Break/>
                  </On>
                </Case>
              </On>
              <On Select="TSource.Max">
                <Execute Statement="CheckTypeA:= ValueMaxTypeA"/>
                <Case Expression="ValueMaxTypeA">
                  <On Select="TValueType.Specified, TValueType.SpecifiedByTemplate">
                    <Execute Statement="CheckValueA:= ValueMaxA"/>
                    <Break/>
                  </On>
                  <On Select="TValueType.Error, TValueType.ErrorByTemplate">
                    <Break/>
                  </On>
                </Case>
              </On>
            </Case>
          </ForLoop>
          <ForLoop  Indexer="I" From="MinSource" To="TSource.SourceEnd">
            <Execute Statement="SourceB:= I"/>
            <Case Expression="I" Optimalisation="integermapping">
              <On Select="TSource.Min">
                <Execute Statement="CheckTypeB:= ValueMinTypeB"/>
                <Case Expression="ValueMinTypeB">
                  <On Select="TValueType.Specified, TValueType.SpecifiedByTemplate">
                    <Execute Statement="CheckValueB:= ValueMinB"/>
                    <Break/>
                  </On>
                  <On Select="TValueType.Error, TValueType.ErrorByTemplate">
                    <Break/>
                  </On>
                </Case>
              </On>
              <On Select="TSource.Value">
                <Execute Statement="CheckTypeB:= ValueTypeB"/>
                <Case Expression="ValueTypeB">
                  <On Select="TValueType.Specified, TValueType.SpecifiedByTemplate">
                    <Execute Statement="CheckValueB:= ValueB"/>
                    <Break/>
                  </On>
                  <On Select="TValueType.Error, TValueType.ErrorByTemplate">
                    <Break/>
                  </On>
                </Case>
              </On>
              <On Select="TSource.Max">
                <Execute Statement="CheckTypeB:= ValueMaxTypeB"/>
                <Case Expression="ValueMaxTypeB">
                  <On Select="TValueType.Specified, TValueType.SpecifiedByTemplate">
                    <Execute Statement="CheckValueB:= ValueMaxB"/>
                    <Break/>
                  </On>
                  <On Select="TValueType.Error, TValueType.ErrorByTemplate">
                    <Break/>
                  </On>
                </Case>
              </On>
            </Case>
          </ForLoop>
          <Case Expression="CheckTypeA">
            <On Select="TValueType.Unspecified, TValueType.Cleared, TValueType.ClearedByTemplate">
              <Case Expression="CheckTypeB">
                <On Select="TValueType.Error, TValueType.ErrorByTemplate">
                  <Exit Result="-1"/>
                </On>
                <On Select="TValueType.Specified, TValueType.SpecifiedByTemplate">
                  <Execute Statement="Result:= 1"/>
                </On>
              </Case>
            </On>
            <On Select="TValueType.Specified, TValueType.SpecifiedByTemplate">
              <Case Expression="CheckTypeB">
                <On Select="TValueType.Unspecified, TValueType.Cleared, TValueType.ClearedByTemplate">
                  <Exit Result="-1"/>
                </On>
                <On Select="TValueType.Error, TValueType.ErrorByTemplate">
                  <Exit Result="-1"/>
                </On>
                <On Select="TValueType.Specified, TValueType.SpecifiedByTemplate">
                  <Choose>
                    <When Expression="CheckValueA &lt; CheckValueB">
                      <Exit Result="-1"/>
                    </When>
                    <When Expression="CheckValueA &gt; CheckValueB">
                      <Exit Result="1"/>
                    </When>
                  </Choose>
                  <Block Condition="SourceA &lt;&gt; SourceB">
                    <Exit Result="SourceA - SourceB"/>
                  </Block>
                </On>
              </Case>
            </On>
            <On Select="TValueType.Error, TValueType.ErrorByTemplate">
              <Case Expression="CheckTypeB">
                <On Select="TValueType.Error, TValueType.ErrorByTemplate">
                  <Block Condition="SourceA &lt;&gt; SourceB">
                    <Exit Result="SourceA - SourceB"/>
                  </Block>
                  <Exit Result="-1" Condition="ItemIDA &lt; ItemIDB"/>
                  <Exit Result="1"/>
                </On>
                <Otherwise>
                  <Exit Result="1"/>
                </Otherwise>
              </Case>
            </On>
          </Case>
          <Execute Statement="MinSource:= SourceA + 1"/>
          <ExitOnAbortRequest/>
        </RepeatUntilLoop>

      </Block>
    </Function>

    <Function Identifier="TSpecificationIndex.GetKey" VirtualMethod="vmGetKey" Type="Boolean">
      <Parameters>
        <Parameter Identifier="ComponentSpec" Type="TComponentSpec"/>
        <Parameter Identifier="Key" Direction="Output"/>
      </Parameters>
      <Block>
        <Execute Statement="Result:= False"/>
      </Block>
    </Function>

    <Procedure Identifier="TSpecificationIndex.Finalize" VirtualMethod="vmFinalize">
      <Block>
        <Free Expression="HashList"/>
      </Block>
    </Procedure>

    <Procedure Identifier="TSpecificationIndex.LoadHashList">
      <Parameters>
        <Parameter Identifier="ComponentSpecHead" Type="TComponentSpec"/>
      </Parameters>
      <Variables>
        <Variable Identifier="Found" Type="Boolean"/>
        <Variable Identifier="Key"/>
        <Variable Identifier="RunningComponent" Type="TComponentSpec" Init="ComponentSpecHead"/>
        <Variable Identifier="Value" Type="TSpecificationLinks" Init="TSpecificationLinks.Create"/>
        <Variable Identifier="FoundValue" Type="TSpecificationLinks"/>
        <Variable Identifier="Link" Type="TSpecificationLink"/>
      </Variables>
      <Block>
        <Execute Statement="HashListLoaded:= True"/>
        <WhileLoop Expression="Assigned(RunningComponent)">
          <Block Condition="GetKey(RunningComponent, Key)">
            <Execute Statement="Link:= TSpecificationLink.Create(RunningComponent)"/>
            <inx:Index.MapValue Index="HashList" Key="Key" Value="Value" PreviousValue="FoundValue" Found="Found" Flags="NoErrorOnExist DiscardOnExist"/>
            <Choose>
              <When Expression="Found">
                <Execute Statement="FoundValue.Tail.Next:= Link"/>
                <Execute Statement="FoundValue.Tail:= Link"/>
              </When>
              <Otherwise>
                <Execute Statement="Value.Head:= Link"/>
                <Execute Statement="Value.Tail:= Link"/>
                <Execute Statement="Value:= TSpecificationLinks.Create"/>
              </Otherwise>
            </Choose>
          </Block>
          <Execute Statement="RunningComponent:= RunningComponent.Next"/>
        </WhileLoop>
        <Free Expression="Value"/>
      </Block>
    </Procedure>

    <Function Identifier="TSpecificationIndex.GetLinks" Type="Boolean">
      <Parameters>
        <Parameter Identifier="ComponentSpec" Type="TComponentSpec"/>
        <Parameter Identifier="ComponentSpecHead" Type="TComponentSpec"/>
        <Parameter Identifier="SearchSpecifications" Type="TSpecificationLink" Direction="Output"/>
      </Parameters>
      <Variables>
        <Variable Identifier="Found" Type="Boolean"/>
        <Variable Identifier="Key"/>
        <Variable Identifier="Value" Type="TSpecificationLinks"/>
      </Variables>
      <Block>
        <Execute Statement="Result:= False"/>
        <Block Condition="GetKey(ComponentSpec, Key)">
          <Execute Statement="Result:= True"/>
          <Execute Statement="LoadHashList(ComponentSpecHead)" Condition="not HashListLoaded"/>
          <inx:Index.FindValue Index="HashList" Key="Key" Value="Value" Found="Found" Flags="NoErrorOnNotFound"/>
          <Choose>
            <When Expression="Found">
              <Execute Statement="SearchSpecifications:= Value.Head"/>
            </When>
            <Otherwise>
              <Execute Statement="SearchSpecifications:= ObjNil"/>
            </Otherwise>
          </Choose>
        </Block>
      </Block>
    </Function>

    <FunctionHeader Identifier="TStorageLocationCategory.FinalizeOrderPicking" Type="Boolean"/>
    <Implementation Identifier="TStorageLocationCategory.FinalizeOrderPicking">
      <Block>
        <Execute Statement="Result:= False"/>
        <Variable Identifier="NewFirstChild" Type="TStorageLocationCategory" Init="ObjNil"/>
        <Variable Identifier="NewLastChild" Type="TStorageLocationCategory" Init="ObjNil"/>
        <lil:LinkedList.Iterate Head="FirstChild" ItemType="TStorageLocationCategory" RunningItem="ChildCategory" Next="ChildCategory.NextSibling">
          <Block Condition="ChildCategory.FinalizeOrderPicking">
            <lil:LinkedList.LinkUp Head="NewFirstChild" Tail="NewLastChild" Item="ChildCategory" TailLinkStatement="NewLastChild.NextSibling:= Item"/>
          </Block>
        </lil:LinkedList.Iterate>
        <Execute Statement="NewLastChild.NextSibling:= ObjNil" Condition="Assigned(NewLastChild)"/>
        <Block Condition="Assigned(NewFirstChild)">
          <lil:LinkedList.MergeSort Head="NewFirstChild" ItemType="TStorageLocationCategory" LinkUp="ItemA.NextSibling:= ItemB" Next="Item.NextSibling" IsInOrder="CompareText(ItemA.Name, ItemB.Name) &lt;= 0"/>
          <Execute Statement="Result:= True"/>
        </Block>
        <Execute Statement="FirstChild:= NewFirstChild"/>
        <Variable Identifier="NewFirstStorageLocation" Type="TStorageLocation" Init="ObjNil"/>
        <Variable Identifier="NewLastStorageLocation" Type="TStorageLocation" Init="ObjNil"/>
        <lil:LinkedList.Iterate Head="FirstStorageLocation" ItemType="TStorageLocation" RunningItem="StorageLocation" Next="StorageLocation.NextSibling">
          <Block Condition="Assigned(StorageLocation.FirstPickRequest)">
            <lil:LinkedList.LinkUp Head="NewFirstStorageLocation" Tail="NewLastStorageLocation" Item="StorageLocation" TailLinkStatement="NewLastStorageLocation.NextSibling:= Item"/>
          </Block>
        </lil:LinkedList.Iterate>
        <Execute Statement="NewLastStorageLocation.NextSibling:= ObjNil" Condition="Assigned(NewLastStorageLocation)"/>
        <Block Condition="Assigned(NewFirstStorageLocation)">
          <lil:LinkedList.MergeSort Head="NewFirstStorageLocation" ItemType="TStorageLocation" LinkUp="ItemA.NextSibling:= ItemB" Next="Item.NextSibling" IsInOrder="CompareText(ItemA.Name, ItemB.Name) &lt;= 0"/>
          <Execute Statement="Result:= True"/>
          <Execute Statement="FirstStorageLocation:= NewFirstStorageLocation"/>
        </Block>
      </Block>
    </Implementation>

    <ProcedureHeader Identifier="TStockCategory.AcquireSpecs"/>
    <Implementation Identifier="TStockCategory.AcquireSpecs">
      <Block>
        <Case Expression="FDeepSearchState" Optimalisation="integermapping">
          <On Select="TDeepSearchstate.None">
            <Choose>
              <When Expression="Assigned(ParentCategory)">
                <Execute Statement="FDeepSearchState:= TDeepSearchstate.Running"/>
                <Execute Statement="ParentCategory.AcquireSpecs"/>
                <Choose>
                  <When Expression="Assigned(ComponentSpec)">
                    <Execute Statement="ComponentSpec.Template:= ParentCategory.ComponentSpec"/>
                  </When>
                  <Otherwise>
                    <Execute Statement="ComponentSpec:= ParentCategory.ComponentSpec"/>
                    <Execute Statement="SpecsAreInherited:= True"/>
                  </Otherwise>
                </Choose>
              </When>
              <When Expression="not Assigned(ComponentSpec)">
                <Execute Statement="ComponentSpec:= TComponentSpec.Create"/>
              </When>
            </Choose>
            <Execute Statement="FDeepSearchState:= TDeepSearchstate.Done"/>
          </On>
          <On Select="TDeepSearchstate.Running">
            <Raise Expression="Exception.Create('Recursive category parent')" />
          </On>
          <On Select="TDeepSearchstate.Done">
            <Exit/>
          </On>
        </Case>
      </Block>
    </Implementation>

    <Constructor Identifier="TSchemaComponent.Create">
      <Parameters>
        <Parameter Identifier="Reference" Type="string"/>
      </Parameters>
      <Variables>
        <Variable Identifier="locDecoded" Type="Boolean"/>
        <Variable Identifier="locPrefix" Type="string"/>
        <Variable Identifier="locCounter" Type="string"/>
      </Variables>
      <Block>
        <Execute Statement="Self.Reference:= Reference"/>
        <Execute Statement="locDecoded:= DecodeReference(Reference, locPrefix, locCounter)"/>
        <Execute Statement="Decoded:= locDecoded"/>
        <ConditionalBlock Expression="locDecoded">
          <Execute Statement="Prefix:= locPrefix"/>
          <Execute Statement="Counter:= locCounter"/>
        </ConditionalBlock>
      </Block>
    </Constructor>

    <Function Identifier="TComponentSpec.CheckComponentKind" VirtualMethod="vmCheckComponentKind" Type="Boolean">
      <Parameters>
        <Parameter Identifier="ComponentKind" Type="TComponentKind"/>
      </Parameters>
      <Block>
        <Execute Statement="Result:= True"/>
      </Block>
    </Function>

    <Function Identifier="TComponentSpec.CategoryMatchScore" VirtualMethod="vmCategoryMatchScore" Type="Int64">
      <Parameters>
        <Parameter Identifier="ComponentSpec" Type="TComponentSpec"/>
      </Parameters>
      <Block>
        <Execute Statement="Result:= 0"/>
        <Case Expression="ComponentKindVT">
          <On Select="TValueType.Specified, TValueType.SpecifiedByTemplate">
            <Case Expression="ComponentSpec.ComponentKindVT">
              <On Select="TValueType.Specified, TValueType.SpecifiedByTemplate">
                <Exit Condition="ComponentKind &lt;&gt; ComponentSpec.ComponentKind"/>
                <Execute Statement="Result:= Result + 1"/>
              </On>
              <Otherwise>
                <Exit/>
              </Otherwise>
            </Case>
          </On>
          <On Select="TValueType.Error, TValueType.ErrorByTemplate">
            <Exit/>
          </On>
        </Case>
        <Execute Statement="Result:= Result shl 1"/>
        <Case Expression="PartNumberVT">
          <On Select="TValueType.Specified, TValueType.SpecifiedByTemplate">
            <Case Expression="ComponentSpec.PartNumberVT">
              <On Select="TValueType.Specified, TValueType.SpecifiedByTemplate">
                <Execute Statement="Result:= Result + 1" Condition="SameText(PartNumber, ComponentSpec.PartNumber)"/>
              </On>
              <Otherwise>
                <Exit/>
              </Otherwise>
            </Case>
          </On>
          <On Select="TValueType.Error, TValueType.ErrorByTemplate">
            <Exit/>
          </On>
        </Case>
        <Execute Statement="Result:= Result shl 1"/>
        <Case Expression="ManufacturerVT">
          <On Select="TValueType.Specified, TValueType.SpecifiedByTemplate">
            <Case Expression="ComponentSpec.ManufacturerVT">
              <On Select="TValueType.Specified, TValueType.SpecifiedByTemplate">
                <Execute Statement="Result:= Result + 1" Condition="SameText(Manufacturer, ComponentSpec.Manufacturer)"/>
              </On>
              <Otherwise>
                <Exit/>
              </Otherwise>
            </Case>
          </On>
          <On Select="TValueType.Error, TValueType.ErrorByTemplate">
            <Exit/>
          </On>
        </Case>
        <Execute Statement="Result:= Result shl 1"/>
        <Case Expression="FootprintVT">
          <On Select="TValueType.Specified, TValueType.SpecifiedByTemplate">
            <Case Expression="ComponentSpec.FootprintVT">
              <On Select="TValueType.Specified, TValueType.SpecifiedByTemplate">
                <Execute Statement="Result:= Result + 1" Condition="Footprint = ComponentSpec.Footprint"/>
              </On>
              <On Select="TValueType.SpecifiedExByTemplate, TValueType.SpecifiedEx">
                <Execute Statement="Result:= Result + 1" Condition="ComponentSpec.FootprintMask.Matches(Footprint)"/>
              </On>
              <On Select="TValueType.Unspecified, TValueType.Cleared, TValueType.ClearedByTemplate">
              </On>
              <Otherwise>
                <Exit/>
              </Otherwise>
            </Case>
          </On>
          <On Select="TValueType.Error, TValueType.ErrorByTemplate">
            <Exit/>
          </On>
        </Case>
        <Execute Statement="Result:= Result shl 1"/>
        <Case Expression="InternalPartNumberVT">
          <On Select="TValueType.Specified, TValueType.SpecifiedByTemplate">
            <Case Expression="ComponentSpec.InternalPartNumberVT">
              <On Select="TValueType.Specified, TValueType.SpecifiedByTemplate">
                <Execute Statement="Result:= Result + 1" Condition="SameText(InternalPartNumber, ComponentSpec.InternalPartNumber)"/>
              </On>
              <Otherwise>
                <Exit/>
              </Otherwise>
            </Case>
          </On>
          <On Select="TValueType.Error, TValueType.ErrorByTemplate">
            <Exit/>
          </On>
        </Case>
      </Block>
    </Function>

    <Function Identifier="TComponentSpec.DoesMatchSpecification" VirtualMethod="vmDoesMatchSpecification" Type="Boolean">
      <Parameters>
        <Parameter Identifier="ComponentSpec" Type="TComponentSpec"/>
      </Parameters>
      <Block>
        <Execute Statement="Result:= False"/>
        <Case Expression="ComponentKindVT">
          <On Select="TValueType.Specified, TValueType.SpecifiedByTemplate">
            <Case Expression="ComponentSpec.ComponentKindVT">
              <On Select="TValueType.Specified, TValueType.SpecifiedByTemplate">
                <Exit Condition="ComponentKind &lt;&gt; ComponentSpec.ComponentKind"/>
              </On>
              <Otherwise>
                <Exit/>
              </Otherwise>
            </Case>
          </On>
          <On Select="TValueType.Error, TValueType.ErrorByTemplate">
            <Exit/>
          </On>
        </Case>
        <Case Expression="PartNumberVT">
          <On Select="TValueType.Specified, TValueType.SpecifiedByTemplate">
            <Case Expression="ComponentSpec.PartNumberVT">
              <On Select="TValueType.Specified, TValueType.SpecifiedByTemplate">
                <Exit Condition="not SameText(PartNumber, ComponentSpec.PartNumber)"/>
              </On>
              <Otherwise>
                <Exit/>
              </Otherwise>
            </Case>
          </On>
          <On Select="TValueType.Error, TValueType.ErrorByTemplate">
            <Exit/>
          </On>
        </Case>
        <Case Expression="ManufacturerVT">
          <On Select="TValueType.Specified, TValueType.SpecifiedByTemplate">
            <Case Expression="ComponentSpec.ManufacturerVT">
              <On Select="TValueType.Specified, TValueType.SpecifiedByTemplate">
                <Exit Condition="not SameText(Manufacturer, ComponentSpec.Manufacturer)"/>
              </On>
              <Otherwise>
                <Exit/>
              </Otherwise>
            </Case>
          </On>
          <On Select="TValueType.Error, TValueType.ErrorByTemplate">
            <Exit/>
          </On>
        </Case>
        <Block Condition="not SkipFootprintMatching">
          <Case Expression="FootprintVT">
            <On Select="TValueType.Specified, TValueType.SpecifiedByTemplate">
              <Case Expression="ComponentSpec.FootprintVT">
                <On Select="TValueType.Specified, TValueType.SpecifiedByTemplate">
                  <Exit Condition="Footprint &lt;&gt; ComponentSpec.Footprint"/>
                </On>
                <On Select="TValueType.SpecifiedEx, TValueType.SpecifiedExByTemplate">
                  <Exit Condition="not ComponentSpec.FootprintMask.Matches(Footprint)"/>
                </On>
                <On Select="TValueType.Unspecified, TValueType.Cleared, TValueType.ClearedByTemplate">
                </On>
                <Otherwise>
                  <Exit/>
                </Otherwise>
              </Case>
            </On>
            <On Select="TValueType.Error, TValueType.ErrorByTemplate">
              <Exit/>
            </On>
          </Case>
        </Block>
        <Execute Statement="Result:= True"/>
      </Block>
    </Function>

    <Procedure Identifier="TComponentSpec.GetSpecificationValues">
      <Parameters>
        <Parameter Identifier="FormatType" Type="TSpecFormatType"/>
        <Parameter Identifier="Footprint" Type="string" Direction="Output"/>
        <Parameter Identifier="PartNumberModel" Type="string" Direction="Output"/>
        <Parameter Identifier="InternalPartNumber" Type="string" Direction="Output"/>
        <Parameter Identifier="ComponentKind" Type="string" Direction="Output"/>
      </Parameters>
      <Variables>
        <Variable Identifier="locPartNumberModel" Type="string" Init="''"/>
      </Variables>
      <Block>
        <Case Expression="ManufacturerVT">
          <On Select="TValueType.Specified, TValueType.SpecifiedByTemplate">
            <Execute Statement="locPartNumberModel:= Self.Manufacturer"/>
          </On>
        </Case>
        <Case Expression="PartNumberVT">
          <On Select="TValueType.Specified, TValueType.SpecifiedByTemplate">
            <Execute Statement="locPartNumberModel:= ConcatExt(' ', True, locPartNumberModel, Self.PartNumber)"/>
          </On>
        </Case>
        <Execute Statement="PartNumberModel:= locPartNumberModel"/>
        <Execute Statement="Footprint:= ''"/>
        <Block Condition="not HideFootprint">
          <Case Expression="FootPrintVT">
            <!--<On Select="TValueType.Unspecified, TValueType.Cleared, TValueType.ClearedByTemplate">
            </On>-->
            <On Select="TValueType.Specified, TValueType.SpecifiedByTemplate">
              <Execute Statement="Footprint:= Self.Footprint"/>
            </On>
            <On Select="TValueType.SpecifiedExByTemplate, TValueType.SpecifiedEx">
              <Execute Statement="Footprint:= Self.FootprintMask.Mask"/>
            </On>
            <On Select="TValueType.Error, TValueType.ErrorByTemplate">
              <Execute Statement="Footprint:= '!' + ErrorFootprint + '!'"/>
            </On>
          </Case>
        </Block>
        <Case Expression="InternalPartNumberVT">
          <On Select="TValueType.Unspecified, TValueType.Cleared, TValueType.ClearedByTemplate">
            <Execute Statement="InternalPartNumber:= ''"/>
          </On>
          <On Select="TValueType.Specified, TValueType.SpecifiedByTemplate">
            <Execute Statement="InternalPartNumber:= '&quot;' + Self.InternalPartNumber + '&quot;'"/>
          </On>
        </Case>
        <Case Expression="ComponentKindVT">
          <On Select="TValueType.Unspecified, TValueType.Cleared, TValueType.ClearedByTemplate">
            <Execute Statement="ComponentKind:= ''"/>
          </On>
          <On Select="TValueType.Specified, TValueType.SpecifiedByTemplate">
            <Execute Statement="ComponentKind:= ComponentKindDescription(Self.ComponentKind)"/>
          </On>
          <On Select="TValueType.Error, TValueType.ErrorByTemplate">
            <Execute Statement="ComponentKind:= '!' + ErrorComponentKind + '!'"/>
          </On>
        </Case>
      </Block>
    </Procedure>

    <Function Identifier="TComponentSpec.SpecificationAsString" VirtualMethod="vmSpecificationAsString" Type="string">
      <Parameters>
        <Parameter Identifier="FormatType" Type="TSpecFormatType"/>
        <Parameter Identifier="ReportContext" Type="TSpecReportContext"/>
      </Parameters>
      <Variables>
        <Variable Identifier="Footprint" Type="string"/>
        <Variable Identifier="PartNumberModel" Type="string"/>
        <Variable Identifier="InternalPartNumber" Type="string"/>
        <Variable Identifier="ComponentKind" Type="string"/>
      </Variables>
      <Block>
        <Execute Statement="GetSpecificationValues(FormatType, Footprint, PartNumberModel, InternalPartNumber, ComponentKind)"/>
        <Case Expression="FormatType" Optimalisation="integermapping">
          <On Select="TSpecFormatType.Fixed">
            <Variable Identifier="ColumnManager" Type="TTextColumnManager" Init="ReportContext.ColumnManager"/>
            <Variable Identifier="ColumnOffset" Type="Integer" Init="ReportContext.ColumnOffset"/>
            <Execute Statement="Footprint:= Footprint + ' '" Condition="IsNonEmptyString(Footprint)"/>
            <Execute Statement="PartNumberModel:= PartNumberModel + ' '" Condition="IsNonEmptyString(PartNumberModel)"/>
            <Execute Statement="InternalPartNumber:= InternalPartNumber + ' '" Condition="IsNonEmptyString(InternalPartNumber)"/>
            <Choose>
              <When Expression="ReportContext.Measure">
                <Execute Statement="ColumnManager.RequestColumnWidth(ColumnOffset + TNamedComponentSpecColumns.FootPrint, 1, Length(FootPrint))"/>
                <Execute Statement="ColumnManager.RequestColumnWidth(ColumnOffset + TNamedComponentSpecColumns.PartNumberModel, 1, Length(PartNumberModel))"/>
                <Execute Statement="ColumnManager.RequestColumnWidth(ColumnOffset + TNamedComponentSpecColumns.InternalPartNumber, 1, Length(InternalPartNumber))"/>
                <Execute Statement="Result:= ''"/>
              </When>
              <Otherwise>
                <Execute Statement="Result:= Format('%*s%*s%*s',
                         ColumnManager.GetColumnWidth(ColumnOffset + TNamedComponentSpecColumns.Value, 6), '',
                         ColumnManager.GetColumnWidth(ColumnOffset + TNamedComponentSpecColumns.FootPrint, 1), FootPrint,
                         ColumnManager.GetColumnWidth(ColumnOffset + TNamedComponentSpecColumns.PartNumberModel, 1), PartNumberModel,
                         ColumnManager.GetColumnWidth(ColumnOffset + TNamedComponentSpecColumns.InternalPartNumber, 1), InternalPartNumber
                         )"/>
              </Otherwise>
            </Choose>
          </On>
          <On Select="TSpecFormatType.Description">
            <Execute Statement="Result:= ConcatExt(' ', True, PartNumberModel, InternalPartNumber, ComponentKind)"/>
          </On>
          <On Select="TSpecFormatType.Name">
            <Execute Statement="Result:= PartNumberModel"/>
          </On>
        </Case>
      </Block>
    </Function>

    <Procedure Identifier="TComponentSpec.HandleLibSource" VirtualMethod="vmHandleLibSource">
      <Parameters>
        <Parameter Identifier="LibAttrib" Type="IXMLDomAttribute"/>
        <Parameter Identifier="PartAttrib" Type="IXMLDomAttribute"/>
        <Parameter Identifier="DescriptionAttrib" Type="IXMLDomAttribute"/>
      </Parameters>
      <Variables>
        <Variable Identifier="LocComponentKind" Type="TComponentKind" Init="TComponentKind.Component"/>
        <Variable Identifier="Found" Type="Boolean"/>
        <Variable Identifier="QualifiedSymbolName" Type="string"/>
      </Variables>
      <Block>
        <Exit Condition="ComponentKindVT = TValueType.Specified"/>
        <Execute Statement="QualifiedSymbolName:= LibAttrib.Text + ':' + PartAttrib.Text"/>
        <inx:Index.FindValue Index="SymbolComponentKindIndex" Key="QualifiedSymbolName" Value="LocComponentKind" Found="Found" Flags="NoErrorOnNotFound" />
        <inx:Index.FindValue Index="SymbolComponentKindIndex" Key="LibAttrib.Text + ':'" Value="LocComponentKind" Found="Found" Flags="NoErrorOnNotFound" Condition="not Found" />
        <Block Condition="not Found">
          <rep:Reporter.Information Text="Format(sMsgMissingLibrarysymbolMapping, QualifiedSymbolName)" Target="Info" Markup="Comment"/>
          <inx:Index.MapValue Index="SymbolComponentKindIndex" Key="QualifiedSymbolName" Value="LocComponentKind" Flags="NoErrorOnExist DiscardOnExist"/>
        </Block>
        <Execute Statement="ComponentKind:= LocComponentKind"/>
        <Execute Statement="ComponentKindVT:= TValueType.Specified"/>
      </Block>
    </Procedure>

    <Procedure Identifier="TComponentSpec.HandleField" VirtualMethod="vmHandleField">
      <Parameters>
        <Parameter Identifier="CustomField" Type="TCustomField"/>
        <Parameter Identifier="Name" Type="string"/>
        <Parameter Identifier="Value" Type="string"/>
        <Parameter Identifier="Clear" Type="Boolean"/>
      </Parameters>
      <Variables>
        <Variable Identifier="locComponentKind" Type="TComponentKind"/>
        <Variable Identifier="Found" Type="Boolean"/>
      </Variables>
      <Block>
        <Case Expression="CustomField" Optimalisation="integermapping">
          <On Select="TCustomField.ComponentKind">
            <Execute Statement="Found:= ComponentKindNameRegister.GetItem(Value, locComponentKind)"/>
            <Choose>
              <When Expression="Found">
                <Execute Statement="ComponentKindVT:= TValueType.Specified"/>
                <Execute Statement="ComponentKind:= locComponentKind"/>
              </When>
              <Otherwise>
                <rep:Reporter.Error Text="Format('ComponentKind could not be matched: %s', Value)" Target="Info"/>
                <Execute Statement="ComponentKindVT:= TValueType.Error"/>
                <Execute Statement="ErrorComponentKind:= Value"/>
              </Otherwise>
            </Choose>
          </On>
          <On Select="TCustomField.Footprint">
            <Choose>
              <When Expression="Clear">
                <Execute Statement="FootprintVT:= TValueType.Cleared"/>
                <Execute Statement="Self.Footprint:= ''"/>
              </When>
              <Otherwise>
                <Execute Statement="Self.Footprint:= Value"/>
                <Execute Statement="FootprintVT:= TValueType.Specified"/>
              </Otherwise>
            </Choose>
          </On>
          <On Select="TCustomField.FootprintMask">
            <Choose>
              <When Expression="Clear">
                <Execute Statement="FootprintVT:= TValueType.Cleared"/>
              </When>
              <Otherwise>
                <Execute Statement="FootprintMask:= MaskManager.NewObject(Value)"/>
                <Execute Statement="FootprintVT:= TValueType.SpecifiedEx"/>
              </Otherwise>
            </Choose>
          </On>
          <On Select="TCustomField.PartNumber">
            <Choose>
              <When Expression="Clear">
                <Execute Statement="PartNumberVT:= TValueType.Cleared"/>
                <Execute Statement="PartNumber:= ''"/>
              </When>
              <Otherwise>
                <Execute Statement="PartNumber:= Value"/>
                <Execute Statement="PartNumberVT:= TValueType.Specified"/>
              </Otherwise>
            </Choose>
          </On>
          <On Select="TCustomField.Manufacturer">
            <Choose>
              <When Expression="Clear">
                <Execute Statement="ManufacturerVT:= TValueType.Cleared"/>
                <Execute Statement="Manufacturer:= ''"/>
              </When>
              <Otherwise>
                <Execute Statement="Manufacturer:= Value"/>
                <Execute Statement="ManufacturerVT:= TValueType.Specified"/>
              </Otherwise>
            </Choose>
          </On>
          <On Select="TCustomField.InternalPartNumber">
            <Choose>
              <When Expression="Clear">
                <Execute Statement="InternalPartNumberVT:= TValueType.Cleared"/>
                <Execute Statement="InternalPartNumber:= ''"/>
              </When>
              <Otherwise>
                <Execute Statement="InternalPartNumber:= Value"/>
                <Execute Statement="InternalPartNumberVT:= TValueType.Specified"/>
              </Otherwise>
            </Choose>
          </On>
        </Case>
      </Block>
    </Procedure>

    <ProcedureHeader Identifier="TComponentSpec.ApplyTemplate" VirtualMethod="vmApplyTemplate">
    </ProcedureHeader>
    <Implementation Identifier="TComponentSpec.ApplyTemplate">
      <Variables>
        <Variable Identifier="locTemplate" Type="TComponentSpec" Init="Template"/>
      </Variables>
      <Block>
        <Exit Condition="not Assigned(locTemplate)"/>
        <Execute Statement="locTemplate.ApplyTemplate"/>
        <Case Expression="ComponentKindVT" Optimalisation="integermapping">
          <On Select="TValueType.Unspecified, TValueType.ClearedByTemplate, TValueType.SpecifiedByTemplate, TValueType.ErrorByTemplate">
            <Case Expression="locTemplate.ComponentKindVT" Optimalisation="integermapping">
              <On Select="TValueType.Specified, TValueType.SpecifiedByTemplate">
                <Execute Statement="ComponentKind:= locTemplate.ComponentKind"/>
                <Execute Statement="ComponentKindVT:= TValueType.SpecifiedByTemplate"/>
              </On>
              <On Select="TValueType.Error, TValueType.ErrorByTemplate">
                <Execute Statement="ComponentKindVT:= TValueType.ErrorByTemplate"/>
              </On>
            </Case>
          </On>
        </Case>
        <Case Expression="PartNumberVT" Optimalisation="integermapping">
          <On Select="TValueType.Unspecified, TValueType.ClearedByTemplate, TValueType.SpecifiedByTemplate, TValueType.ErrorByTemplate">
            <Case Expression="locTemplate.PartNumberVT" Optimalisation="integermapping">
              <On Select="TValueType.Specified, TValueType.SpecifiedByTemplate">
                <Execute Statement="PartNumber:= locTemplate.PartNumber"/>
                <Execute Statement="PartNumberVT:= TValueType.SpecifiedByTemplate"/>
              </On>
              <On Select="TValueType.Error, TValueType.ErrorByTemplate">
                <Execute Statement="PartNumberVT:= TValueType.ErrorByTemplate"/>
              </On>
            </Case>
          </On>
        </Case>
        <Case Expression="ManufacturerVT" Optimalisation="integermapping">
          <On Select="TValueType.Unspecified, TValueType.ClearedByTemplate, TValueType.SpecifiedByTemplate, TValueType.ErrorByTemplate">
            <Case Expression="locTemplate.ManufacturerVT" Optimalisation="integermapping">
              <On Select="TValueType.Specified, TValueType.SpecifiedByTemplate">
                <Execute Statement="Manufacturer:= locTemplate.Manufacturer"/>
                <Execute Statement="ManufacturerVT:= TValueType.SpecifiedByTemplate"/>
              </On>
              <On Select="TValueType.Error, TValueType.ErrorByTemplate">
                <Execute Statement="ManufacturerVT:= TValueType.ErrorByTemplate"/>
              </On>
            </Case>
          </On>
        </Case>
        <Case Expression="FootprintVT" Optimalisation="integermapping">
          <On Select="TValueType.Unspecified, TValueType.ClearedByTemplate, TValueType.SpecifiedByTemplate, TValueType.ErrorByTemplate">
            <Case Expression="locTemplate.FootprintVT" Optimalisation="integermapping">
              <On Select="TValueType.Specified, TValueType.SpecifiedByTemplate">
                <Execute Statement="Footprint:= locTemplate.Footprint"/>
                <Execute Statement="FootprintVT:= TValueType.SpecifiedByTemplate"/>
              </On>
              <On Select="TValueType.SpecifiedEx, TValueType.SpecifiedExByTemplate">
                <Execute Statement="FootprintMask:= locTemplate.FootprintMask"/>
                <Execute Statement="FootprintVT:= TValueType.SpecifiedExByTemplate"/>
              </On>
              <On Select="TValueType.Error, TValueType.ErrorByTemplate">
                <Execute Statement="FootprintVT:= TValueType.ErrorByTemplate"/>
              </On>
            </Case>
          </On>
        </Case>
        <Execute Statement="Template:= ObjNil"/>
      </Block>
    </Implementation>

    <Procedure Identifier="TComponentSpec.LoadFromIniFileSection">
      <Parameters>
        <Parameter Identifier="Ini" Type="TScienceIniHelper"/>
        <Parameter Identifier="Section" Type="string"/>
      </Parameters>
      <Variables>
        <Variable Identifier="NameS" Type="string"/>
        <Variable Identifier="ValueS" Type="string"/>
        <Variable Identifier="Found" Type="Boolean"/>
        <Variable Identifier="CustomField" Type="TCustomField"/>
      </Variables>
      <Block>
        <Object.Use Identifier="KeyValueList" Type="TStringList" Expression="TStringList.Create">
          <Execute Statement="Ini.Section(Section)"/>
          <Execute Statement="Ini.Inifile.ReadSectionValues(Section, KeyValueList)"/>
          <ForLoop Indexer="I" From="0" To="KeyValueList.Count - 1">
            <Execute Statement="NameS:= KeyValueList.Names[I]"/>
            <Execute Statement="ValueS:= Ini.ReadString(NameS, '')"/>
            <Execute Statement="CustomField:= TCustomField.Unknown" Condition="not CustomFieldNameRegister.GetItem(NameS, CustomField)"/>
            <Execute Statement="HandleField(CustomField, NameS, ValueS, ValueS='-')" />
          </ForLoop>
        </Object.Use>
      </Block>
    </Procedure>

    <Procedure Identifier="TComponentSpec.LoadFromXML">
      <Parameters>
        <Parameter Identifier="Element" Type="IXMLDOMElement"/>
      </Parameters>
      <Type>
        <Enumeration Identifier="TValueState" Elements="None, HasValue, Handled"/>
      </Type>
      <Variables>
        <Variable Identifier="CustomField" Type="TCustomField"/>
        <Variable Identifier="NameS" Type="string"/>
        <Variable Identifier="ValueS" Type="string"/>
        <Variable Identifier="Found" Type="Boolean"/>
      </Variables>
      <Block>
        <msx:Node.IterateChilds Node="Element">
          <msx:OnElement baseName="'value'">
            <msx:Block>
              <Execute Statement="HandleField(TCustomField.Value, 'Value', Node.Text, Node.Text='-')"/>
            </msx:Block>
          </msx:OnElement>
          <msx:OnElement baseName="'footprint'">
            <msx:Block>
              <Execute Statement="HandleField(TCustomField.Footprint, 'Footprint', Node.Text, Node.Text='')"/>
            </msx:Block>
          </msx:OnElement>
          <msx:OnElement baseName="'fields'">
            <msx:Block>
              <msx:Node.IterateChilds Node="Node">
                <msx:OnElement baseName="'field'">
                  <msx:Attribute baseName="'name'"/>
                  <msx:Block>
                    <Execute Statement="NameS:= Name.Text"/>
                    <Execute Statement="ValueS:= Node.Text"/>
                    <Execute Statement="CustomField:= TCustomField.Unknown" Condition="not CustomFieldNameRegister.GetItem(NameS, CustomField)"/>
                    <Execute Statement="HandleField(CustomField, NameS, ValueS, ValueS='-')" />
                  </msx:Block>
                </msx:OnElement>
              </msx:Node.IterateChilds>
            </msx:Block>
          </msx:OnElement>
          <msx:OnElement baseName="'libsource'">
            <msx:Attribute baseName="'lib'"/>
            <msx:Attribute baseName="'part'"/>
            <msx:Attribute baseName="'description'"/>
            <msx:Block>
              <Execute Statement="HandleLibSource(lib, part, description)"/>
            </msx:Block>
          </msx:OnElement>
          <msx:OnOtherElement>
          </msx:OnOtherElement>
        </msx:Node.IterateChilds>
      </Block>
    </Procedure>
    
    <Function Identifier="TPassiveSpec.GetValue" VirtualMethod="vmGetValue" Type="Boolean">
      <Parameters>
        <Parameter Identifier="Value" Type="DecimalQuantity" Direction="Output"/>
      </Parameters>
      <Block>
        <Execute Statement="Result:= False"/>
      </Block>
    </Function>

    <Procedure Identifier="TPassiveSpec.SetValue" VirtualMethod="vmSetValue">
      <Parameters>
        <Parameter Identifier="Value" Type="DecimalQuantity"/>
      </Parameters>
      <Block>
      </Block>
    </Procedure>

    <Function Identifier="TComponentCategory.CreateSpecification" VirtualMethod="vmCreateSpecification" Type="TComponentSpec">
      <Block>
        <Execute Statement="Result:= TComponentSpec.Create"/>
      </Block>
    </Function>

    <Function Identifier="TComponentCategory.IsValidSpecification" VirtualMethod="vmIsValidSpecification" Type="Boolean">
      <Parameters>
        <Parameter Identifier="ComponentSpec" Type="TComponentSpec"/>
      </Parameters>
      <Block>
        <Execute Statement="Result:= True"/>
      </Block>
    </Function>

    <Function Identifier="TComponentCategory.IndexSearchSpecifications" VirtualMethod="vmIndexSearchSpecifications" Type="Boolean">
      <Parameters>
        <Parameter Identifier="ComponentSpec" Type="TComponentSpec"/>
        <Parameter Identifier="Specifications" Type="TSpecificationLink" Direction="Output"/>
      </Parameters>
      <Block>
        <Execute Statement="Result:= False"/>
      </Block>
    </Function>

    <Function Identifier="TComponentCategory.GetTemplate" VirtualMethod="vmGetTemplate" Type="TComponentSpec">
      <Parameters>
        <Parameter Identifier="Specification" Type="TComponentSpec"/>
      </Parameters>
      <Block>
        <Execute Statement="Result:= ObjNil"/>
      </Block>
    </Function>

    <Function Identifier="TComponentCategory.CompareSpecifications" Type="Integer" VirtualMethod="vmCompareSpecifications">
      <Parameters>
        <Parameter Identifier="A" Type="TComponentSpec"/>
        <Parameter Identifier="B" Type="TComponentSpec"/>
      </Parameters>
      <Block>
        <Execute Statement="Result:= A.ComponentKind - B.ComponentKind"/>
        <Exit Condition="Result &lt;&gt; 0"/>
        <Execute Statement="Result:= CompareStateStringValue(A.ID, A.InternalPartNumber, A.InternalPartNumberVT, B.ID, B.InternalPartNumber, B.InternalPartNumberVT)"/>
        <Exit Condition="Result &lt;&gt; 0"/>
        <Execute Statement="Result:= CompareStateStringValue(A.ID, A.PartNumber, A.PartNumberVT, B.ID, B.PartNumber, B.PartNumberVT)"/>
        <Exit Condition="Result &lt;&gt; 0"/>
        <Execute Statement="Result:= CompareStateStringValue(A.ID, A.Manufacturer, A.ManufacturerVT, B.ID, B.Manufacturer, B.ManufacturerVT)"/>
        <Exit Condition="Result &lt;&gt; 0"/>
        <Block Condition="not (HideFootprint and SkipFootprintMatching)">
          <Case Expression="A.FootprintVT">
            <On Select="TValueType.Unspecified, TValueType.Cleared, TValueType.ClearedByTemplate">
              <Case Expression="B.FootprintVT">
                <On Select="TValueType.Error, TValueType.ErrorByTemplate">
                  <Exit Result="-1"/>
                </On>
                <On Select="TValueType.Specified, TValueType.SpecifiedByTemplate, TValueType.SpecifiedExByTemplate, TValueType.SpecifiedEx">
                  <Execute Statement="Result:= 1"/>
                </On>
              </Case>
            </On>
            <On Select="TValueType.Specified, TValueType.SpecifiedByTemplate">
              <Case Expression="B.FootprintVT">
                <On Select="TValueType.Unspecified, TValueType.Cleared, TValueType.ClearedByTemplate, TValueType.Error, TValueType.ErrorByTemplate, TValueType.SpecifiedExByTemplate, TValueType.SpecifiedEx">
                  <Execute Statement="Result:= -1"/>
                </On>
                <On Select="TValueType.Specified, TValueType.SpecifiedByTemplate">
                  <Execute Statement="Result:= AnsiCompareStr(A.Footprint, B.Footprint)"/>
                </On>
              </Case>
            </On>
            <On Select="TValueType.SpecifiedExByTemplate, TValueType.SpecifiedEx">
              <Case Expression="B.FootprintVT">
                <On Select="TValueType.Unspecified, TValueType.Cleared, TValueType.ClearedByTemplate, TValueType.Error, TValueType.ErrorByTemplate">
                  <Execute Statement="Result:= -1"/>
                </On>
                <On Select="TValueType.Specified, TValueType.SpecifiedByTemplate">
                  <Execute Statement="Result:= 1"/>
                </On>
                <On Select="TValueType.SpecifiedExByTemplate, TValueType.SpecifiedEx">
                  <Execute Statement="Result:= AnsiCompareStr(A.FootprintMask.Mask, B.FootprintMask.Mask)"/>
                </On>
              </Case>
            </On>
            <On Select="TValueType.Error, TValueType.ErrorByTemplate">
              <Case Expression="B.FootprintVT">
                <On Select="TValueType.Error, TValueType.ErrorByTemplate">
                  <Exit Result="-1" Condition="A.ID &lt; B.ID"/>
                </On>
                <Otherwise>
                  <Execute Statement="Result:= 1"/>
                </Otherwise>
              </Case>
            </On>
          </Case>
        </Block>
      </Block>
    </Function>

    <Procedure Identifier="TComponentCategory.ReportComponentHeader" VirtualMethod="vmReportComponentHeader">
      <Parameters>
        <Parameter Identifier="ComponentKind" Type="TComponentKind"/>
      </Parameters>
      <Block>
        <rep:Reporter.Information Text="ComponentKindHeader(ComponentKind)" Markup="Header2"/>
      </Block>
    </Procedure>

    <Function Identifier="CompareComponent" Type="Integer">
      <Parameters>
        <Parameter Identifier="A" Type="TSchemaComponent"/>
        <Parameter Identifier="B" Type="TSchemaComponent"/>
      </Parameters>
      <Block>
        <Execute Statement="Result:= 0"/>
        <Choose>
          <When Expression="A.Decoded and B.Decoded">
            <!--<rep:Reporter.Information Text="Format('%s vs %s', A.Prefix, B.Prefix)"/>-->
            <Execute Statement="Result:= CompareText(A.Prefix, B.Prefix)"/>
            <!--<rep:Reporter.Information Text="Format('%d vs %d', A.Counter, B.Counter)"/>-->
            <Exit Condition="Result &lt;&gt; 0"/>
            <Choose>
              <When Expression="A.Counter &lt; B.Counter">
                <Execute Statement="Result:= -1"/>
              </When>
              <When Expression="A.Counter &gt; B.Counter">
                <Execute Statement="Result:= 1"/>
              </When>
            </Choose>
          </When>
          <When Expression="not A.Decoded and not B.Decoded">
            <Execute Statement="Result:= CompareText(A.Reference, B.Reference)"/>
          </When>
          <When Expression="not A.Decoded">
            <Execute Statement="Result:= CompareText(A.Reference, B.Prefix)"/>
            <Execute Statement="Result:= -1" Condition="Result = 0"/>
          </When>
          <When Expression="not B.Decoded">
            <Execute Statement="Result:= CompareText(A.Prefix, B.Reference)"/>
            <Execute Statement="Result:= 1" Condition="Result = 0"/>
          </When>
        </Choose>
      </Block>
    </Function>

    <Procedure Identifier="TComponentCategory.LoadTemplatesFromIniFile" VirtualMethod="vmLoadTemplatesFromIniFile">
      <Parameters>
        <Parameter Identifier="Ini" Type="TScienceIniHelper"/>
      </Parameters>
      <Block>
      </Block>
    </Procedure>

    <Function Identifier="TComponentCategory.CanExtractTemplateFromIniFile" VirtualMethod="vmCanExtractTemplateFromIniFile" Type="Boolean">
      <Parameters>
        <Parameter Identifier="Ini" Type="TScienceIniHelper"/>
        <Parameter Identifier="ComponentSpec" Type="TComponentSpec" Direction="Output"/>
      </Parameters>
      <Block>
        <Execute Statement="Result:= False"/>
      </Block>
    </Function>

    <Procedure Identifier="TComponentCategory.ReportStockComponents">
      <Parameters>
        <Parameter Identifier="Spec" Type="TComponentSpec"/>
        <Parameter Identifier="StockContext" Type="TStockReportContext"/>
      </Parameters>
      <Variables>
        <Variable Identifier="SpecAsString" Type="string"/>
        <Variable Identifier="TotCount" Type="Integer" Init="0"/>
        <Variable Identifier="StockDescriptions" Type="string" Init="''"/>
        <Variable Identifier="DoSeperate" Type="Boolean" Init="False"/>
      </Variables>
      <Block>
        <Execute Statement="SpecAsString:= Spec.SpecificationAsString(TSpecFormatType.Fixed, StockContext.SpecContext)"/>
        <Exit Condition="StockContext.Measure" />
        <lil:LinkedList.Iterate Head="Spec.StockComponentHead" ItemType="TStockComponent" RunningItem="RunningComponent" Next="RunningComponent.Next">
          <Execute Statement="StockDescriptions:= StockDescriptions + ', '" Condition="DoSeperate"/>
          <Execute Statement="StockDescriptions:= StockDescriptions + Format('%dx #%d @%s', RunningComponent.Amount, RunningComponent.ID, RunningComponent.Location.Name)"/>
          <Execute Statement="TotCount:= TotCount + RunningComponent.Amount"/>
          <Execute Statement="RunningComponent:= RunningComponent.Next"/>
          <Execute Statement="DoSeperate:= True"/>
        </lil:LinkedList.Iterate>
        <rep:Reporter.Information Text="Format('%3dx %-*s(%s)', TotCount, StockContext.SpecContext.ColumnManager.GetColumnWidth(1, TNamedComponentSpecColumns.Max + 1), SpecAsString, StockDescriptions)"/>
      </Block>
    </Procedure>

    <Procedure Identifier="TComponentCategory.ReportSchemaComponents">
      <Parameters>
        <Parameter Identifier="Spec" Type="TComponentSpec"/>
        <Parameter Identifier="BomCount" Type="Integer"/>
        <Parameter Identifier="SchemaContext" Type="TSchemaReportContext"/>
      </Parameters>
      <Block>
        <Variable Identifier="SpecAsString" Type="string" Init="Spec.SpecificationAsString(TSpecFormatType.Fixed, SchemaContext.SpecContext)"/>
        <Block Condition="not SchemaContext.Measure">
          <rep:Reporter.Information Text="Format('%3dx %-*s(%s)', Spec.SchemaUsageCount, SchemaContext.SpecContext.ColumnManager.GetColumnWidth(1, TNamedComponentSpecColumns.Max + 1), SpecAsString, Spec.ComponentDesignators)" Markup="Header4"/>
        </Block>
      </Block>
    </Procedure>

    <Procedure Identifier="TComponentCategory.ProcessDesignators">
      <Parameters>
        <Parameter Identifier="BomCount" Type="Integer"/>
      </Parameters>
      <Block>
        <lil:LinkedList.Iterate Head="ComponentSpecHead" ItemType="TComponentSpec" RunningItem="RunningSpec" Next="RunningSpec.Next">
          <Variable Identifier="LocSchemaComponentHead" Type="TSchemaComponent" Init="RunningSpec.SchemaComponentHead"/>
          <Variable Identifier="TotCount" Type="Integer" Init="0"/>
          <Variable Identifier="ComponentDesignators" Type="string" Init="''"/>
          <Variable Identifier="DoSeperate" Type="Boolean" Init="False"/>
          <lil:LinkedList.MergeSort Head="LocSchemaComponentHead" ItemType="TSchemaComponent" Next="Item.Next" LinkUp="ItemA.Next:= ItemB" IsInOrder="CompareComponent(ItemA, ItemB) &lt;= 0"/>
          <Execute Statement="RunningSpec.SchemaComponentHead:= LocSchemaComponentHead"/>
          <lil:LinkedList.Iterate Head="LocSchemaComponentHead" ItemType="TSchemaComponent" RunningItem="RunningComponent" Next="RunningComponent.Next">
            <Execute Statement="ComponentDesignators:= ComponentDesignators + ', '" Condition="DoSeperate"/>
            <Execute Statement="ComponentDesignators:= ComponentDesignators + RunningComponent.Reference"/>
            <Execute Statement="DoSeperate:= True"/>
            <Execute Statement="TotCount:= TotCount + BomCount"/>
          </lil:LinkedList.Iterate>
          <Execute Statement="RunningSpec.SchemaUsageCount:= TotCount"/>
          <Execute Statement="RunningSpec.ComponentDesignators:= ComponentDesignators"/>
        </lil:LinkedList.Iterate>
      </Block>
    </Procedure>

    <Procedure Identifier="TComponentCategory.ConsolidateSpecifications">
      <!--<Parameters>
        <Parameter Identifier="ConsolidateKind" Type="TComponentSpecConsolidateKind"/>
      </Parameters>-->
      <Variables>
        <Variable Identifier="RemoveSpec" Type="TComponentSpec"/>
        <Variable Identifier="PrevSpec" Type="TComponentSpec"/>
        <Variable Identifier="RunningSpec" Type="TComponentSpec" Init="ComponentSpecHead"/>
        <Variable Identifier="ComponentKind" Type="TComponentKind" Init="TComponentKind.None"/>
      </Variables>
      <Block>
        <Exit Condition="not Assigned(RunningSpec)"/>
        <lil:LinkedList.MergeSort Head="RunningSpec" ItemType="TComponentSpec" LinkUp="ItemA.Next:= ItemB" Next="Item.Next" IsInOrder="CompareSpecifications(ItemA, ItemB) &lt;= 0"/>
        <Execute Statement="ComponentSpecHead:= RunningSpec"/>
        <Execute Statement="PrevSpec:= RunningSpec"/>
        <Execute Statement="RunningSpec:= RunningSpec.Next"/>
        <WhileLoop Expression="Assigned(RunningSpec)">
          <ConditionalBlock Expression="CompareSpecifications(PrevSpec, RunningSpec) = 0">
            <Execute Statement="RemoveSpec:= RunningSpec"/>
            <Execute Statement="RunningSpec:= RunningSpec.Next"/>
            <Execute Statement="PrevSpec.Next:= RunningSpec"/>
            <Choose>
              <When Expression="Assigned(PrevSpec.SchemaComponentHead)">
                <Execute Statement="PrevSpec.SchemaComponentTail.Next:= RemoveSpec.SchemaComponentHead"/>
                <Execute Statement="PrevSpec.SchemaComponentTail:= RemoveSpec.SchemaComponentTail"/>
              </When>
              <Otherwise>
                <Execute Statement="PrevSpec.SchemaComponentHead:= RemoveSpec.SchemaComponentHead"/>
                <Execute Statement="PrevSpec.SchemaComponentTail:= RemoveSpec.SchemaComponentTail"/>
              </Otherwise>
            </Choose>
            <Choose>
              <When Expression="Assigned(PrevSpec.StockComponentHead)">
                <Execute Statement="PrevSpec.StockComponentTail.Next:= RemoveSpec.StockComponentHead"/>
                <Execute Statement="PrevSpec.StockComponentTail:= RemoveSpec.StockComponentTail"/>
              </When>
              <Otherwise>
                <Execute Statement="PrevSpec.StockComponentHead:= RemoveSpec.StockComponentHead"/>
                <Execute Statement="PrevSpec.StockComponentTail:= RemoveSpec.StockComponentTail"/>
              </Otherwise>
            </Choose>
            <Choose>
              <When Expression="Assigned(PrevSpec.MatchedSpecLinkHead)">
                <Execute Statement="PrevSpec.MatchedSpecLinkTail.Next:= RemoveSpec.MatchedSpecLinkHead"/>
                <Execute Statement="PrevSpec.MatchedSpecLinkTail:= RemoveSpec.MatchedSpecLinkTail"/>
              </When>
              <Otherwise>
                <Execute Statement="PrevSpec.MatchedSpecLinkHead:= RemoveSpec.MatchedSpecLinkHead"/>
                <Execute Statement="PrevSpec.MatchedSpecLinkTail:= RemoveSpec.MatchedSpecLinkTail"/>
              </Otherwise>
            </Choose>


            <Free Expression="RemoveSpec"/>
            <Continue/>
          </ConditionalBlock>
          <Execute Statement="PrevSpec:= RunningSpec"/>
          <Execute Statement="RunningSpec:= RunningSpec.Next"/>
        </WhileLoop>
      </Block>
    </Procedure>

    <Procedure Identifier="TComponentCategory.ReportSchema">
      <Parameters>
        <Parameter Identifier="BomCount" Type="Integer"/>
        <Parameter Identifier="SchemaContext" Type="TSchemaReportContext"/>
        <Parameter Identifier="StockContext" Type="TStockReportContext"/>
      </Parameters>
      <Variables>
        <Variable Identifier="ComponentKind" Type="TComponentKind" Init="TComponentKind.None"/>
      </Variables>
      <Block>
        <lil:LinkedList.Iterate Head="ComponentSpecHead" ItemType="TComponentSpec" RunningItem="RunningSpec" Next="RunningSpec.Next">
          <Choose>
            <When Expression="SchemaContext.Measure">
            </When>
            <When Expression="RunningSpec.ComponentKind &lt;&gt; ComponentKind">
              <rep:Reporter.Information Text="''"/>
              <Execute Statement="ComponentKind:= RunningSpec.ComponentKind"/>
              <Execute Statement="ReportComponentHeader(ComponentKind)"/>
            </When>
            <Otherwise>
              <rep:Reporter.Information Text="''" Condition="SeperateComponents"/>
            </Otherwise>
          </Choose>
          <Execute Statement="ReportSchemaComponents(RunningSpec, BomCount, SchemaContext)"/>
          <lil:LinkedList.Iterate Head="RunningSpec.MatchedSpecLinkHead" ItemType="TSpecificationLink" RunningItem="RunningSpecLink" Next="RunningSpecLink.Next">
            <Execute Statement="ReportStockComponents(RunningSpecLink.StockComponentSpec, StockContext)"/>
          </lil:LinkedList.Iterate>
        </lil:LinkedList.Iterate>
      </Block>
    </Procedure>

    <Procedure Identifier="TComponentCategory.ReportStock">
      <Parameters>
        <Parameter Identifier="StockContext" Type="TStockReportContext"/>
      </Parameters>
      <Variables>
        <Variable Identifier="ComponentKind" Type="TComponentKind" Init="TComponentKind.None"/>
      </Variables>
      <Block>
        <lil:LinkedList.Iterate Head="ComponentSpecHead" ItemType="TComponentSpec" RunningItem="RunningSpec" Next="RunningSpec.Next">
          <Block Condition="not StockContext.Measure">
            <Block Condition="RunningSpec.ComponentKind &lt;&gt; ComponentKind">
              <rep:Reporter.Information Text="''"/>
              <Execute Statement="ComponentKind:= RunningSpec.ComponentKind"/>
              <Execute Statement="ReportComponentHeader(ComponentKind)"/>
            </Block>
          </Block>
          <Execute Statement="ReportStockComponents(RunningSpec, StockContext)"/>
        </lil:LinkedList.Iterate>
      </Block>
    </Procedure>

    <Procedure Identifier="TComponentCategory.AssignStockSpecsToSchemaSpec">
      <Parameters>
        <Parameter Identifier="SchemaSpec" Type="TComponentSpec"/>
      </Parameters>
      <Variables>
        <Variable Identifier="RunningSpec" Type="TComponentSpec" Init="ComponentSpecHead"/>
        <Variable Identifier="MatchedSpecLink" Type="TSpecificationLink"/>
        <Variable Identifier="SearchSpecLink" Type="TSpecificationLink"/>
      </Variables>
      <Block>
        <Block Condition="IndexSearchSpecifications(SchemaSpec, SearchSpecLink)">
          <WhileLoop Expression="Assigned(SearchSpecLink)">
            <Block Condition="SchemaSpec.DoesMatchSpecification(SearchSpecLink.StockComponentSpec)">
              <Execute Statement="MatchedSpecLink:= TSpecificationLink.Create(SearchSpecLink.StockComponentSpec)"/>
              <Choose>
                <When Expression="Assigned(SchemaSpec.MatchedSpecLinkHead)">
                  <Execute Statement="SchemaSpec.MatchedSpecLinkTail.Next:= MatchedSpecLink"/>
                </When>
                <Otherwise>
                  <Execute Statement="SchemaSpec.MatchedSpecLinkHead:= MatchedSpecLink"/>
                </Otherwise>
              </Choose>
              <Execute Statement="SchemaSpec.MatchedSpecLinkTail:= MatchedSpecLink"/>
            </Block>
            <Execute Statement="SearchSpecLink:= SearchSpecLink.Next"/>
          </WhileLoop>
          <Exit/>
        </Block>

        <WhileLoop Expression="Assigned(RunningSpec)">
          <Block Condition="SchemaSpec.DoesMatchSpecification(RunningSpec)">
            <Execute Statement="MatchedSpecLink:= TSpecificationLink.Create(RunningSpec)"/>
            <Choose>
              <When Expression="Assigned(SchemaSpec.MatchedSpecLinkHead)">
                <Execute Statement="SchemaSpec.MatchedSpecLinkTail.Next:= MatchedSpecLink"/>
              </When>
              <Otherwise>
                <Execute Statement="SchemaSpec.MatchedSpecLinkHead:= MatchedSpecLink"/>
              </Otherwise>
            </Choose>
            <Execute Statement="SchemaSpec.MatchedSpecLinkTail:= MatchedSpecLink"/>
          </Block>
          <Execute Statement="RunningSpec:= RunningSpec.Next"/>
        </WhileLoop>
      </Block>
    </Procedure>

    <Procedure Identifier="TComponentCategory.AssignStockSpecsFromCategory">
      <Parameters>
        <Parameter Identifier="StockCategory" Type="TComponentCategory"/>
        <Parameter Identifier="InternalPartNumberIndex" Type="TMappingCaseInSensitiveUnicodeStringToObject"/>
      </Parameters>
      <Variables>
        <Variable Identifier="RunningSpec" Type="TComponentSpec" Init="ComponentSpecHead"/>
        <Variable Identifier="SearchSpecifications" Type="TSpecificationLinks"/>
        <Variable Identifier="Found" Type="Boolean"/>
      </Variables>
      <Block>
        <WhileLoop Expression="Assigned(RunningSpec)">
          <Case Expression="RunningSpec.InternalPartNumberVT">
            <On Select="TValueType.Specified, TValueType.SpecifiedByTemplate">
              <inx:Index.FindValue Index="InternalPartNumberIndex" Key="RunningSpec.InternalPartNumber" Flags="NoErrorOnNotFound" Found="Found" Value="SearchSpecifications" />
              <Execute Statement="RunningSpec.MatchedSpecLinkHead := SearchSpecifications.Head" Condition="Found"/>
            </On>
            <Otherwise>
              <Execute Statement="StockCategory.AssignStockSpecsToSchemaSpec(RunningSpec)"/>
            </Otherwise>
          </Case>
          <Execute Statement="RunningSpec:= RunningSpec.Next"/>
        </WhileLoop>
      </Block>
    </Procedure>

    <Procedure Identifier="TComponentCategory.AssignStockSpecsFromCategory">
      <Parameters>
        <Parameter Identifier="StockCategory" Type="TComponentCategory"/>
        <Parameter Identifier="InternalPartNumberIndex" Type="TMappingCaseInSensitiveUnicodeStringToObject"/>
        <Parameter Identifier="PickRequestList" Type="TObjectList"/>
        <Parameter Identifier="BomCount" Type="Integer"/>
      </Parameters>
      <Variables>
        <Variable Identifier="RunningSpec" Type="TComponentSpec" Init="ComponentSpecHead"/>
        <Variable Identifier="SearchSpecifications" Type="TSpecificationLinks"/>
        <Variable Identifier="Found" Type="Boolean"/>
        <Variable Identifier="RunningComponent" Type="TSchemaComponent"/>
        <Variable Identifier="StorageLocation" Type="TStorageLocation"/>
        <Variable Identifier="PickRequest" Type="TPickRequest"/>
        <Variable Identifier="TotCount" Type="Integer"/>
      </Variables>
      <Block>
        <WhileLoop Expression="Assigned(RunningSpec)">
          <Case Expression="RunningSpec.InternalPartNumberVT">
            <On Select="TValueType.Specified, TValueType.SpecifiedByTemplate">
              <inx:Index.FindValue Index="InternalPartNumberIndex" Key="RunningSpec.InternalPartNumber" Flags="NoErrorOnNotFound" Found="Found" Value="SearchSpecifications" />
              <Execute Statement="RunningSpec.MatchedSpecLinkHead := SearchSpecifications.Head" Condition="Found"/>
            </On>
            <Otherwise>
              <Execute Statement="StockCategory.AssignStockSpecsToSchemaSpec(RunningSpec)"/>
            </Otherwise>
          </Case>
          <Execute Statement="TotCount:= 0"/>
          <Execute Statement="PickRequest:= ObjNil"/>
          <lil:LinkedList.Iterate Head="RunningSpec.SchemaComponentHead" ItemType="TSchemaComponent" RunningItem="RunningComponent" Next="RunningComponent.Next">
            <Execute Statement="TotCount:= TotCount + BomCount"/>
          </lil:LinkedList.Iterate>
          <lil:LinkedList.Iterate Head="RunningSpec.MatchedSpecLinkHead" ItemType="TSpecificationLink" RunningItem="SpecLink" Next="SpecLink.Next">
            <lil:LinkedList.Iterate Head="SpecLink.StockComponentSpec.StockComponentHead" ItemType="TStockComponent" RunningItem="RunningComponent" Next="RunningComponent.Next">
              <Execute Statement="StorageLocation:= RunningComponent.Location"/>
              <Execute Statement="PickRequest:= TPickRequest.Create(RunningSpec, SpecLink.StockComponentSpec, RunningComponent)"/>
              <Execute Statement="PickRequestList.Add(PickRequest)"/>
              <Choose>
                <When Expression="Assigned(StorageLocation.FirstPickRequest)">
                  <Execute Statement="StorageLocation.LastPickRequest.Next:= PickRequest"/>
                </When>
                <Otherwise>
                  <Execute Statement="StorageLocation.FirstPickRequest:= PickRequest"/>
                </Otherwise>
              </Choose>
              <Execute Statement="StorageLocation.LastPickRequest:= PickRequest"/>
              <Execute Statement="RunningComponent:= RunningComponent.Next"/>
            </lil:LinkedList.Iterate>
          </lil:LinkedList.Iterate>
          <Block Condition="not Assigned(PickRequest)">
            <Execute Statement="PickRequest:= TPickRequest.Create(RunningSpec)"/>
            <Execute Statement="PickRequestList.Add(PickRequest)"/>
          </Block>
          <Execute Statement="RunningSpec:= RunningSpec.Next"/>
        </WhileLoop>
      </Block>
    </Procedure>

    <Procedure Identifier="TComponentCategory.Add">
      <Parameters>
        <Parameter Identifier="Specification" Type="TComponentSpec" />
      </Parameters>
      <Block>
        <Choose>
          <When Expression="Assigned(ComponentSpecHead)">
            <Execute Statement="ComponentSpecTail.Next:= Specification"/>
          </When>
          <Otherwise>
            <Execute Statement="ComponentSpecHead:= Specification"/>
          </Otherwise>
        </Choose>
        <Execute Statement="ComponentSpecTail:= Specification"/>
      </Block>
    </Procedure>

    <Function Identifier="TComponentCategory.ProcessSchemaXml" Type="Boolean">
      <Parameters>
        <Parameter Identifier="Element" Type="IXMLDomElement" />
        <Parameter Identifier="Reference" Type="string" />
        <Parameter Identifier="ID" Type="Integer" />
      </Parameters>
      <Variables>
        <Variable Identifier="Specification" Type="TComponentSpec"/>
        <Variable Identifier="Component" Type="TSchemaComponent"/>
      </Variables>
      <Block>
        <Execute Statement="Result:= False"/>
        <TryFinally>
          <Try>
            <Execute Statement="Specification:= CreateSpecification" />
            <Execute Statement="Specification.LoadFromXML(Element)" />
            <ConditionalBlock Expression="IsValidSpecification(Specification)">
              <Execute Statement="Result:= True"/>
              <Execute Statement="Component:= TSchemaComponent.Create(Reference)"/>
              <Execute Statement="Specification.ID:= ID"/>
              <Execute Statement="Specification.SchemaComponentHead:= Component"/>
              <Execute Statement="Specification.SchemaComponentTail:= Component"/>
              <Execute Statement="Specification.Template:= GetTemplate(Specification)"/>
              <Execute Statement="Specification.ApplyTemplate"/>
              <Execute Statement="Add(Specification)"/>
            </ConditionalBlock>
          </Try>
          <Finally>
            <Free Identifier="Specification" Condition="not Result"/>
          </Finally>
        </TryFinally>
      </Block>
    </Function>

    <Function Identifier="TComponentCategory.ProcessStockComponent" Type="Boolean">
      <Parameters>
        <Parameter Identifier="StockComponent" Type="TStockComponent"/>
        <Parameter Identifier="ValueHead" Type="TComponentValue"/>
        <Parameter Identifier="ID" Type="Integer" />
      </Parameters>
      <Variables>
        <Variable Identifier="Specification" Type="TComponentSpec"/>
        <Variable Identifier="CustomField" Type="TCustomField"/>
      </Variables>
      <Block>
        <Execute Statement="Result:= False"/>
        <TryFinally>
          <Try>
            <Execute Statement="Specification:= CreateSpecification" />
            <Execute Statement="Specification.Template:= StockComponent.StockCategory.ComponentSpec"/>
            <Execute Statement="Specification.HandleField(TCustomField.Value, '', StockComponent.Name, StockComponent.Name='-')"/>
            <Execute Statement="Specification.HandleField(TCustomField.InternalPartNumber, '', StockComponent.InternalPartNumber, StockComponent.InternalPartNumber='-')" Condition="IsNonEmptyString(StockComponent.InternalPartNumber)"/>
            <!--<Execute Statement="Specification.HandleField(TCustomField.Footprint, '', StockComponent.FootprintInfo.Name, False)" Condition="Assigned(StockComponent.FootprintInfo)"/>-->
            <lil:LinkedList.Iterate Head="ValueHead" ItemType="TComponentValue" RunningItem="RunningComponentValue" Next="RunningComponentValue.Next">
              <Execute Statement="CustomField:= TCustomField.Unknown" Condition="not CustomFieldNameRegister.GetItem(RunningComponentValue.Name, CustomField)"/>
              <!--<Execute Statement="CustomFieldNameRegister.GetItem(RunningComponentValue.Name, CustomField)"/>-->
              <Execute Statement="Specification.HandleField(CustomField, RunningComponentValue.Name, RunningComponentValue.Value, RunningComponentValue.Value='-')" />
            </lil:LinkedList.Iterate>

            <Execute Statement="Specification.ApplyTemplate"/>
            <ConditionalBlock Expression="IsValidSpecification(Specification)">
              <Execute Statement="Result:= True"/>
              <Execute Statement="Specification.ID:= ID"/>
              <Execute Statement="Specification.StockComponentHead:= StockComponent"/>
              <Execute Statement="Specification.StockComponentTail:= StockComponent"/>
              <Choose>
                <When Expression="Assigned(ComponentSpecHead)">
                  <Execute Statement="ComponentSpecTail.Next:= Specification"/>
                </When>
                <Otherwise>
                  <Execute Statement="ComponentSpecHead:= Specification"/>
                </Otherwise>
              </Choose>
              <Execute Statement="ComponentSpecTail:= Specification"/>
            </ConditionalBlock>
          </Try>
          <Finally>
            <Free Identifier="Specification" Condition="not Result"/>
          </Finally>
        </TryFinally>
      </Block>
    </Function>

    <Procedure Identifier="InitSymbolComponentKindIndex">
      <Parameters>
        <Parameter Identifier="Index" Type="TAbstractBoxedValueMappingHashIndex"/>
      </Parameters>
      <Block>
      </Block>
    </Procedure>

    <Procedure Identifier="LoadSymbolMappings">
      <Parameters>
        <Parameter Identifier="Directory" Type="string" />
      </Parameters>
      <Variables>
        <Variable Identifier="XmlDoc" Type="IXmlDomDocument"/>
        <Variable Identifier="Found" Type="Boolean"/>
        <Variable Identifier="ComponentKind" Type="TComponentKind"/>
        <Variable Identifier="PrevComponentKind" Type="TComponentKind"/>
        <Variable Identifier="LibName" Type="string"/>
        <Variable Identifier="LibPrefix" Type="string"/>
        <Variable Identifier="QualifiedSymbolName" Type="string"/>
      </Variables>
      <Block>
        <msx:Document.Create Identifier="XmlDoc"/>
        <syu:Directory.Iterate Directory="Directory" FileSpec="'*.xml'" FindObject="Info" Recursive="False">
          <syu:FileBlock>
            <rep:Reporter.Information Text="Info.FilePath" Target="Info" Markup="Comment"/>
            <sts:ShowStatus.Information Text="Format('Loading symbol mappings: &quot;%s&quot;', Info.FilePath)"/>
            <msx:Document.LoadFromFile Document="XmlDoc" Filename="Info.FilePath"/>
            <msx:Node.IterateChilds Node="XmlDoc.DocumentElement">
              <msx:OnElement baseName="'Library'">
                <msx:Attribute baseName="'Name'" Required="true"/>
                <msx:Attribute baseName="'Component'"/>
                <msx:Block>
                  <Execute Statement="LibName:= Name.Text"/>
                  <Execute Statement="LibPrefix:= LibName + ':'"/>
                  <Block Condition="Assigned(Component)">
                    <Execute Statement="Found:= ComponentKindNameRegister.GetItem(Component.Text, ComponentKind)"/>
                    <!--<inx:Index.FindValue Index="ComponentKindIndex" Key="Component.Text" Found="Found" Value="ComponentKind" Flags="NoErrorOnNotFound"/>-->
                    <Choose>
                      <When Expression="Found">
                        <inx:Index.MapValue Index="SymbolComponentKindIndex" Key="LibPrefix" Value="ComponentKind" Flags="NoErrorOnExist DiscardOnExist" Found="Found" PreviousValue="PrevComponentKind"/>
                        <Block Condition="Found">
                          <rep:Reporter.Error Target="Info" Text="Format(sMsgMappingExistingLibrary, LibName, ComponentKindName(ComponentKind), ComponentKindName(PrevComponentKind))"  Condition="PrevComponentKind &lt;&gt; ComponentKind"/>
                        </Block>
                      </When>
                      <Otherwise>
                        <rep:Reporter.Error Target="Info" Text="Format(sMsgMissingLibraryComponentKind, Component.Text, LibName)" />
                      </Otherwise>
                    </Choose>
                  </Block>
                  <msx:Node.IterateChilds Node="Node">
                    <msx:OnElement baseName="'Part'">
                      <msx:Attribute baseName="'Part'" Required="true"/>
                      <msx:Attribute baseName="'Component'" Required="true"/>
                      <msx:Block>
                        <Execute Statement="QualifiedSymbolName:= LibPrefix + Part.Text"/>
                        <Execute Statement="Found:= ComponentKindNameRegister.GetItem(Component.Text, ComponentKind)"/>
                        <!--<inx:Index.FindValue Index="ComponentKindIndex" Key="Component.Text" Found="Found" Value="ComponentKind" Flags="NoErrorOnNotFound"/>-->
                        <Choose>
                          <When Expression="Found">
                            <inx:Index.MapValue Index="SymbolComponentKindIndex" Key="QualifiedSymbolName" Value="ComponentKind" Flags="NoErrorOnExist DiscardOnExist" Found="Found" PreviousValue="PrevComponentKind"/>
                            <Block Condition="Found">
                              <rep:Reporter.Error Target="Info" Text="Format(sMsgMappingExistingSymbol, QualifiedSymbolName, ComponentKindName(ComponentKind), ComponentKindName(PrevComponentKind))"  Condition="PrevComponentKind &lt;&gt; ComponentKind"/>
                            </Block>
                          </When>
                          <Otherwise>
                            <rep:Reporter.Error Target="Info" Text="Format(sMsgMissingSymbolComponentKind, Component.Text, QualifiedSymbolName)" />
                          </Otherwise>
                        </Choose>
                      </msx:Block>
                    </msx:OnElement>
                  </msx:Node.IterateChilds>
                </msx:Block>
              </msx:OnElement>
            </msx:Node.IterateChilds>
          </syu:FileBlock>
        </syu:Directory.Iterate>
      </Block>
    </Procedure>

    <Function Identifier="TUnitConvertor.EStrToDecimalQuantity" Type="Boolean">
      <Parameters>
        <Parameter Identifier="TextValue" Type="string"/>
        <Parameter Identifier="IntValue" Type="DecimalQuantity" Direction="Output"/>
      </Parameters>
      <Variables>
        <Variable Identifier="Scale" Type="Integer" Init="0"/>
        <Variable Identifier="FracScale" Type="Integer" Init="0"/>
        <Variable Identifier="IsNegative" Type="Boolean" Init="False"/>
        <Variable Identifier="ValidEndState" Type="Boolean" Init="False"/>
      </Variables>
      <Block>
        <Execute Statement="Result:= False"/>
        <Object.Use Identifier="Digits" Type="TDigitList" Expression="TDigitList.Create">
          <stm:StateHandler InitialState="Start">
            <StringLoop StringValue="TextValue" OrdinalIdentifier="ChrI">
              <stm:HandleStates>
                <!--<-<TUnitConvertor.EStrToDecimalQuantity.StringLoop-->
                <stm:State Name="Start">
                  <Case Expression="ChrI" Optimalisation="integermapping" OrdinalType="widechar">
                    <On Select="cSpace, cTab">
                    </On>
                    <On Select="cNegative">
                      <Execute Statement="IsNegative:= True"/>
                      <stm:SetState Name="AfterSign"/>
                      <Execute Statement="ValidEndState:= False"/>
                    </On>
                    <On Select="cPositive">
                      <stm:SetState Name="AfterSign"/>
                      <Execute Statement="ValidEndState:= False"/>
                    </On>
                    <On Select="c0">
                      <Execute Statement="Digits.Add(0)" Condition="(Digits.Count &lt;&gt;0)"/>
                      <stm:SetState Name="InNum"/>
                      <Execute Statement="ValidEndState:= True"/>
                    </On>
                    <On Select="c1..c9">
                      <Execute Statement="Digits.Add(ChrI - CharOrd(c0))"/>
                      <stm:SetState Name="InNum"/>
                      <Execute Statement="ValidEndState:= True"/>
                    </On>
                    <Otherwise>
                      <Exit/>
                    </Otherwise>
                  </Case>
                </stm:State>
                <stm:State Name="AfterSign">
                  <Case Expression="ChrI" Optimalisation="integermapping" OrdinalType="widechar">
                    <On Select="c0">
                      <Execute Statement="Digits.Add(0)" Condition="(Digits.Count &lt;&gt;0)"/>
                      <stm:SetState Name="InNum"/>
                      <Execute Statement="ValidEndState:= True"/>
                    </On>
                    <On Select="c1..c9">
                      <Execute Statement="Digits.Add(ChrI - CharOrd(c0))"/>
                      <stm:SetState Name="InNum"/>
                      <Execute Statement="ValidEndState:= True"/>
                    </On>
                    <Otherwise>
                      <Exit/>
                    </Otherwise>
                  </Case>
                </stm:State>
                <stm:State Name="InNum">
                  <Case Expression="ChrI" Optimalisation="integermapping" OrdinalType="widechar">
                    <On Select="cSpace">
                      <stm:SetState Name="AfterNumSep"/>
                      <Execute Statement="ValidEndState:= True"/>
                    </On>
                    <On Select="cTab">
                      <stm:SetState Name="Final"/>
                      <Execute Statement="ValidEndState:= True"/>
                    </On>
                    <On Select="c0">
                      <Execute Statement="Digits.Add(0)" Condition="(Digits.Count &lt;&gt;0)"/>
                    </On>
                    <On Select="c1..c9">
                      <Execute Statement="Digits.Add(ChrI - CharOrd(c0))"/>
                    </On>
                    <On Select="cDecimalSep1, cDecimalSep2">
                      <stm:SetState Name="AfterDecimalChar"/>
                      <Execute Statement="ValidEndState:= True"/>
                    </On>
                    <On Select="cTera">
                      <Execute Statement="Scale:= cScaleTera"/>
                      <stm:SetState Name="AfterPrefixFracSep"/>
                      <Execute Statement="ValidEndState:= True"/>
                    </On>
                    <On Select="cGiga">
                      <Execute Statement="Scale:= cScaleGiga"/>
                      <stm:SetState Name="AfterPrefixFracSep"/>
                      <Execute Statement="ValidEndState:= True"/>
                    </On>
                    <On Select="cMega">
                      <Execute Statement="Scale:= cScaleMega"/>
                      <stm:SetState Name="AfterPrefixFracSep"/>
                      <Execute Statement="ValidEndState:= True"/>
                    </On>
                    <On Select="cKilo">
                      <Execute Statement="Scale:= cScaleKilo"/>
                      <stm:SetState Name="AfterPrefixFracSep"/>
                      <Execute Statement="ValidEndState:= True"/>
                    </On>
                    <On Select="cK">
                      <Exit Condition="SiUnit &lt;&gt; TSiUnit.Ohm"/>
                      <Execute Statement="Scale:= cScaleKilo"/>
                      <stm:SetState Name="AfterPrefixFracSep"/>
                      <Execute Statement="ValidEndState:= True"/>
                    </On>
                    <On Select="cR, cE">
                      <Exit Condition="SiUnit &lt;&gt; TSiUnit.Ohm"/>
                      <stm:SetState Name="AfterPrefixFracSep"/>
                      <Execute Statement="ValidEndState:= True"/>
                    </On>
                    <On Select="cMilliOrMeter">
                      <Choose>
                        <When Expression="SiUnit = TSiUnit.Meter">
                          <stm:SetState Name="AfterMilliOrMeter"/>
                          <Execute Statement="ValidEndState:= True"/>
                        </When>
                        <Otherwise>
                          <Execute Statement="Scale:= cScaleMilli"/>
                          <stm:SetState Name="AfterPrefixFracSep"/>
                          <Execute Statement="ValidEndState:= True"/>
                        </Otherwise>
                      </Choose>
                    </On>
                    <On Select="cMicro, cMicroAlt, cMicroAlt2">
                      <Execute Statement="Scale:= cScaleMicro"/>
                      <stm:SetState Name="AfterPrefixFracSep"/>
                      <Execute Statement="ValidEndState:= True"/>
                    </On>
                    <On Select="cNano">
                      <Execute Statement="Scale:= cScaleNano"/>
                      <stm:SetState Name="AfterPrefixFracSep"/>
                      <Execute Statement="ValidEndState:= True"/>
                    </On>
                    <On Select="cPico">
                      <Execute Statement="Scale:= cScalePico"/>
                      <stm:SetState Name="AfterPrefixFracSep"/>
                      <Execute Statement="ValidEndState:= True"/>
                    </On>
                    <On Select="cFemto">
                      <Execute Statement="Scale:= cScaleFemto"/>
                      <stm:SetState Name="AfterPrefixFracSep"/>
                      <Execute Statement="ValidEndState:= True"/>
                    </On>
                    <On Select="cOhm">
                      <Exit Condition="SiUnit &lt;&gt; TSiUnit.Ohm"/>
                      <stm:SetState Name="Final"/>
                      <Execute Statement="ValidEndState:= True"/>
                    </On>
                    <On Select="cWatt">
                      <Exit Condition="SiUnit &lt;&gt; TSiUnit.Watt"/>
                      <stm:SetState Name="Final"/>
                      <Execute Statement="ValidEndState:= True"/>
                    </On>
                    <On Select="cFarad">
                      <Exit Condition="SiUnit &lt;&gt; TSiUnit.Farad"/>
                      <stm:SetState Name="Final"/>
                      <Execute Statement="ValidEndState:= True"/>
                    </On>
                    <On Select="cVolt">
                      <Exit Condition="SiUnit &lt;&gt; TSiUnit.Volt"/>
                      <stm:SetState Name="AfterUnitFracSep"/>
                      <Execute Statement="ValidEndState:= True"/>
                    </On>
                    <On Select="cAmp">
                      <Exit Condition="SiUnit &lt;&gt; TSiUnit.Amp"/>
                      <stm:SetState Name="Final"/>
                      <Execute Statement="ValidEndState:= True"/>
                    </On>
                    <On Select="cPerc">
                      <Exit Condition="SiUnit &lt;&gt; TSiUnit.Perc"/>
                      <stm:SetState Name="Final"/>
                      <Execute Statement="ValidEndState:= True"/>
                    </On>
                    <On Select="cHenry_Hz">
                      <Case Expression="SiUnit">
                        <On Select="TSiUnit.Henry">
                          <stm:SetState Name="Final"/>
                          <Execute Statement="ValidEndState:= True"/>
                        </On>
                        <On Select="TSiUnit.Hz">
                          <stm:SetState Name="AfterFirstUnitChar"/>
                          <Execute Statement="ValidEndState:= False"/>
                        </On>
                        <Otherwise>
                          <Exit/>
                        </Otherwise>
                      </Case>
                    </On>
                    <On Select="cSecond">
                      <Exit Condition="SiUnit &lt;&gt; TSiUnit.Second"/>
                      <stm:SetState Name="Final"/>
                      <Execute Statement="ValidEndState:= True"/>
                    </On>
                    <Otherwise>
                      <Exit/>
                    </Otherwise>
                  </Case>
                </stm:State>
                <stm:State Name="AfterDecimalChar">
                  <Case Expression="ChrI" Optimalisation="integermapping" OrdinalType="widechar">
                    <On Select="c0">
                      <Execute Statement="FracScale:= FracScale - 1"/>
                      <Execute Statement="Digits.Add(0)" Condition="(Digits.Count &lt;&gt;0)"/>
                      <stm:SetState Name="InDecimalFrac"/>
                      <Execute Statement="ValidEndState:= True"/>
                    </On>
                    <On Select="c1..c9">
                      <Execute Statement="FracScale:= FracScale - 1"/>
                      <Execute Statement="Digits.Add(ChrI - CharOrd(c0))"/>
                      <stm:SetState Name="InDecimalFrac"/>
                      <Execute Statement="ValidEndState:= True"/>
                    </On>
                    <Otherwise>
                      <Exit/>
                    </Otherwise>
                  </Case>
                </stm:State>
                <stm:State Name="InDecimalFrac">
                  <Case Expression="ChrI" Optimalisation="integermapping" OrdinalType="widechar">
                    <On Select="cSpace">
                      <stm:SetState Name="AfterNumSep"/>
                      <Execute Statement="ValidEndState:= True"/>
                    </On>
                    <On Select="cTab">
                      <stm:SetState Name="Final"/>
                      <Execute Statement="ValidEndState:= True"/>
                    </On>
                    <On Select="c0">
                      <Execute Statement="FracScale:= FracScale - 1"/>
                      <Execute Statement="Digits.Add(0)" Condition="(Digits.Count &lt;&gt;0)"/>
                    </On>
                    <On Select="c1..c9">
                      <Execute Statement="FracScale:= FracScale - 1"/>
                      <Execute Statement="Digits.Add(ChrI - CharOrd(c0))"/>
                    </On>
                    <On Select="cTera">
                      <Execute Statement="Scale:= cScaleTera"/>
                      <stm:SetState Name="AfterPrefix"/>
                      <Execute Statement="ValidEndState:= True"/>
                    </On>
                    <On Select="cGiga">
                      <Execute Statement="Scale:= cScaleGiga"/>
                      <stm:SetState Name="AfterPrefix"/>
                      <Execute Statement="ValidEndState:= True"/>
                    </On>
                    <On Select="cMega">
                      <Execute Statement="Scale:= cScaleMega"/>
                      <stm:SetState Name="AfterPrefix"/>
                      <Execute Statement="ValidEndState:= True"/>
                    </On>
                    <On Select="cKilo">
                      <Execute Statement="Scale:= cScaleKilo"/>
                      <stm:SetState Name="AfterPrefix"/>
                      <Execute Statement="ValidEndState:= True"/>
                    </On>
                    <On Select="cK">
                      <Exit Condition="SiUnit &lt;&gt; TSiUnit.Ohm"/>
                      <Execute Statement="Scale:= cScaleKilo"/>
                      <stm:SetState Name="AfterPrefix"/>
                      <Execute Statement="ValidEndState:= True"/>
                    </On>
                    <On Select="cR, cE">
                      <Exit Condition="SiUnit &lt;&gt; TSiUnit.Ohm"/>
                      <stm:SetState Name="AfterPrefix"/>
                      <Execute Statement="ValidEndState:= True"/>
                    </On>
                    <On Select="cMilliOrMeter">
                      <Choose>
                        <When Expression="SiUnit = TSiUnit.Meter">
                          <stm:SetState Name="AfterMilliOrMeter2"/>
                          <Execute Statement="ValidEndState:= True"/>
                        </When>
                        <Otherwise>
                          <Execute Statement="Scale:= cScaleMilli"/>
                          <stm:SetState Name="AfterPrefix"/>
                          <Execute Statement="ValidEndState:= True"/>
                        </Otherwise>
                      </Choose>
                    </On>
                    <On Select="cMicro, cMicroAlt, cMicroAlt2">
                      <Execute Statement="Scale:= cScaleMicro"/>
                      <stm:SetState Name="AfterPrefix"/>
                      <Execute Statement="ValidEndState:= True"/>
                    </On>
                    <On Select="cNano">
                      <Execute Statement="Scale:= cScaleNano"/>
                      <stm:SetState Name="AfterPrefix"/>
                      <Execute Statement="ValidEndState:= True"/>
                    </On>
                    <On Select="cPico">
                      <Execute Statement="Scale:= cScalePico"/>
                      <stm:SetState Name="AfterPrefix"/>
                      <Execute Statement="ValidEndState:= True"/>
                    </On>
                    <On Select="cFemto">
                      <Execute Statement="Scale:= cScaleFemto"/>
                      <stm:SetState Name="AfterPrefix"/>
                      <Execute Statement="ValidEndState:= True"/>
                    </On>
                    <On Select="cOhm">
                      <Exit Condition="SiUnit &lt;&gt; TSiUnit.Ohm"/>
                      <stm:SetState Name="Final"/>
                      <Execute Statement="ValidEndState:= True"/>
                    </On>
                    <On Select="cWatt">
                      <Exit Condition="SiUnit &lt;&gt; TSiUnit.Watt"/>
                      <stm:SetState Name="Final"/>
                      <Execute Statement="ValidEndState:= True"/>
                    </On>
                    <On Select="cFarad">
                      <Exit Condition="SiUnit &lt;&gt; TSiUnit.Farad"/>
                      <stm:SetState Name="Final"/>
                      <Execute Statement="ValidEndState:= True"/>
                    </On>
                    <On Select="cVolt">
                      <Exit Condition="SiUnit &lt;&gt; TSiUnit.Volt"/>
                      <stm:SetState Name="Final"/>
                      <Execute Statement="ValidEndState:= True"/>
                    </On>
                    <On Select="cAmp">
                      <Exit Condition="SiUnit &lt;&gt; TSiUnit.Amp"/>
                      <stm:SetState Name="Final"/>
                      <Execute Statement="ValidEndState:= True"/>
                    </On>
                    <On Select="cPerc">
                      <Exit Condition="SiUnit &lt;&gt; TSiUnit.Perc"/>
                      <stm:SetState Name="Final"/>
                      <Execute Statement="ValidEndState:= True"/>
                    </On>
                    <On Select="cHenry_Hz">
                      <Case Expression="SiUnit">
                        <On Select="TSiUnit.Henry">
                          <stm:SetState Name="Final"/>
                          <Execute Statement="ValidEndState:= True"/>
                        </On>
                        <On Select="TSiUnit.Hz">
                          <stm:SetState Name="AfterFirstUnitChar"/>
                          <Execute Statement="ValidEndState:= False"/>
                        </On>
                        <Otherwise>
                          <Exit/>
                        </Otherwise>
                      </Case>
                    </On>
                    <On Select="cSecond">
                      <Exit Condition="SiUnit &lt;&gt; TSiUnit.Second"/>
                      <stm:SetState Name="Final"/>
                      <Execute Statement="ValidEndState:= True"/>
                    </On>
                    <Otherwise>
                      <Exit/>
                    </Otherwise>
                  </Case>
                </stm:State>
                <stm:State Name="AfterNumSep">
                  <Case Expression="ChrI" Optimalisation="integermapping" OrdinalType="widechar">
                    <On Select="cSpace, cTab">
                      <stm:SetState Name="Final"/>
                      <Execute Statement="ValidEndState:= True"/>
                    </On>
                    <On Select="cTera">
                      <Execute Statement="Scale:= cScaleTera"/>
                      <stm:SetState Name="AfterPrefix"/>
                      <Execute Statement="ValidEndState:= True"/>
                    </On>
                    <On Select="cGiga">
                      <Execute Statement="Scale:= cScaleGiga"/>
                      <stm:SetState Name="AfterPrefix"/>
                      <Execute Statement="ValidEndState:= True"/>
                    </On>
                    <On Select="cMega">
                      <Execute Statement="Scale:= cScaleMega"/>
                      <stm:SetState Name="AfterPrefix"/>
                      <Execute Statement="ValidEndState:= True"/>
                    </On>
                    <On Select="cKilo">
                      <Execute Statement="Scale:= cScaleKilo"/>
                      <stm:SetState Name="AfterPrefix"/>
                      <Execute Statement="ValidEndState:= True"/>
                    </On>
                    <On Select="cK">
                      <Exit Condition="SiUnit &lt;&gt; TSiUnit.Ohm"/>
                      <Execute Statement="Scale:= cScaleKilo"/>
                      <stm:SetState Name="AfterPrefix"/>
                      <Execute Statement="ValidEndState:= True"/>
                    </On>
                    <On Select="cMilliOrMeter">
                      <Choose>
                        <When Expression="SiUnit = TSiUnit.Meter">
                          <stm:SetState Name="AfterMilliOrMeter2"/>
                          <Execute Statement="ValidEndState:= True"/>
                        </When>
                        <Otherwise>
                          <Execute Statement="Scale:= cScaleMilli"/>
                          <stm:SetState Name="AfterPrefix"/>
                          <Execute Statement="ValidEndState:= True"/>
                        </Otherwise>
                      </Choose>
                    </On>
                    <On Select="cMicro, cMicroAlt, cMicroAlt2">
                      <Execute Statement="Scale:= cScaleMicro"/>
                      <stm:SetState Name="AfterPrefix"/>
                      <Execute Statement="ValidEndState:= True"/>
                    </On>
                    <On Select="cNano">
                      <Execute Statement="Scale:= cScaleNano"/>
                      <stm:SetState Name="AfterPrefix"/>
                      <Execute Statement="ValidEndState:= True"/>
                    </On>
                    <On Select="cPico">
                      <Execute Statement="Scale:= cScalePico"/>
                      <stm:SetState Name="AfterPrefix"/>
                      <Execute Statement="ValidEndState:= True"/>
                    </On>
                    <On Select="cFemto">
                      <Execute Statement="Scale:= cScaleFemto"/>
                      <stm:SetState Name="AfterPrefix"/>
                      <Execute Statement="ValidEndState:= True"/>
                    </On>
                    <On Select="cOhm">
                      <Exit Condition="SiUnit &lt;&gt; TSiUnit.Ohm"/>
                      <stm:SetState Name="Final"/>
                      <Execute Statement="ValidEndState:= True"/>
                    </On>
                    <On Select="cWatt">
                      <Exit Condition="SiUnit &lt;&gt; TSiUnit.Watt"/>
                      <stm:SetState Name="Final"/>
                      <Execute Statement="ValidEndState:= True"/>
                    </On>
                    <On Select="cFarad">
                      <Exit Condition="SiUnit &lt;&gt; TSiUnit.Farad"/>
                      <stm:SetState Name="Final"/>
                      <Execute Statement="ValidEndState:= True"/>
                    </On>
                    <On Select="cVolt">
                      <Exit Condition="SiUnit &lt;&gt; TSiUnit.Volt"/>
                      <stm:SetState Name="Final"/>
                      <Execute Statement="ValidEndState:= True"/>
                    </On>
                    <On Select="cAmp">
                      <Exit Condition="SiUnit &lt;&gt; TSiUnit.Amp"/>
                      <stm:SetState Name="Final"/>
                      <Execute Statement="ValidEndState:= True"/>
                    </On>
                    <On Select="cPerc">
                      <Exit Condition="SiUnit &lt;&gt; TSiUnit.Perc"/>
                      <stm:SetState Name="Final"/>
                      <Execute Statement="ValidEndState:= True"/>
                    </On>
                    <On Select="cHenry_Hz">
                      <Case Expression="SiUnit">
                        <On Select="TSiUnit.Henry">
                          <stm:SetState Name="Final"/>
                          <Execute Statement="ValidEndState:= True"/>
                        </On>
                        <On Select="TSiUnit.Hz">
                          <stm:SetState Name="AfterFirstUnitChar"/>
                          <Execute Statement="ValidEndState:= False"/>
                        </On>
                        <Otherwise>
                          <Exit/>
                        </Otherwise>
                      </Case>
                    </On>
                    <On Select="cSecond">
                      <Exit Condition="SiUnit &lt;&gt; TSiUnit.Second"/>
                      <stm:SetState Name="Final"/>
                      <Execute Statement="ValidEndState:= True"/>
                    </On>
                    <Otherwise>
                      <Exit/>
                    </Otherwise>
                  </Case>
                </stm:State>
                <stm:State Name="AfterPrefix">
                  <Case Expression="ChrI" Optimalisation="integermapping" OrdinalType="widechar">
                    <On Select="cSpace, cTab">
                      <stm:SetState Name="Final"/>
                      <Execute Statement="ValidEndState:= True"/>
                    </On>
                    <On Select="cMeter">
                      <stm:SetState Name="Final"/>
                      <Execute Statement="ValidEndState:= True"/>
                    </On>
                    <On Select="cOhm">
                      <Exit Condition="SiUnit &lt;&gt; TSiUnit.Ohm"/>
                      <stm:SetState Name="Final"/>
                      <Execute Statement="ValidEndState:= True"/>
                    </On>
                    <On Select="cWatt">
                      <Exit Condition="SiUnit &lt;&gt; TSiUnit.Watt"/>
                      <stm:SetState Name="Final"/>
                      <Execute Statement="ValidEndState:= True"/>
                    </On>
                    <On Select="cFarad">
                      <Exit Condition="SiUnit &lt;&gt; TSiUnit.Farad"/>
                      <stm:SetState Name="Final"/>
                      <Execute Statement="ValidEndState:= True"/>
                    </On>
                    <On Select="cVolt">
                      <Exit Condition="SiUnit &lt;&gt; TSiUnit.Volt"/>
                      <stm:SetState Name="Final"/>
                      <Execute Statement="ValidEndState:= True"/>
                    </On>
                    <On Select="cAmp">
                      <Exit Condition="SiUnit &lt;&gt; TSiUnit.Amp"/>
                      <stm:SetState Name="Final"/>
                      <Execute Statement="ValidEndState:= True"/>
                    </On>
                    <On Select="cPerc">
                      <Exit Condition="SiUnit &lt;&gt; TSiUnit.Perc"/>
                      <stm:SetState Name="Final"/>
                      <Execute Statement="ValidEndState:= True"/>
                    </On>
                    <On Select="cHenry_Hz">
                      <Case Expression="SiUnit">
                        <On Select="TSiUnit.Henry">
                          <stm:SetState Name="Final"/>
                          <Execute Statement="ValidEndState:= True"/>
                        </On>
                        <On Select="TSiUnit.Hz">
                          <stm:SetState Name="AfterFirstUnitChar"/>
                          <Execute Statement="ValidEndState:= False"/>
                        </On>
                        <Otherwise>
                          <Exit/>
                        </Otherwise>
                      </Case>
                    </On>
                    <On Select="cSecond">
                      <Exit Condition="SiUnit &lt;&gt; TSiUnit.Second"/>
                      <stm:SetState Name="Final"/>
                      <Execute Statement="ValidEndState:= True"/>
                    </On>
                    <Otherwise>
                      <Exit/>
                    </Otherwise>
                  </Case>
                </stm:State>
                <stm:State Name="AfterMilliOrMeter">
                  <Case Expression="ChrI" Optimalisation="integermapping" OrdinalType="widechar">
                    <On Select="cSpace, cTab">
                      <stm:SetState Name="Final"/>
                      <Execute Statement="ValidEndState:= True"/>
                    </On>
                    <On Select="c0">
                      <Execute Statement="FracScale:= FracScale - 1"/>
                      <Execute Statement="Digits.Add(0)" Condition="(Digits.Count &lt;&gt;0)"/>
                      <stm:SetState Name="InPrefixFrac"/>
                      <Execute Statement="ValidEndState:= True"/>
                    </On>
                    <On Select="c1..c9">
                      <Execute Statement="FracScale:= FracScale - 1"/>
                      <Execute Statement="Digits.Add(ChrI - CharOrd(c0))"/>
                      <stm:SetState Name="InPrefixFrac"/>
                      <Execute Statement="ValidEndState:= True"/>
                    </On>
                    <On Select="cMeter">
                      <Execute Statement="Scale:= cScaleMilli"/>
                      <stm:SetState Name="Final"/>
                      <Execute Statement="ValidEndState:= True"/>
                    </On>
                    <Otherwise>
                      <Exit/>
                    </Otherwise>
                  </Case>
                </stm:State>
                <stm:State Name="AfterPrefixFracSep">
                  <Case Expression="ChrI" Optimalisation="integermapping" OrdinalType="widechar">
                    <On Select="cSpace, cTab">
                      <stm:SetState Name="Final"/>
                      <Execute Statement="ValidEndState:= True"/>
                    </On>
                    <On Select="c0">
                      <Execute Statement="FracScale:= FracScale - 1"/>
                      <Execute Statement="Digits.Add(0)" Condition="(Digits.Count &lt;&gt;0)"/>
                      <stm:SetState Name="InPrefixFrac"/>
                      <Execute Statement="ValidEndState:= True"/>
                    </On>
                    <On Select="c1..c9">
                      <Execute Statement="FracScale:= FracScale - 1"/>
                      <Execute Statement="Digits.Add(ChrI - CharOrd(c0))"/>
                      <stm:SetState Name="InPrefixFrac"/>
                      <Execute Statement="ValidEndState:= True"/>
                    </On>
                    <On Select="cMeter">
                      <stm:SetState Name="Final"/>
                      <Execute Statement="ValidEndState:= True"/>
                    </On>
                    <On Select="cOhm">
                      <Exit Condition="SiUnit &lt;&gt; TSiUnit.Ohm"/>
                      <stm:SetState Name="Final"/>
                      <Execute Statement="ValidEndState:= True"/>
                    </On>
                    <On Select="cWatt">
                      <Exit Condition="SiUnit &lt;&gt; TSiUnit.Watt"/>
                      <stm:SetState Name="Final"/>
                      <Execute Statement="ValidEndState:= True"/>
                    </On>
                    <On Select="cFarad">
                      <Exit Condition="SiUnit &lt;&gt; TSiUnit.Farad"/>
                      <stm:SetState Name="Final"/>
                      <Execute Statement="ValidEndState:= True"/>
                    </On>
                    <On Select="cVolt">
                      <Exit Condition="SiUnit &lt;&gt; TSiUnit.Volt"/>
                      <stm:SetState Name="Final"/>
                      <Execute Statement="ValidEndState:= True"/>
                    </On>
                    <On Select="cAmp">
                      <Exit Condition="SiUnit &lt;&gt; TSiUnit.Amp"/>
                      <stm:SetState Name="Final"/>
                      <Execute Statement="ValidEndState:= True"/>
                    </On>
                    <On Select="cPerc">
                      <Exit Condition="SiUnit &lt;&gt; TSiUnit.Perc"/>
                      <stm:SetState Name="Final"/>
                      <Execute Statement="ValidEndState:= True"/>
                    </On>
                    <On Select="cHenry_Hz">
                      <Case Expression="SiUnit">
                        <On Select="TSiUnit.Henry">
                          <stm:SetState Name="Final"/>
                          <Execute Statement="ValidEndState:= True"/>
                        </On>
                        <On Select="TSiUnit.Hz">
                          <stm:SetState Name="AfterFirstUnitChar"/>
                          <Execute Statement="ValidEndState:= False"/>
                        </On>
                        <Otherwise>
                          <Exit/>
                        </Otherwise>
                      </Case>
                    </On>
                    <On Select="cSecond">
                      <Exit Condition="SiUnit &lt;&gt; TSiUnit.Second"/>
                      <stm:SetState Name="Final"/>
                      <Execute Statement="ValidEndState:= True"/>
                    </On>
                    <Otherwise>
                      <Exit/>
                    </Otherwise>
                  </Case>
                </stm:State>
                <stm:State Name="AfterUnitFracSep">
                  <Case Expression="ChrI" Optimalisation="integermapping" OrdinalType="widechar">
                    <On Select="cSpace, cTab">
                      <stm:SetState Name="Final"/>
                      <Execute Statement="ValidEndState:= True"/>
                    </On>
                    <On Select="c0">
                      <Execute Statement="FracScale:= FracScale - 1"/>
                      <Execute Statement="Digits.Add(0)" Condition="(Digits.Count &lt;&gt;0)"/>
                      <stm:SetState Name="InUnitFrac"/>
                      <Execute Statement="ValidEndState:= True"/>
                    </On>
                    <On Select="c1..c9">
                      <Execute Statement="FracScale:= FracScale - 1"/>
                      <Execute Statement="Digits.Add(ChrI - CharOrd(c0))"/>
                      <stm:SetState Name="InUnitFrac"/>
                      <Execute Statement="ValidEndState:= True"/>
                    </On>
                    <Otherwise>
                      <Exit/>
                    </Otherwise>
                  </Case>
                </stm:State>
                <stm:State Name="InUnitFrac">
                  <Case Expression="ChrI" Optimalisation="integermapping" OrdinalType="widechar">
                    <On Select="cSpace, cTab">
                      <stm:SetState Name="Final"/>
                      <Execute Statement="ValidEndState:= True"/>
                    </On>
                    <On Select="c0">
                      <Execute Statement="FracScale:= FracScale - 1"/>
                      <Execute Statement="Digits.Add(0)" Condition="(Digits.Count &lt;&gt;0)"/>
                    </On>
                    <On Select="c1..c9">
                      <Execute Statement="FracScale:= FracScale - 1"/>
                      <Execute Statement="Digits.Add(ChrI - CharOrd(c0))"/>
                    </On>
                    <Otherwise>
                      <Exit/>
                    </Otherwise>
                  </Case>
                </stm:State>
                <stm:State Name="InPrefixFrac">
                  <Case Expression="ChrI" Optimalisation="integermapping" OrdinalType="widechar">
                    <On Select="cSpace, cTab">
                      <stm:SetState Name="Final"/>
                      <Execute Statement="ValidEndState:= True"/>
                    </On>
                    <On Select="c0">
                      <Execute Statement="FracScale:= FracScale - 1"/>
                      <Execute Statement="Digits.Add(0)" Condition="(Digits.Count &lt;&gt;0)"/>
                    </On>
                    <On Select="c1..c9">
                      <Execute Statement="FracScale:= FracScale - 1"/>
                      <Execute Statement="Digits.Add(ChrI - CharOrd(c0))"/>
                    </On>
                    <On Select="cMeter">
                      <stm:SetState Name="Final"/>
                      <Execute Statement="ValidEndState:= True"/>
                    </On>
                    <On Select="cOhm">
                      <Exit Condition="SiUnit &lt;&gt; TSiUnit.Ohm"/>
                      <stm:SetState Name="Final"/>
                      <Execute Statement="ValidEndState:= True"/>
                    </On>
                    <On Select="cWatt">
                      <Exit Condition="SiUnit &lt;&gt; TSiUnit.Watt"/>
                      <stm:SetState Name="Final"/>
                      <Execute Statement="ValidEndState:= True"/>
                    </On>
                    <On Select="cFarad">
                      <Exit Condition="SiUnit &lt;&gt; TSiUnit.Farad"/>
                      <stm:SetState Name="Final"/>
                      <Execute Statement="ValidEndState:= True"/>
                    </On>
                    <On Select="cVolt">
                      <Exit Condition="SiUnit &lt;&gt; TSiUnit.Volt"/>
                      <stm:SetState Name="Final"/>
                      <Execute Statement="ValidEndState:= True"/>
                    </On>
                    <On Select="cAmp">
                      <Exit Condition="SiUnit &lt;&gt; TSiUnit.Amp"/>
                      <stm:SetState Name="Final"/>
                      <Execute Statement="ValidEndState:= True"/>
                    </On>
                    <On Select="cPerc">
                      <Exit Condition="SiUnit &lt;&gt; TSiUnit.Perc"/>
                      <stm:SetState Name="Final"/>
                      <Execute Statement="ValidEndState:= True"/>
                    </On>
                    <On Select="cHenry_Hz">
                      <Case Expression="SiUnit">
                        <On Select="TSiUnit.Henry">
                          <stm:SetState Name="Final"/>
                          <Execute Statement="ValidEndState:= True"/>
                        </On>
                        <On Select="TSiUnit.Hz">
                          <stm:SetState Name="AfterFirstUnitChar"/>
                          <Execute Statement="ValidEndState:= False"/>
                        </On>
                        <Otherwise>
                          <Exit/>
                        </Otherwise>
                      </Case>
                    </On>
                    <On Select="cSecond">
                      <Exit Condition="SiUnit &lt;&gt; TSiUnit.Second"/>
                      <stm:SetState Name="Final"/>
                      <Execute Statement="ValidEndState:= True"/>
                    </On>
                    <Otherwise>
                      <Exit/>
                    </Otherwise>
                  </Case>
                </stm:State>
                <stm:State Name="AfterFirstUnitChar">
                  <Case Expression="ChrI" Optimalisation="integermapping" OrdinalType="widechar">
                    <On Select="cHz2">
                      <Exit Condition="SiUnit &lt;&gt; TSiUnit.Hz"/>
                      <stm:SetState Name="Final"/>
                      <Execute Statement="ValidEndState:= True"/>
                    </On>
                    <Otherwise>
                      <Exit/>
                    </Otherwise>
                  </Case>
                </stm:State>
                <stm:State Name="AfterMilliOrMeter2">
                  <Case Expression="ChrI" Optimalisation="integermapping" OrdinalType="widechar">
                    <On Select="cSpace, cTab">
                      <stm:SetState Name="Final"/>
                      <Execute Statement="ValidEndState:= True"/>
                    </On>
                    <Otherwise>
                      <Exit/>
                    </Otherwise>
                  </Case>
                </stm:State>
                <stm:State Name="Final">
                  <Case Expression="ChrI" Optimalisation="integermapping" OrdinalType="widechar">
                    <On Select="cSpace, cTab">
                    </On>
                    <Otherwise>
                      <Exit/>
                    </Otherwise>
                  </Case>
                </stm:State>
                <!-->->-->
              </stm:HandleStates>
            </StringLoop>
          </stm:StateHandler>
          <Exit Condition="not ValidEndState"/>
          <Execute Statement="IntValue:= Digits.GetDecimal(Scale + FracScale, IsNegative) ~ UnitStr"/>
        </Object.Use>
        <Exit Result="True"/>
      </Block>
    </Function>

    <Procedure Identifier="TUnitConvertor.Init">
      <Parameters>
        <Parameter Identifier="SiUnit" Type="TSiUnit"/>
      </Parameters>
      <Block>
        <Execute Statement="Self.SiUnit:= SiUnit"/>
        <Case Expression="SiUnit" Optimalisation="integermapping">
          <On Select="TSiUnit.Farad">
            <Execute Statement="AllowPrefixMicro:= True"/>
            <Execute Statement="AllowPrefixNano:= True"/>
            <Execute Statement="AllowPrefixPico:= True"/>
          </On>
          <On Select="TSiUnit.Perc">
          </On>
          <Otherwise>
            <Execute Statement="AllowPrefixTera:= False"/>
            <Execute Statement="AllowPrefixGiga:= True"/>
            <Execute Statement="AllowPrefixMega:= True"/>
            <Execute Statement="AllowPrefixKilo:= True"/>
            <Execute Statement="AllowPrefixMilli:= True"/>
            <Execute Statement="AllowPrefixMicro:= True"/>
            <Execute Statement="AllowPrefixNano:= True"/>
            <Execute Statement="AllowPrefixPico:= True"/>
            <Execute Statement="AllowPrefixFemto:= True"/>
          </Otherwise>
        </Case>
        <Case Expression="SiUnit" Optimalisation="integermapping">
          <On Select="TSiUnit.None">
          </On>
          <On Select="TSiUnit.Volt">
            <Execute Statement="UnitStr:= ⌠V⌡"/>
          </On>
          <On Select="TSiUnit.Amp">
            <Execute Statement="UnitStr:= ⌠A⌡"/>
          </On>
          <On Select="TSiUnit.Ohm">
            <Execute Statement="UnitStr:= ⌠Ω⌡"/>
          </On>
          <On Select="TSiUnit.Farad">
            <Execute Statement="UnitStr:= ⌠F⌡"/>
          </On>
          <On Select="TSiUnit.Henry">
            <Execute Statement="UnitStr:= ⌠H⌡"/>
          </On>
          <On Select="TSiUnit.Perc">
            <Execute Statement="UnitStr:= ⌠%⌡"/>
          </On>
          <On Select="TSiUnit.Watt">
            <Execute Statement="UnitStr:= ⌠W⌡"/>
          </On>
          <On Select="TSiUnit.Meter">
            <Execute Statement="UnitStr:= ⌠m⌡"/>
          </On>
          <On Select="TSiUnit.Hz">
            <Execute Statement="UnitStr:= ⌠Hz⌡"/>
          </On>
          <On Select="TSiUnit.Second">
            <Execute Statement="UnitStr:= ⌠s⌡"/>
          </On>
          <Otherwise>
            <Raise Expression="Exception.Create(Format('TUnitConvertor.Init - unsupported UnitKind: %d', SiUnit))"/>
          </Otherwise>
        </Case>
      </Block>
    </Procedure>

    <Constructor Identifier="TUnitConvertor.Create">
      <Parameters>
        <Parameter Identifier="SiUnit" Type="TSiUnit"/>
      </Parameters>
      <Block>
        <Execute Statement="Init(SiUnit)"/>
      </Block>
    </Constructor>

    <Function Identifier="GetUnitConvertor" Type="TUnitConvertor">
      <Parameters>
        <Parameter Identifier="SiUnit" Type="TSiUnit"/>
      </Parameters>
      <Block>
        <Case Expression="SiUnit" Optimalisation="integermapping">
          <!--<-<GetConverter.Case-->
          <On Select="TSiUnit.None">
            <Choose>
              <When Expression="IsEmpty(ucNone)">
                <Execute Statement="Result:= TUnitConvertor.Create(SiUnit)"/>
                <Execute Statement="ucNone:= Result"/>
              </When>
              <Otherwise>
                <Execute Statement="Result:= ucNone"/>
              </Otherwise>
            </Choose>
          </On>
          <On Select="TSiUnit.Ohm">
            <Choose>
              <When Expression="IsEmpty(ucOhm)">
                <Execute Statement="Result:= TUnitConvertor.Create(SiUnit)"/>
                <Execute Statement="ucOhm:= Result"/>
              </When>
              <Otherwise>
                <Execute Statement="Result:= ucOhm"/>
              </Otherwise>
            </Choose>
          </On>
          <On Select="TSiUnit.Watt">
            <Choose>
              <When Expression="IsEmpty(ucWatt)">
                <Execute Statement="Result:= TUnitConvertor.Create(SiUnit)"/>
                <Execute Statement="ucWatt:= Result"/>
              </When>
              <Otherwise>
                <Execute Statement="Result:= ucWatt"/>
              </Otherwise>
            </Choose>
          </On>
          <On Select="TSiUnit.Farad">
            <Choose>
              <When Expression="IsEmpty(ucFarad)">
                <Execute Statement="Result:= TUnitConvertor.Create(SiUnit)"/>
                <Execute Statement="ucFarad:= Result"/>
              </When>
              <Otherwise>
                <Execute Statement="Result:= ucFarad"/>
              </Otherwise>
            </Choose>
          </On>
          <On Select="TSiUnit.Henry">
            <Choose>
              <When Expression="IsEmpty(ucHenry)">
                <Execute Statement="Result:= TUnitConvertor.Create(SiUnit)"/>
                <Execute Statement="ucHenry:= Result"/>
              </When>
              <Otherwise>
                <Execute Statement="Result:= ucHenry"/>
              </Otherwise>
            </Choose>
          </On>
          <On Select="TSiUnit.Volt">
            <Choose>
              <When Expression="IsEmpty(ucVolt)">
                <Execute Statement="Result:= TUnitConvertor.Create(SiUnit)"/>
                <Execute Statement="ucVolt:= Result"/>
              </When>
              <Otherwise>
                <Execute Statement="Result:= ucVolt"/>
              </Otherwise>
            </Choose>
          </On>
          <On Select="TSiUnit.Amp">
            <Choose>
              <When Expression="IsEmpty(ucAmp)">
                <Execute Statement="Result:= TUnitConvertor.Create(SiUnit)"/>
                <Execute Statement="ucAmp:= Result"/>
              </When>
              <Otherwise>
                <Execute Statement="Result:= ucAmp"/>
              </Otherwise>
            </Choose>
          </On>
          <On Select="TSiUnit.Perc">
            <Choose>
              <When Expression="IsEmpty(ucPerc)">
                <Execute Statement="Result:= TUnitConvertor.Create(SiUnit)"/>
                <Execute Statement="ucPerc:= Result"/>
              </When>
              <Otherwise>
                <Execute Statement="Result:= ucPerc"/>
              </Otherwise>
            </Choose>
          </On>
          <On Select="TSiUnit.Hz">
            <Choose>
              <When Expression="IsEmpty(ucHz)">
                <Execute Statement="Result:= TUnitConvertor.Create(SiUnit)"/>
                <Execute Statement="ucHz:= Result"/>
              </When>
              <Otherwise>
                <Execute Statement="Result:= ucHz"/>
              </Otherwise>
            </Choose>
          </On>
          <On Select="TSiUnit.Meter">
            <Choose>
              <When Expression="IsEmpty(ucMeter)">
                <Execute Statement="Result:= TUnitConvertor.Create(SiUnit)"/>
                <Execute Statement="ucMeter:= Result"/>
              </When>
              <Otherwise>
                <Execute Statement="Result:= ucMeter"/>
              </Otherwise>
            </Choose>
          </On>
          <On Select="TSiUnit.Second">
            <Choose>
              <When Expression="IsEmpty(ucSecond)">
                <Execute Statement="Result:= TUnitConvertor.Create(SiUnit)"/>
                <Execute Statement="ucSecond:= Result"/>
              </When>
              <Otherwise>
                <Execute Statement="Result:= ucSecond"/>
              </Otherwise>
            </Choose>
          </On>
          <!-->->-->
          <Otherwise>
            <Raise Expression="Exception.Create(Format('Invalid SiUnit: %d', SiUnit))"/>
          </Otherwise>
        </Case>
      </Block>
    </Function>

  </Procedures>

  <Initialization>
    <Execute Statement="MaskManager:= TAnsiMaskManager.Create"/>
    <Execute Statement="MaskManager.Groups:= True"/>
    <Execute Statement="MaskManager.CaseSensitive:= True"/>
    <Execute Statement="MaskManager.RepeatingGroup:= True"/>
    <Execute Statement="InitSymbolComponentKindIndex(SymbolComponentKindIndex)"/>
    <ForLoop Indexer="I" From="TSiUnit.Low" To="TSiUnit.High">
      <Execute Statement="GetUnitConvertor(I)"/>
    </ForLoop>
  </Initialization>

  <Finalization>
    <Free Identifier="SymbolComponentKindIndex"/>
    <Free Identifier="MaskManager"/>
  </Finalization>

</pkg:Library>